<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lizonglin313.github.io/</id>
    <title>Big Carrot</title>
    <updated>2021-03-10T08:51:19.146Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lizonglin313.github.io/"/>
    <link rel="self" href="https://lizonglin313.github.io/atom.xml"/>
    <subtitle>脚踏实地，不要妄自菲薄</subtitle>
    <logo>https://lizonglin313.github.io/images/avatar.png</logo>
    <icon>https://lizonglin313.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Big Carrot</rights>
    <entry>
        <title type="html"><![CDATA[防火墙]]></title>
        <id>https://lizonglin313.github.io/post/fang-huo-qiang</id>
        <link href="https://lizonglin313.github.io/post/fang-huo-qiang">
        </link>
        <updated>2021-03-10T05:48:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="防火墙概述">防火墙概述</h2>
<p>防火墙位于一个可信的内部网络与一个不可信的外界网络之间，用于保护内部网络免受非法用户的入侵。在内网和外网之间构筑保护层，通过网络路由和信息过滤实现网络的安全。</p>
<h4 id="防火墙的特性">防火墙的特性</h4>
<ol>
<li>内部网络和外部网络之间所有网络数据必须经过防火墙</li>
<li>只有符合安全策略的数据流才能通过防火墙</li>
<li>防火墙自身应具有非常强的抗攻击免疫力</li>
</ol>
<h4 id="防火墙的功能">防火墙的功能</h4>
<ol>
<li>网络安全的屏障，可以极大程度的提高内部网络的安全性，过滤不安全的服务降低风险</li>
<li>强化网络安全策略，以防火墙为中心，通过配置安全软件，集中安全管理</li>
<li>对网络存取和访问进行审计监控，记录日志、统计数据、以便分析</li>
<li>防范内部信息的外泄</li>
</ol>
<h2 id="主要缺陷">主要缺陷</h2>
<ol>
<li>传统防火墙不能防范来自内部网络的攻击（新一代“分布式防火墙”则支持防范内部攻击）</li>
<li>防火墙不能防范不通过防火墙的攻击（必须让防火墙成为唯一的与外部网络连接的网络接口）</li>
<li>不能防范恶意代码的传输（防火墙不能扫描每一个数据包内的数据）</li>
<li>不能防范利用协议缺陷进行的攻击</li>
<li>不能防范利用服务器漏洞进行的攻击</li>
<li>不能防范未知的网络安全问题（被动式安全防护技术）</li>
<li>对已有的网络服务有一定的限制</li>
</ol>
<h2 id="性能评价指标">性能评价指标</h2>
<ol>
<li>传输层性能指标
<ul>
<li>TCP并发连接数：穿越防火墙的主机之间或者主机与防火墙之间能同时建立的最大连接数</li>
<li>最大TCP连接速率：防火墙维持的最大TCP连接建立速度，用以体现防火墙更新链接状态表的最大速率和实施反应能力</li>
</ul>
</li>
<li>网络层性能指标
<ul>
<li>吞吐量指标：没有丢帧情况下，防火墙能接受并转发的最大速率</li>
<li>时延指标：发送端口发出数据包经过防火墙后接收端口收到的时间间隔，有直通转发时延和存储转发时延两种</li>
<li>丢包率指标：正常稳定网络条件下，应该被转发但是由于缺少资源而没有被转发的数据包占全部数据包的百分比</li>
<li>背靠背缓冲指标：接受到以最小帧间隔传输的网络流量时，在不丢包的情况下所能处理的最大包数（缓冲能力）</li>
</ul>
</li>
<li>应用层性能指标
<ul>
<li>HTTP传输速率：被请求的目标数据通过防火墙的平均传输速率</li>
<li>最大HTTP事务处理速率：用户访问目标时，所能达到的最大速率</li>
</ul>
</li>
</ol>
<h2 id="功能评价指标">功能评价指标</h2>
<ol>
<li>服务平台支持：常见的系统平台如Linux、Unix等</li>
<li>LAN口支持：LAN口的类型、带宽、口数</li>
<li>协议支持：主要指对非TCP/IP协议族的支持，如IPX等</li>
<li>VPN支持：是否支持虚拟专网VPN功能，提供建立VPN隧道所需的IPSec、PPTP、专用协议以及在VPN中使用TCP/IP</li>
<li>加密支持：主要指是否支持VPN加密需要的加密算法如DES、3DES、RC4以及特殊的加密算法和硬件加密功能</li>
<li>认证支持：主要指防火墙提供的认证方式，如RADIUS、Keberos、PKI、口令等方式</li>
<li>访问控制：主要指防火墙通过包过滤、应用代理或传输层代理方式，实现对网络资源的访问控制</li>
<li>NAT支持：是否提供NAT功能，隐藏内部网络结构，提高内网安全</li>
<li>日志支持：完善的日志记录、存储、管理等</li>
<li>其他：病毒扫描、内容过滤、抵御DOS/DDOS、脚本攻击、实时入侵防御、防范IP欺骗</li>
</ol>
<h2 id="防火墙规则制定的两种原则及其各自特点">防火墙规则制定的两种原则及其各自特点</h2>
<h3 id="防火墙规则的分类">防火墙规则的分类：</h3>
<ol>
<li>高级政策</li>
</ol>
<p>用来定义受限制的网络许可和明确拒绝的服务内容、使用这些服务的方法以及例外条例</p>
<ol start="2">
<li>低级政策</li>
</ol>
<p>描述防火墙限制访问的具体实现及如何过滤高级政策定义的服务</p>
<h3 id="规则的特点">规则的特点：</h3>
<ul>
<li>保护内部信息资源的策略的实现和延伸</li>
<li>必须与网络访问活动密切相关</li>
<li>可靠稳妥，切合实际</li>
<li>实施各种不同的服务访问政策</li>
</ul>
<h3 id="设计原则">设计原则：</h3>
<ol>
<li>拒绝访问一切未予特许的服务（侧重安全性）</li>
<li>允许访问一切未被特别拒绝的服务（侧重灵活性和方便性）</li>
</ol>
<h2 id="包过滤技术和应用网关技术的区别">包过滤技术和应用网关技术的区别</h2>
<p>包过滤技术也称分组过滤技术，在网络层截获网络数据包，根据防火墙规则表，检测攻击行为，在网络层提供低级别的安全防护和控制。</p>
<p>应用网关技术又称为代理技术，采用协议代理服务，位于应用层，需要为每一种应用服务器设置专门的代理服务器。</p>
<h2 id="防火墙常见体系结构">防火墙常见体系结构</h2>
<ol>
<li>筛选路由器体系结构</li>
<li>单宿主堡垒主机体系结构</li>
<li>双宿主堡垒主机体系结构</li>
<li>屏蔽子网体系结构</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PKI技术]]></title>
        <id>https://lizonglin313.github.io/post/pki-ji-zhu</id>
        <link href="https://lizonglin313.github.io/post/pki-ji-zhu">
        </link>
        <updated>2021-03-09T01:28:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="public-key-infrastructure">Public Key Infrastructure</h2>
<p>PKI技术以非对称密钥技术为基础，以数字证书为媒介，将各参与实体的标识信息与公钥绑定在一起。通过特定接口为用户提供安全服务，包括加密、解密、数字签名、身份认证等；具有透明性、易用性、可扩展性、互操作性、多用性、支持多平台等基础设施共有的特点。</p>
<h2 id="pki系统内容">PKI系统内容</h2>
<h4 id="pki系统主要包括以下内容">PKI系统主要包括以下内容：</h4>
<ol>
<li>认证中心CA：证书的签发机构；负责签发证书、验证身份、登记、发布证书撤销列表CRL</li>
<li>证书库：颁发证书和撤销证书集中存放地</li>
<li>密钥备份及恢复系统</li>
<li>证书撤销处理系统：Certificate Revocation List</li>
<li>PKI应用接口系统</li>
</ol>
<h4 id="pki应用系统包括">PKI应用系统包括：</h4>
<ol>
<li>认证中心CA</li>
<li>X.500目录服务器：用于发布用户的证书以及证书注销列表</li>
<li>安全WWW服务器以及安全通信平台：通过SSL、IPsec等安全协议保证传输数据的机密性、完整性、真实性</li>
<li>安全应用系统</li>
</ol>
<h4 id="pki提供的服务">PKI提供的服务</h4>
<ol>
<li>安全登录</li>
<li>对终端用户透明：接口</li>
<li>全面的安全性：用统一的方式提供安全服务，保证信息的机密性、完整性、认证性、不可否认性</li>
</ol>
<h2 id="pki体系结构">PKI体系结构</h2>
<h3 id="paa">PAA</h3>
<p>Policy Approval Authority政策批准机构，创建PKI系统方阵、政策、批准PAA下属PCA政策，为PCA签发公钥证书，建立整个PKI体系的安全策略。</p>
<h3 id="pca">PCA</h3>
<p>Policy Certification Authority政策认证机构，制定本PCA的具体政策，如密钥的产生、长度、证书有效期、CRL处理；并为下属CA签发公钥证书。</p>
<h3 id="ca">CA</h3>
<p>Certificate Authority认证中心，担任具体的用户密钥对生成和签发，CRL的生成以及发布。核心功能是<strong>发放和管理数字证书</strong>。</p>
<p>在Fabric中，CA为组织内部节点发放证书，包含用户公钥、标识等信息，用户证书被CA签名发放。通过CA，第三方用户可以验证用户持有的证书是否由信任的CA分发，以验证用户的合法身份。</p>
<blockquote>
<p>PEM格式：Privacy-Enhanced Mail 隐私增强邮件。</p>
<p>此外，证书是公开的，因此不包含私钥信息。对于CA自己的证书，一般通过自签名为自己发放。</p>
</blockquote>
<p>以<code>ca.example.com-cert.pem</code>为例，这是一个证书文件，为了便于在网络上传送，通常证书会编码为<code>PEM</code>，如果我们直接查看它的内容：</p>
<pre><code class="language-shell">-----BEGIN CERTIFICATE-----
MIICPjCCAeOgAwIBAgIQUkJOmiAwvlYsCrOusBHa8jAKBggqhkjOPQQDAjBpMQsw
CQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy
YW5jaXNjbzEUMBIGA1UEChMLZXhhbXBsZS5jb20xFzAVBgNVBAMTDmNhLmV4YW1w
bGUuY29tMB4XDTIxMDIwNDExMjgwMFoXDTMxMDIwMjExMjgwMFowaTELMAkGA1UE
BhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBGcmFuY2lz
Y28xFDASBgNVBAoTC2V4YW1wbGUuY29tMRcwFQYDVQQDEw5jYS5leGFtcGxlLmNv
bTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABLobAhmABZmDnBUN7kYay3p9hX8K
3jC6gfo4cH+fMe15b1hwKCr5pcbyNrBLpzejsEu8HKLf6qjQgeqU99t8uOCjbTBr
MA4GA1UdDwEB/wQEAwIBpjAdBgNVHSUEFjAUBggrBgEFBQcDAgYIKwYBBQUHAwEw
DwYDVR0TAQH/BAUwAwEB/zApBgNVHQ4EIgQgjWGUej/DLisEDcDHYMST4otUkW0k
qigiB7mobi0r20MwCgYIKoZIzj0EAwIDSQAwRgIhALlqhswN20B9C5z5ZcPjtUsb
BE90U8L7RoO/VMQSi/NbAiEApyA0DvYXtm4El8G8w+9D8aE/y4aQGq4d+QKHZYIn
BXY=
-----END CERTIFICATE-----
</code></pre>
<p>由于Fabric中采用X.509证书，我们使用<code>openssl</code>查看<code>ca.example.com-cert.pem</code>的可读格式的内容，下面是一个X.509证书的主要内容：</p>
<pre><code class="language-shell">C:\Users\HP\Desktop\test-network\organizations\ordererOrganizations\example.com\ca&gt;openssl x509 -in ca.example.com-cert.pem -text -noout
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            52:42:4e:9a:20:30:be:56:2c:0a:b3:ae:b0:11:da:f2	# 序列号
        Signature Algorithm: ecdsa-with-SHA256	# 签名算法
        Issuer: C = US, ST = California, L = San Francisco, O = example.com, CN = ca.example.com #发放机构
        Validity	# 有效期
            Not Before: Feb  4 11:28:00 2021 GMT
            Not After : Feb  2 11:28:00 2031 GMT
        Subject: C = US, ST = California, L = San Francisco, O = example.com, CN = ca.example.com	# 证书持有人
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)	# 公钥
                pub:
                    04:ba:1b:02:19:80:05:99:83:9c:15:0d:ee:46:1a:
                    cb:7a:7d:85:7f:0a:de:30:ba:81:fa:38:70:7f:9f:
                    31:ed:79:6f:58:70:28:2a:f9:a5:c6:f2:36:b0:4b:
                    a7:37:a3:b0:4b:bc:1c:a2:df:ea:a8:d0:81:ea:94:
                    f7:db:7c:b8:e0
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment, Certificate Sign, CRL Sign
            X509v3 Extended Key Usage:
                TLS Web Client Authentication, TLS Web Server Authentication
            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Subject Key Identifier:
                8D:61:94:7A:3F:C3:2E:2B:04:0D:C0:C7:60:C4:93:E2:8B:54:91:6D:24:AA:28:22:07:B9:A8:6E:2D:2B:DB:43
    Signature Algorithm: ecdsa-with-SHA256	# CA对该证书的签名
         30:46:02:21:00:b9:6a:86:cc:0d:db:40:7d:0b:9c:f9:65:c3:
         e3:b5:4b:1b:04:4f:74:53:c2:fb:46:83:bf:54:c4:12:8b:f3:
         5b:02:21:00:a7:20:34:0e:f6:17:b6:6e:04:97:c1:bc:c3:ef:
         43:f1:a1:3f:cb:86:90:1a:ae:1d:f9:02:87:65:82:27:05:76
</code></pre>
<h4 id="ca证书的发放">CA证书的发放</h4>
<ul>
<li>离线发放：申请批准后，RA初始化申请者信息，在LDAP（Lightweight Directory Access Protocol）服务器添加信息；信息传给CA，生成参照号Ref.number以及认证码Auth.code；使用电子邮件或者打印，线下传递；申请人收到后在审查机构面对面领取证书，证书可存入光盘，软盘等</li>
<li>在线发放：申请批准后，RA初始化申请者信息，在LDAP（Lightweight Directory Access Protocol）服务器添加信息；信息传给CA，生成参照号Ref.number以及认证码Auth.code；申请人在本机登录网站通过浏览器安装Root CA证书，输入参照号和授权码获得证书。</li>
</ul>
<h4 id="crl">CRL</h4>
<p>证书废除原因主要有以下几点：</p>
<ul>
<li>密钥泄露：私钥泄露或者被破坏</li>
<li>从属变更：关于密钥的信息变更</li>
<li>终止使用：该密钥不再用于原来的用途或者证书已经到期</li>
<li>CA本身原因：CA系统私钥泄露</li>
<li>CA有理由怀疑证书细节不真实、不可信</li>
<li>证书持有者没有履行协议</li>
<li>证书持有者死亡、违反电子交易规则或者被判定为犯罪</li>
</ul>
<h3 id="ora">ORA</h3>
<p>Online Register Authority在线证书审查机构进行申请者身份认证，向CA提交证书申请，验证接受CA签发的证书，发放给申请者。</p>
<h3 id="ee">EE</h3>
<p>End Entity最终实体是PKI的最终使用者</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang接口]]></title>
        <id>https://lizonglin313.github.io/post/golang-jie-kou</id>
        <link href="https://lizonglin313.github.io/post/golang-jie-kou">
        </link>
        <updated>2021-02-21T09:37:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="golang的接口特性">Golang的接口特性</h2>
<ul>
<li>
<p>接口组装</p>
</li>
<li>
<p>兼有python、c++的灵活性</p>
</li>
<li>
<p>拥有java的类型检查</p>
</li>
<li>
<p>接口由<strong>使用者</strong>定义</p>
</li>
<li>
<p>接口的实现是<strong>隐式</strong>的，只要实现接口里的方法就行</p>
</li>
</ul>
<h2 id="定义和使用接口">定义和使用接口</h2>
<p>首先我们定义一个接口：</p>
<pre><code class="language-go">type Retriever interface {
    Get(url string) string	// 这个接口要实现Get方法
}

// 有这样一个函数，会使用Get方法
func download(r Retriever) string {
    return r.Get(&quot;nothing&quot;)
}
</code></pre>
<p>然后，我们去实现它：</p>
<pre><code class="language-go">type retriever struct {
    Contents string
}
// 需要实现Get方法
func (r retriever) Get(url string) string {
    return r.Contents
}
</code></pre>
<p>现在，我们有一个接口<code>Retriever</code>，它需要有一个<code>Get</code>方法。我们又定义了一个</p>
<p><code>retriever</code>对象，这个对象实现了<code>Get</code>方法，我们就可以说，<code>retriever</code>实现了<code>Retriever</code>这个接口，我们就可以用了。</p>
<pre><code class="language-go">func main() {
    var r Retriever
    r = retriever{&quot;my retriever&quot;}
    fmt.Println(download(r))
}
// my retriever
// Process finished with exit code 0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fabric2.X的配置文件（以test-network为例）]]></title>
        <id>https://lizonglin313.github.io/post/fabric2x-de-pei-zhi-wen-jian-yi-test-network-wei-li</id>
        <link href="https://lizonglin313.github.io/post/fabric2x-de-pei-zhi-wen-jian-yi-test-network-wei-li">
        </link>
        <updated>2021-02-10T14:38:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Hyperledger Fabric项目可以认为是一个<code>BaaS - Blockchain as a Service</code>，其主要的服务是为提供企业级的联盟链基础设施，多用于商业环境。和公有链不同的是，联盟链削弱中心化这一特性，通过灵活的身份准入、私有数据隔离、智能合约和链码等特性，使得使用者可以根据实际业务需求去设计自己的网络。而一个Fabric网络的结构，则依赖于许多网络配置文件。这些配置文件定义了参与网络的组织有哪些，每个组织的有哪些节点，以及这些节点的信息；除此之外，背书策略、排序策略、身份管理等内容也是通过这些配置文件来定义。</p>
</blockquote>
<h2 id="网络启动流程">网络启动流程</h2>
<h3 id="第一步-使用cryptogen工具生成参与网络组织实体的证书">第一步 使用<code>cryptogen</code>工具生成参与网络组织实体的证书</h3>
<p><code>cryptogen</code>工具用于生成证书文件，<code>PKI</code>、<code>CA</code>、<code>X.509</code>、<code>公钥体系</code>等密码学基础为整个Fabric提供了底层的安全支持，实现可信成员对网络资源的合法访问。启动一个网络的第一步，就是<strong>生成证书</strong>，</p>
<p>在Fabric2.2中，同先前所有生成证书的配置都在一个文件中不同的是，每一个组织在都有单独的配置文件来管理。<code>test-network</code>使用三个文件生成对应三个组织的证书，在脚本中，它们是这样的：</p>
<pre><code class="language-shell"> cryptogen generate --config=./organizations/cryptogen/crypto-config-org1.yaml --output=&quot;organizations&quot;
 ...
 cryptogen generate --config=./organizations/cryptogen/crypto-config-org2.yaml --output=&quot;organizations&quot;
 ...
 cryptogen generate --config=./organizations/cryptogen/crypto-config-orderer.yaml --output=&quot;organizations&quot;
 ...
</code></pre>
<p>这几个文件的组织形式是这样的：</p>
<pre><code class="language-shell">root@lizonglin-virtual-machine:/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network/organizations# tree
.
...
├── cryptogen   
│   ├── crypto-config-orderer.yaml
│   ├── crypto-config-org1.yaml
│   └── crypto-config-org2.yaml
└── fabric-ca
    ├── ordererOrg
    │   └── fabric-ca-server-config.yaml
    ├── org1
    │   └── fabric-ca-server-config.yaml
    ├── org2
    │   └── fabric-ca-server-config.yaml
    └── registerEnroll.sh

</code></pre>
<p><code>orderer</code>组织，两个<code>org</code>分别由三个文件定义。</p>
<p>使用<code>cryptogen</code>工具生成证书材料，三个文件内容如下：</p>
<ul>
<li>crypto-config-orderer.yaml</li>
</ul>
<pre><code class="language-shell"># ---------------------------------------------------------------------------
# &quot;OrdererOrgs&quot; - Definition of organizations managing orderer nodes
# ---------------------------------------------------------------------------
OrdererOrgs: # orderer组织来管理orderer节点，定义orderer节点所属组织的信息
  # ---------------------------------------------------------------------------
  # Orderer
  # ---------------------------------------------------------------------------
  - Name: Orderer	# 组织名称
    Domain: example.com	# 组织域名
    EnableNodeOUs: true	# 是否在msp下生成config.yaml文件（许可为节点组织单元的一员）
    # ---------------------------------------------------------------------------
    # &quot;Specs&quot; - See PeerOrgs for complete description
    # ---------------------------------------------------------------------------
    Specs:	# Hostname + Domain 组成了完整的Orderer组织的域名： orderer.example.name
      - Hostname: orderer
        SANS:
          - localhost
</code></pre>
<ul>
<li>crypto-config-org1.yaml</li>
</ul>
<pre><code class="language-shell"># ---------------------------------------------------------------------------
# &quot;PeerOrgs&quot; - Definition of organizations managing peer nodes
# ---------------------------------------------------------------------------
PeerOrgs:	# 这里定义的由peer节点组成的组织1的信息
  # ---------------------------------------------------------------------------
  # Org1
  # ---------------------------------------------------------------------------
  - Name: Org1	# 组织名称
    Domain: org1.example.com	# 组织域名
    EnableNodeOUs: true	# 生成msp文件
    # ---------------------------------------------------------------------------
    # &quot;Specs&quot;
    # ---------------------------------------------------------------------------
    # Uncomment this section to enable the explicit definition of hosts in your
    # configuration.  Most users will want to use Template, below
    #
    # Specs is an array of Spec entries.  Each Spec entry consists of two fields:
    #   - Hostname:   (Required) The desired hostname, sans the domain.
    #   - CommonName: (Optional) Specifies the template or explicit override for
    #                 the CN.  By default, this is the template:
    #
    #                              &quot;{{.Hostname}}.{{.Domain}}&quot;
    #
    #                 which obtains its values from the Spec.Hostname and
    #                 Org.Domain, respectively.
    # ---------------------------------------------------------------------------
    #   - Hostname: foo # implicitly &quot;foo.org1.example.com&quot;
    #     CommonName: foo27.org5.example.com # overrides Hostname-based FQDN set above
    #   - Hostname: bar
#   - Hostname: baz
    # ---------------------------------------------------------------------------
    # &quot;Template&quot;
    # ---------------------------------------------------------------------------
    # Allows for the definition of 1 or more hosts that are created sequentially
    # from a template. By default, this looks like &quot;peer%d&quot; from 0 to Count-1.
    # You may override the number of nodes (Count), the starting index (Start)
    # or the template used to construct the name (Hostname).
    #
    # Note: Template and Specs are not mutually exclusive.  You may define both
    # sections and the aggregate nodes will be created for you.  Take care with
    # name collisions
    # ---------------------------------------------------------------------------
    Template:
      Count: 1	# 节点个数
      SANS:
        - localhost
      # Start: 5
      # Hostname: {{.Prefix}}{{.Index}} # default
    # ---------------------------------------------------------------------------
    # &quot;Users&quot;
    # ---------------------------------------------------------------------------
    # Count: The number of user accounts _in addition_ to Admin
    # ---------------------------------------------------------------------------
    Users:
      Count: 1	# 管理员个数
</code></pre>
<ul>
<li>crypto-config-org2.yaml</li>
</ul>
<pre><code class="language-shell"># ---------------------------------------------------------------------------
# &quot;PeerOrgs&quot; - Definition of organizations managing peer nodes
# ---------------------------------------------------------------------------
PeerOrgs:
  # ---------------------------------------------------------------------------
  # Org2
  # ---------------------------------------------------------------------------
  - Name: Org2
    Domain: org2.example.com
    EnableNodeOUs: true
    # ---------------------------------------------------------------------------
    Template:
      Count: 1
      SANS:
        - localhost
    # ---------------------------------------------------------------------------
    Users:
      Count: 1
</code></pre>
<p>如果我们要配置三个组织：含有三个<code>orderer</code>节点的<code>Orderer</code>组织，两个包含两个<code>peer</code>节点的<code>Org</code>组织，那么配置文件应该这样写：</p>
<pre><code class="language-shell"># Orderer组织配置如下
OrdererOrgs:
	- Name: Orderer
	  Domain: example.com
	  EnableNodeOUs: true
	  Specs:
	  	- Hostname: orderer0
	  	- Hostname: orderer1
	  	- Hostname: orderer2
# Org1组织配置如下
PeerOrgs:
	- Name: Org1
	  Domain: org1.example.com
	  EnableNodeOUs: true
	  Template:
	  	Count: 2
	  Users:
	  	Count: 1
# Org2配置如下
PeerOrgs:
	- Name: Org2
	  Domain: org2.example.com
	  EnableNodeOUs: true
	  Template:
	  	Count: 2
	  Users:
	  	Count: 1
</code></pre>
<blockquote>
<p>关于使用<code>cryptogen</code>还是<code>CAs</code>去生成加密证书材料，Fabric是这样说的：</p>
<p>启动网络之前，每个组织需要生成加密材料，来定义网络中的组织。由于Fabric是许可链，网络中的每一个节点和用户需要使用证书以及密钥进行签名、验证等行为。此外，每个用户需要从属于某个组织，这个组织被视为网络的成员。你可以使用<code>Cryptogen tool</code>和<code>Fabric CAs</code>去生成组织的加密材料。</p>
<p>默认情况，测试网络使用<code>cryptogen</code>工具。这个工具在开发和测试环境中可以快速的生成证书材料和密钥，这些几乎在网络中处处都会用到。</p>
<p>同样的，也可以使用<code>Fabric CAs</code>生成证书、密钥等加密材料。<code>CAs</code>对证书进行签名并发放密钥，为每个组织生成一个合法的根信任。通过配置文件，使用<code>registerEnroll.sh</code>脚本生成实体、证书、<code>MSP</code>相关的文件。</p>
</blockquote>
<h3 id="第二步-使用configtxgen生成创世区块">第二步 使用<code>configtxgen</code>生成创世区块</h3>
<p><code>configtxgen</code>工具使用<code>configtx.yaml</code>文件生成创世区块，这个文件也用来定义网络。通过这个文件，我们可以定义联盟，也就是把组织是为联盟的成员。其中，需要用到每个成员的MSP证书（上一步已经生成），来创建通道MSP，作为每个组织的根信任。通道MSP使得组织可以被视为网络成员。<code>configtx.yaml</code>文件同样定义了每个<code>peer</code>组织的锚节点，之后还用于创建通道及更新锚节点。</p>
<pre><code class="language-shell">root@lizonglin-virtual-machine:/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network/configtx# cat configtx.yaml 
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
#

---
################################################################################
#
#   Section: Organizations
#
#   - This section defines the different organizational identities which will
#   be referenced later in the configuration.
#
################################################################################ 
Organizations: # 这个组织包含如下内容

    # SampleOrg defines an MSP using the sampleconfig.  It should never be used
    # in production but may be used as a template for other definitions
    - &amp;OrdererOrg	# 可以在yaml文件的其他地方引用这个名字
        # DefaultOrg defines the organization which is used in the sampleconfig
        # of the fabric.git development environment
        Name: OrdererOrg	# 名字

        # ID to load the MSP definition as
        ID: OrdererMSP	# MSPid

        # MSPDir is the filesystem path which contains the MSP configuration
        MSPDir: ../organizations/ordererOrganizations/example.com/msp	# 寻找msp的路径

        # Policies defines the set of policies at this level of the config tree
        # For organization policies, their canonical path is usually
        #   /Channel/&lt;Application|Orderer&gt;/&lt;OrgName&gt;/&lt;PolicyName&gt;
        Policies:	# 该组织的策略
            Readers:	# 读策略
                Type: Signature
                Rule: &quot;OR('OrdererMSP.member')&quot;	# 由该OrdererMSP的任何一个成员签名就可以读
            Writers:	# 写策略
                Type: Signature
                Rule: &quot;OR('OrdererMSP.member')&quot; # 同样的 OR 指 有一个就行
            Admins:		# 管理员
                Type: Signature
                Rule: &quot;OR('OrdererMSP.admin')&quot;

        OrdererEndpoints:	# 该组织端口号
            - orderer.example.com:7050

    - &amp;Org1 # 组织1，在yaml文件中 &amp;xxx 的写法使其可以在别处被引用
        # DefaultOrg defines the organization which is used in the sampleconfig
        # of the fabric.git development environment
        Name: Org1MSP

        # ID to load the MSP definition as
        ID: Org1MSP

        MSPDir: ../organizations/peerOrganizations/org1.example.com/msp

        # Policies defines the set of policies at this level of the config tree
        # For organization policies, their canonical path is usually
        #   /Channel/&lt;Application|Orderer&gt;/&lt;OrgName&gt;/&lt;PolicyName&gt;
        Policies:
            Readers:
                Type: Signature
                # 这里的策略是，有'Org1MSP.admin', 'Org1MSP.peer', 'Org1MSP.client'三者中的一个允许就可以读
                Rule: &quot;OR('Org1MSP.admin', 'Org1MSP.peer', 'Org1MSP.client')&quot;
            Writers: # 同理有两个中的一个就可写
                Type: Signature
                Rule: &quot;OR('Org1MSP.admin', 'Org1MSP.client')&quot;
            Admins:	# 只有admin
                Type: Signature
                Rule: &quot;OR('Org1MSP.admin')&quot;
            Endorsement:	# 有一个Org1MSP的peer节点签名就可以背书
                Type: Signature
                Rule: &quot;OR('Org1MSP.peer')&quot;

        # leave this flag set to true.
        AnchorPeers:	# 锚节点用于跨组织通信
            # AnchorPeers defines the location of peers which can be used
            # for cross org gossip communication.  Note, this value is only
            # encoded in the genesis block in the Application section context
            - Host: peer0.org1.example.com
              Port: 7051

    - &amp;Org2
        # DefaultOrg defines the organization which is used in the sampleconfig
        # of the fabric.git development environment
        Name: Org2MSP

        # ID to load the MSP definition as
        ID: Org2MSP

        MSPDir: ../organizations/peerOrganizations/org2.example.com/msp

        # Policies defines the set of policies at this level of the config tree
        # For organization policies, their canonical path is usually
        #   /Channel/&lt;Application|Orderer&gt;/&lt;OrgName&gt;/&lt;PolicyName&gt;
        Policies:
            Readers:
                Type: Signature
                Rule: &quot;OR('Org2MSP.admin', 'Org2MSP.peer', 'Org2MSP.client')&quot;
            Writers:
                Type: Signature
                Rule: &quot;OR('Org2MSP.admin', 'Org2MSP.client')&quot;
            Admins:
                Type: Signature
                Rule: &quot;OR('Org2MSP.admin')&quot;
            Endorsement:
                Type: Signature
                Rule: &quot;OR('Org2MSP.peer')&quot;

        AnchorPeers:
            # AnchorPeers defines the location of peers which can be used
            # for cross org gossip communication.  Note, this value is only
            # encoded in the genesis block in the Application section context
            - Host: peer0.org2.example.com
              Port: 9051

################################################################################
#
#   SECTION: Capabilities
#
#   - This section defines the capabilities of fabric network. This is a new
#   concept as of v1.1.0 and should not be utilized in mixed networks with
#   v1.0.x peers and orderers.  Capabilities define features which must be
#   present in a fabric binary for that binary to safely participate in the
#   fabric network.  For instance, if a new MSP type is added, newer binaries
#   might recognize and validate the signatures from this type, while older
#   binaries without this support would be unable to validate those
#   transactions.  This could lead to different versions of the fabric binaries
#   having different world states.  Instead, defining a capability for a channel
#   informs those binaries without this capability that they must cease
#   processing transactions until they have been upgraded.  For v1.0.x if any
#   capabilities are defined (including a map with all capabilities turned off)
#   then the v1.0.x peer will deliberately crash.
#
################################################################################
Capabilities:
    # Channel capabilities apply to both the orderers and the peers and must be
    # supported by both.
    # Set the value of the capability to true to require it.
    Channel: &amp;ChannelCapabilities
        # V2_0 capability ensures that orderers and peers behave according
        # to v2.0 channel capabilities. Orderers and peers from
        # prior releases would behave in an incompatible way, and are therefore
        # not able to participate in channels at v2.0 capability.
        # Prior to enabling V2.0 channel capabilities, ensure that all
        # orderers and peers on a channel are at v2.0.0 or later.
        V2_0: true

    # Orderer capabilities apply only to the orderers, and may be safely
    # used with prior release peers.
    # Set the value of the capability to true to require it.
    Orderer: &amp;OrdererCapabilities
        # V2_0 orderer capability ensures that orderers behave according
        # to v2.0 orderer capabilities. Orderers from
        # prior releases would behave in an incompatible way, and are therefore
        # not able to participate in channels at v2.0 orderer capability.
        # Prior to enabling V2.0 orderer capabilities, ensure that all
        # orderers on channel are at v2.0.0 or later.
        V2_0: true

    # Application capabilities apply only to the peer network, and may be safely
    # used with prior release orderers.
    # Set the value of the capability to true to require it.
    Application: &amp;ApplicationCapabilities
        # V2_0 application capability ensures that peers behave according
        # to v2.0 application capabilities. Peers from
        # prior releases would behave in an incompatible way, and are therefore
        # not able to participate in channels at v2.0 application capability.
        # Prior to enabling V2.0 application capabilities, ensure that all
        # peers on channel are at v2.0.0 or later.
        V2_0: true

################################################################################
#
#   SECTION: Application
#
#   - This section defines the values to encode into a config transaction or
#   genesis block for application related parameters
#
################################################################################
Application: &amp;ApplicationDefaults

    # Organizations is the list of orgs which are defined as participants on
    # the application side of the network
    Organizations:

    # Policies defines the set of policies at this level of the config tree
    # For Application policies, their canonical path is
    #   /Channel/Application/&lt;PolicyName&gt;
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: &quot;ANY Readers&quot;
        Writers:
            Type: ImplicitMeta
            Rule: &quot;ANY Writers&quot;
        Admins:
            Type: ImplicitMeta
            Rule: &quot;MAJORITY Admins&quot;
        LifecycleEndorsement:
            Type: ImplicitMeta
            Rule: &quot;MAJORITY Endorsement&quot;
        Endorsement:
            Type: ImplicitMeta
            Rule: &quot;MAJORITY Endorsement&quot;

    Capabilities:
        &lt;&lt;: *ApplicationCapabilities
################################################################################
#
#   SECTION: Orderer
#
#   - This section defines the values to encode into a config transaction or
#   genesis block for orderer related parameters
#
################################################################################
Orderer: &amp;OrdererDefaults

    # Orderer Type: The orderer implementation to start
    OrdererType: etcdraft

    EtcdRaft:
        Consenters:
        - Host: orderer.example.com
          Port: 7050
          ClientTLSCert: ../organizations/ordererOrganizations/example.com/orderers/orderer.example.com/tls/server.crt
          ServerTLSCert: ../organizations/ordererOrganizations/example.com/orderers/orderer.example.com/tls/server.crt

    # Batch Timeout: The amount of time to wait before creating a batch
    BatchTimeout: 2s

    # Batch Size: Controls the number of messages batched into a block
    BatchSize:

        # Max Message Count: The maximum number of messages to permit in a batch
        MaxMessageCount: 10

        # Absolute Max Bytes: The absolute maximum number of bytes allowed for
        # the serialized messages in a batch.
        AbsoluteMaxBytes: 99 MB

        # Preferred Max Bytes: The preferred maximum number of bytes allowed for
        # the serialized messages in a batch. A message larger than the preferred
        # max bytes will result in a batch larger than preferred max bytes.
        PreferredMaxBytes: 512 KB

    # Organizations is the list of orgs which are defined as participants on
    # the orderer side of the network
    Organizations:

    # Policies defines the set of policies at this level of the config tree
    # For Orderer policies, their canonical path is
    #   /Channel/Orderer/&lt;PolicyName&gt;
    Policies:
        Readers:
            Type: ImplicitMeta
            Rule: &quot;ANY Readers&quot;
        Writers:
            Type: ImplicitMeta
            Rule: &quot;ANY Writers&quot;
        Admins:
            Type: ImplicitMeta
            Rule: &quot;MAJORITY Admins&quot;
        # BlockValidation specifies what signatures must be included in the block
        # from the orderer for the peer to validate it.
        BlockValidation:
            Type: ImplicitMeta
            Rule: &quot;ANY Writers&quot;

################################################################################
#
#   CHANNEL
#
#   This section defines the values to encode into a config transaction or
#   genesis block for channel related parameters.
#
################################################################################
Channel: &amp;ChannelDefaults
    # Policies defines the set of policies at this level of the config tree
    # For Channel policies, their canonical path is
    #   /Channel/&lt;PolicyName&gt;
    Policies:
        # Who may invoke the 'Deliver' API
        Readers:
            Type: ImplicitMeta
            Rule: &quot;ANY Readers&quot;
        # Who may invoke the 'Broadcast' API
        Writers:
            Type: ImplicitMeta
            Rule: &quot;ANY Writers&quot;
        # By default, who may modify elements at this config level
        Admins:
            Type: ImplicitMeta
            Rule: &quot;MAJORITY Admins&quot;

    # Capabilities describes the channel level capabilities, see the
    # dedicated Capabilities section elsewhere in this file for a full
    # description
    Capabilities:
        &lt;&lt;: *ChannelCapabilities

################################################################################
#
#   Profile
#
#   - Different configuration profiles may be encoded here to be specified
#   as parameters to the configtxgen tool
#
################################################################################
Profiles:

    TwoOrgsOrdererGenesis:
        &lt;&lt;: *ChannelDefaults
        Orderer:
            &lt;&lt;: *OrdererDefaults
            Organizations:
                - *OrdererOrg
            Capabilities:
                &lt;&lt;: *OrdererCapabilities
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
                    - *Org2
    TwoOrgsChannel:
        Consortium: SampleConsortium
        &lt;&lt;: *ChannelDefaults
        Application:
            &lt;&lt;: *ApplicationDefaults
            Organizations:
                - *Org1
                - *Org2
            Capabilities:
                &lt;&lt;: *ApplicationCapabilities

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang的指针]]></title>
        <id>https://lizonglin313.github.io/post/golang-de-zhi-zhen</id>
        <link href="https://lizonglin313.github.io/post/golang-de-zhi-zhen">
        </link>
        <updated>2021-02-07T13:53:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>很多主流语言中都有指针作为变量的一种，go也不例外。一方面，go保留了例如c、cpp等语言的严谨性，同时兼有python、函数式编程语言的灵活性；针对长历史的语言，去其糟粕取其精华，依然保留了指针。</p>
</blockquote>
<h2 id="值传递和引用传递">值传递和引用传递</h2>
<p>相信在初学c语言时，指针对于大部分人来说有些难以理解，尤其是不了解计算机底层的人，传值、传地址难以区分。c和cpp中，指针操作有<strong>传值</strong>和**传引用（地址）**两种方式。</p>
<ul>
<li>传值</li>
</ul>
<p>传值就是传递变量的值，相当于把这个变量复制一份，用于函数域中的操作。函数域之外，变量的值不受影响。</p>
<ul>
<li>传引用</li>
</ul>
<p>传引用，也叫传地址，在某个函数中操作以引用方式传进去的变量，会改变变量实际的值，也就是在函数域之外，变量的值也会被改变。</p>
<pre><code class="language-c++">void con_value(int num){
    num++;
}

void con_refer(int &amp;a){
    num++;
}

int main(){
    int num = 1;
    con_value(num);
    printf(&quot;n1 = %d\n&quot;, num);
    
    con_refer(num);
    printf(&quot;n2 = %d\n&quot;, num);
}
</code></pre>
<p><code>con_value()</code>就是值传递，<code>con_refer()</code>就是传引用。执行<code>main()</code>函数后，<code>n1 = 1</code>因为传入的只是值，相当于<code>con_value()</code>把<code>num</code>复制了一份用来操作，实际上函数的作用域之外<code>num</code>没有变；<code>n2 = 2</code>，<code>con_refer()</code>则是传入的引用，直接使用了<code>num</code>，所以无论函数内还是外，<code>num</code>的值都发生的改变。</p>
<h2 id="go中的指针">go中的指针</h2>
<p>在go语言中，指针只有<strong>值传递</strong>这一种，也就是函数做的只是拷贝，然后再使用。</p>
<h4 id="情况一函数内改变不影响函数外">情况一：函数内改变不影响函数外</h4>
<pre><code class="language-go">var a int
fun f(a int){
    ...
}
</code></pre>
<p>这种情况下，<code>f()</code>中对<code>a</code>的改变不会影响的外面的<code>a</code>，因为是拷贝过去的。</p>
<h4 id="情况二通过指针改变变量实际的值通过传递指针达到引用传递的效果">情况二：通过指针改变变量实际的值（通过传递指针达到引用传递的效果）</h4>
<pre><code class="language-go">var na int = 2
var pa *int = &amp;na

func f(pa *int) {
	*pa++
	fmt.Println(*pa)
}
</code></pre>
<p>首先，<code>na</code>是<code>int</code>型变量，而<code>pa</code>是指向<code>na</code>地址的指针，我们通过传入一个指针来改变变量的值。同样以值传递的思想，函数<code>f()</code>拷贝了一份<code>pa</code>，但是无论怎么拷贝，拷贝出的东西它都是指向<code>na</code>的地址的，所以通过传一个指针就可以改变对应地址的值，函数外<code>na</code>的值也发生了改变。</p>
<h4 id="情况三-关于object的传递">情况三： 关于<code>object</code>的传递</h4>
<pre><code class="language-go">var object Object

func f(object Object){
    ···
}
</code></pre>
<p>如果是这种情况，就要看在定义<code>object</code>时，是把他当作值传递来用还是引用传递来用。</p>
<pre><code class="language-go">// 1.这种情况可以安全的当作值传递来用
type Object struct {
	a *int
}

func f(object Object){
    ...
}

func main(){
	l := 9
	o := Object{&amp;l} // 不管怎么拷贝，拷贝出的 object.a 都是指向原本l的地址，会改变l的值
	f(o)	
}


// 2.如果对象需要例如维护某些状态，仅仅传值是不会改变函数外参数原本的值的，如：st
type Object struct {
	a *int
	st bool // 一个bool值
}
func fo(object Object) { // 传值，一个Object类型的值
	*object.a ++
	object.st = false  // 原本的st不会被改变
}

func main() {
	l := 9
    o := Object{&amp;l, true}
	fo(o)
	fmt.Printf(&quot;%d  &quot;, *o.a) // 10
	fmt.Println(o.st)	// true
}

// 3.如果需要，传指针来实现引用传递的效果，如下面的 st 被修改了
func p_fo(object *Object) {	// 接收一个Object类型的指针
	*object.a++
	object.st = false	// 拷贝后的 object 指向原来的地址，赋值操作实际上改变原值
}

func main() {
	l := 9
	o := Object{&amp;l, true}
	o_p := &amp;o
	p_fo(o_p)
	fmt.Printf(&quot;%d  &quot;, *o.a) // 10
	fmt.Println(o.st) // false
}
</code></pre>
<p>所以，在定义一个<code>Object</code>时，要考虑以后是用值还是用引用，再来定义使其更方便的被使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[$ ./network.sh up =>ENTER后发生了什么？]]></title>
        <id>https://lizonglin313.github.io/post/dollar-networksh-up-greaterenter-hou-fa-sheng-liao-shi-me</id>
        <link href="https://lizonglin313.github.io/post/dollar-networksh-up-greaterenter-hou-fa-sheng-liao-shi-me">
        </link>
        <updated>2021-01-24T14:32:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Fabric2.X中，用fabric-samples替换掉原来的first-network，提供给开发人员快速上手。fabric-samples中的test-network为我们提供了一系列脚本和配置文件，让我们可以简单的启动一个fabric网络。</p>
<p>本文以广度优先的方法解读network.sh的内容</p>
</blockquote>
<h2 id="networksh">network.sh</h2>
<h4 id="a设置环境变量">a.设置环境变量</h4>
<pre><code class="language-shell">export PATH=${PWD}/../bin:${PWD}:$PATH
export FABRIC_CFG_PATH=${PWD}/configtx
export VERBOSE=false
</code></pre>
<ul>
<li><code>bin</code>目录内容如下</li>
</ul>
<pre><code>├─bin
│      configtxgen
│      configtxlator
│      cryptogen
│      discover
│      fabric-ca-client
│      fabric-ca-server
│      idemixgen
│      orderer
│      peer
</code></pre>
<p><code>cryptogen</code>以及<code>configtxgen</code>这两个重要的工具通过编译生成，用来创建参与网络实体的证书，生成创世区块和通道的配置文件以及组织的锚节点。相应的，<code>bin</code>目录中还有其他需要使用到的工具。</p>
<p><code>configtx</code>中的文件是用来配置网络的，<code>configtxgen</code>这个工具就是依靠<code>configtx</code>中的<code>configtx.yaml</code>文件来定义网络。</p>
<h4 id="b提供函数">b.提供函数</h4>
<ul>
<li><code>clearContainers()</code></li>
</ul>
<p>清除启动、运行网络时，在docker中创建的镜像；这个函数在关闭网络时被调用。</p>
<ul>
<li><code>removeUnwantedImages()</code></li>
</ul>
<p>清除不想要的镜像</p>
<ul>
<li><code>checkPrereqs()</code></li>
</ul>
<p>检查网络组件、二进制文件、镜像文件的版本，依托于上级目录的<code>config</code>文件夹，该文件夹的内容中包含了Fabric网络中的基本属性的配置，其内容如下：</p>
<pre><code class="language-shell">├─config
│      configtx.yaml
│      core.yaml	
│      orderer.yaml
</code></pre>
<p>检查<code>peer</code>版本、<code>docker_image</code>版本。</p>
<blockquote>
<p>一般来说，拉取Fabric项目后，使用<code>bootstrap.sh</code>脚本，都可以得到对应版本的文件以及环境。</p>
</blockquote>
<ul>
<li><code>createOrgs()</code></li>
</ul>
<p>该函数使用<code>cryptogen</code>工具或者<code>CAs</code>创建组织的身份材料，它在运行时首先清理掉现有的身份，然后一步步执行。在<code>test-network</code>中，首先使用<code>cryptogen</code>或者<code>CAs</code>工具创建<code>Org1</code>，<code>Org2</code>的身份，然后创建<code>Orderer Org</code>的身份。</p>
<blockquote>
<p>一旦创建了组织的身份后，我们就需要生成<code>genesis block</code>，并且创建应用的<code>channel</code>让<code>Orderer</code>节点加入。</p>
</blockquote>
<ul>
<li><code>createConsortium()</code></li>
</ul>
<p>该函数使用<code>configtxgen</code>这个工具生成<code>channel</code>的<code>orderer genesis block</code>。</p>
<blockquote>
<p>在创建组织实体身份以及创世区块后，就可以开启<code>peers</code>和<code>orderering</code>服务了。</p>
</blockquote>
<ul>
<li><code>networkUp()</code></li>
</ul>
<p>该函数使用<code>docker compose</code>开启<code>peer</code>和<code>orderer</code>节点。成功后，为我们打印出当前的<code>docker images</code>。</p>
<blockquote>
<p>对于运行的Fabric网络，可以创建<code>channel</code>实现应用数据的隔离。</p>
</blockquote>
<ul>
<li><code>createChannel()</code></li>
</ul>
<p>该函数创建一个<code>channel</code>让<code>Org1</code>和<code>Org2</code>的<code>peers</code>节点加入。首先，它检查网络是否启动，如果没有，就先把网络开启，然后再创建。它使用<code>createChannel.sh</code>脚本创建通道。</p>
<ul>
<li><code>deployCC()</code></li>
</ul>
<p>该函数把链码安装到通道上并将链码实例化，它调用<code>deployCC.sh</code>这个脚本实现。</p>
<ul>
<li><code>networkDown()</code></li>
</ul>
<p>该函数断开正在运行的网络，它首先删除<code>docker compose</code>中的镜像，清除容器，删除<code>genesis block</code>各个组织的<code>ca</code>，卸载<code>chaincode</code>。也就是说，<code>down</code>掉网络后，我们在上面创建的实体、通道，安装的链码等等全部被清除掉了，如果再次启动时还需从头开始配置。</p>
<h2 id="up-down">Up &amp; Down</h2>
<h4 id="networksh-up">./network.sh up</h4>
<p>这个命令其实就是调用函数<code>networkUp()</code>，函数中依次调用：</p>
<ol>
<li><code>createOrgs()</code></li>
<li><code>createConsortium()</code></li>
<li>开启<code>docker-compose</code></li>
<li>打印<code>docker ps -a</code>存在的镜像</li>
</ol>
<h4 id="networksh-down">./network.sh down</h4>
<p>这个命令调用函数<code>networkDown()</code>，函数中依次调用：</p>
<ol>
<li><code>docker-compose -f</code>删除镜像</li>
<li><code>clearContainers()</code></li>
<li><code>removeUnwantedImages</code></li>
<li><code>rm -rf system-genesis-block</code></li>
<li><code>rm -rf organizations/fabric-ca/org...</code></li>
<li><code>rm -rf channel-artifacts log.txt chaincode.tar.gz chaincode</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang常用工具]]></title>
        <id>https://lizonglin313.github.io/post/golang-chang-yong-gong-ju</id>
        <link href="https://lizonglin313.github.io/post/golang-chang-yong-gong-ju">
        </link>
        <updated>2021-01-23T11:35:32.000Z</updated>
        <content type="html"><![CDATA[<p>一般格式：<code>go command [arguments]</code></p>
<h3 id="build">build</h3>
<ul>
<li>
<p><code>build</code></p>
<p>最常用的命令，用来编译go文件</p>
<p>跨平台编译，如<code>env GOOS=linux GOARCH=amd64 go build</code>在Linux系统、amd64架构编译</p>
</li>
</ul>
<h3 id="install">install</h3>
<ul>
<li>
<p><code>install</code></p>
<p>同为编译，和<code>build</code>的不同在于编译后会将输出文件打包成库放在pkg下面</p>
</li>
</ul>
<h3 id="get">get</h3>
<ul>
<li>
<p><code>get</code></p>
<p>用于获取go第三方包，默认从git repo获取最新版本，如<code>go get -u github.com/go-sql-driver/mysql</code></p>
</li>
</ul>
<h3 id="fmt">fmt</h3>
<ul>
<li>
<p><code>fmt</code></p>
<p>统一代码风格，<code>go fmt</code></p>
</li>
</ul>
<h3 id="test">test</h3>
<ul>
<li>
<p><code>test</code></p>
<p>运行当前包目录下的test，如<code>go test</code>或<code>go test -v</code>，test文件命名是<code>xxx_test.go</code></p>
</li>
</ul>
<p>关于写test case：</p>
<ul>
<li>
<p>test命名为<code>TestXxxx</code></p>
</li>
<li>
<p>test case 的参数为：<code>t *testing.T</code> 或者 <code>b *testing.B</code> (用于测试性能)</p>
</li>
<li>
<p><code>t.Errorf()</code> 用于打印错误信息，同时跳过整个test case</p>
</li>
<li>
<p><code>t.SkipNow()</code> 为跳过当前test，并且直接处理下一个test case，要写在test case的第一行</p>
</li>
<li>
<p><code>t.Run()</code> 来执行subtests，可以做到控制test输出以及test的顺序</p>
</li>
<li>
<p><code>TestMain(m *testing.M)</code> 初始化test，使用<code>m.Run()</code>来调用其他tests，可以用来完成一些初始化；如果没有调用<code>m.Run()</code>，那么处了TestMain以外其他的tests就不会被执行</p>
</li>
</ul>
<p>关于benchmark：</p>
<ul>
<li>benchmark函数一般以Benchmark开头，如<code>BenchmarkXxx</code></li>
<li>参数为： <code>b *testing.B</code></li>
<li>每次执行一般会跑<code>b.N</code>次</li>
<li>在执行过程中根据实际case的执行时间是否稳定来调整<code>b.N</code>的次数直至稳定</li>
<li>命令行中，命令为：<code>go test -bench=.</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fabric2.X_fabric-samples_test-network解读]]></title>
        <id>https://lizonglin313.github.io/post/fabric2x_fabric-samples_test-network-jie-du</id>
        <link href="https://lizonglin313.github.io/post/fabric2x_fabric-samples_test-network-jie-du">
        </link>
        <updated>2021-01-21T12:41:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Fabric2.X中，<code>fabric-samples</code>将作为Fabric1.X中的<code>first-network</code>的替代。也就是说，在2.X版本及以后，使用<code>fabric-samples</code>作为fabric的测试网络了。</p>
</blockquote>
<p>在配置好基本环境之后，来看一下它为我们提供了哪些内容。</p>
<h2 id="目录结构">目录结构</h2>
<pre><code class="language-shell">root@lizonglin-virtual-machine:/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples# ll
total 100
drwxr-xr-x 15 lizonglin lizonglin  4096 1月  21 10:55 ./
drwxr-xr-x  3 lizonglin lizonglin  4096 1月  21 10:17 ../
drwxr-xr-x  2 lizonglin lizonglin  4096 10月  1 03:52 bin/
drwxr-xr-x  8 lizonglin lizonglin  4096 1月  21 10:55 chaincode/
drwxr-xr-x  3 lizonglin lizonglin  4096 1月  21 10:55 chaincode-docker-devmode/
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 10:55 ci/
-rw-r--r--  1 lizonglin lizonglin   597 1月  17 18:50 CODE_OF_CONDUCT.md
-rw-r--r--  1 lizonglin lizonglin   109 1月  17 18:50 CODEOWNERS
drwxr-xr-x  3 lizonglin lizonglin  4096 1月  21 10:55 commercial-paper/
drwxr-xr-x  2 lizonglin lizonglin  4096 10月  1 02:41 config/
-rw-r--r--  1 lizonglin lizonglin   935 1月  17 18:50 CONTRIBUTING.md
drwxr-xr-x  5 lizonglin lizonglin  4096 1月  21 10:55 fabcar/
drwxr-xr-x  6 lizonglin lizonglin  4096 1月  21 11:24 first-network/
drwxr-xr-x  8 lizonglin lizonglin  4096 1月  21 10:55 .git/
-rw-r--r--  1 lizonglin lizonglin   189 1月  21 10:55 .gitignore
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 10:55 high-throughput/
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 10:55 interest_rate_swaps/
-rw-r--r--  1 lizonglin lizonglin 11358 1月  17 18:50 LICENSE
-rw-r--r--  1 lizonglin lizonglin  1644 1月  21 10:55 MAINTAINERS.md
drwxr-xr-x  2 lizonglin lizonglin  4096 1月  21 10:55 off_chain_data/
-rw-r--r--  1 lizonglin lizonglin  1694 1月  21 10:55 README.md
-rw-r--r--  1 lizonglin lizonglin  1035 1月  17 18:50 SECURITY.md
drwxr-xr-x  8 lizonglin lizonglin  4096 1月  21 18:52 test-network/
</code></pre>
<p>fabric-samples的目录结构如下，可以看到还是暂时为我们保留了first-network，但是新版的启动网络脚本则是在test-network中。</p>
<pre><code class="language-shell">root@lizonglin-virtual-machine:/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network# ll
total 68
drwxr-xr-x  8 lizonglin lizonglin  4096 1月  21 18:52 ./
drwxr-xr-x 15 lizonglin lizonglin  4096 1月  21 10:55 ../
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 10:55 addOrg3/
drwxr-xr-x  2 lizonglin lizonglin  4096 1月  21 10:55 configtx/
drwxr-xr-x  2 lizonglin lizonglin  4096 1月  21 10:55 docker/
-rw-r--r--  1 lizonglin lizonglin    69 1月  17 18:50 .env
-rw-r--r--  1 lizonglin lizonglin   349 1月  21 10:55 .gitignore
-rwxr-xr-x  1 lizonglin lizonglin 20570 1月  21 10:55 network.sh*
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 20:05 organizations/
-rw-r--r--  1 lizonglin lizonglin   788 1月  21 10:55 README.md
drwxr-xr-x  3 lizonglin lizonglin  4096 1月  21 10:55 scripts/
drwxr-xr-x  2 lizonglin lizonglin  4096 1月  21 20:05 system-genesis-block/
</code></pre>
<h2 id="networksh">network.sh</h2>
<p>其中，network.sh*即启动脚本，在新的脚本中，为我们进行了大量的配置工作，使得新版本的脚本很长，省略一些不必要的内容：</p>
<pre><code class="language-shell">#!/bin/bash
# 首先是一些说明：
# 两个组织，每个组织一个peer节点
# 一个使用Raft单节点的排序服务
# This script brings up a Hyperledger Fabric network for testing smart contracts
# and applications. The test network consists of two organizations with one
# peer each, and a single node Raft ordering service. Users can also use this
# script to create a channel deploy a chaincode on the channel
#
# prepending $PWD/../bin to PATH to ensure we are picking up the correct binaries
# this may be commented out to resolve installed version of tools if desired
export PATH=${PWD}/../bin:${PWD}:$PATH
export FABRIC_CFG_PATH=${PWD}/configtx
export VERBOSE=false

# Print the usage message
function printHelp() {
  echo &quot;Usage: &quot;
  echo &quot;  network.sh &lt;Mode&gt; [Flags]&quot;
  echo &quot;    &lt;Mode&gt;&quot;
  echo &quot;      - 'up' - bring up fabric orderer and peer nodes. No channel is created&quot;
  echo &quot;      - 'up createChannel' - bring up fabric network with one channel&quot;
  echo &quot;      - 'createChannel' - create and join a channel after the network is created&quot;
  echo &quot;      - 'deployCC' - deploy the fabcar chaincode on the channel&quot;
  echo &quot;      - 'down' - clear the network with docker-compose down&quot;
  echo &quot;      - 'restart' - restart the network&quot;
  echo
  echo &quot;    Flags:&quot;
  echo &quot;    -ca &lt;use CAs&gt; -  create Certificate Authorities to generate the crypto material&quot;
  echo &quot;    -c &lt;channel name&gt; - channel name to use (defaults to \&quot;mychannel\&quot;)&quot;
  echo &quot;    -s &lt;dbtype&gt; - the database backend to use: goleveldb (default) or couchdb&quot;
  echo &quot;    -r &lt;max retry&gt; - CLI times out after certain number of attempts (defaults to 5)&quot;
  echo &quot;    -d &lt;delay&gt; - delay duration in seconds (defaults to 3)&quot;
  echo &quot;    -l &lt;language&gt; - the programming language of the chaincode to deploy: go (default), java, javascript, typescript&quot;
  echo &quot;    -v &lt;version&gt;  - chaincode version. Must be a round number, 1, 2, 3, etc&quot;
  echo &quot;    -i &lt;imagetag&gt; - the tag to be used to launch the network (defaults to \&quot;latest\&quot;)&quot;
  echo &quot;    -verbose - verbose mode&quot;
  echo &quot;  network.sh -h (print this message)&quot;
  echo
  echo &quot; Possible Mode and flags&quot;
  echo &quot;  network.sh up -ca -c -r -d -s -i -verbose&quot;
  echo &quot;  network.sh up createChannel -ca -c -r -d -s -i -verbose&quot;
  echo &quot;  network.sh createChannel -c -r -d -verbose&quot;
  echo &quot;  network.sh deployCC -l -v -r -d -verbose&quot;
  echo
  echo &quot; Taking all defaults:&quot;
  echo &quot;	network.sh up&quot;
  echo
  echo &quot; Examples:&quot;
  echo &quot;  network.sh up createChannel -ca -c mychannel -s couchdb -i 2.0.0&quot;
  echo &quot;  network.sh createChannel -c channelName&quot;
  echo &quot;  network.sh deployCC -l javascript&quot;
}
# 清理docker容器
# Obtain CONTAINER_IDS and remove them
# TODO Might want to make this optional - could clear other containers
# This function is called when you bring a network down
function clearContainers() {
  CONTAINER_IDS=$(docker ps -a | awk '($2 ~ /dev-peer.*/) {print $1}')
  if [ -z &quot;$CONTAINER_IDS&quot; -o &quot;$CONTAINER_IDS&quot; == &quot; &quot; ]; then
    echo &quot;---- No containers available for deletion ----&quot;
  else
    docker rm -f $CONTAINER_IDS
  fi
}
# 删除docker镜像
# Delete any images that were generated as a part of this setup
# specifically the following images are often left behind:
# This function is called when you bring the network down
function removeUnwantedImages() {
  DOCKER_IMAGE_IDS=$(docker images | awk '($1 ~ /dev-peer.*/) {print $3}')
  if [ -z &quot;$DOCKER_IMAGE_IDS&quot; -o &quot;$DOCKER_IMAGE_IDS&quot; == &quot; &quot; ]; then
    echo &quot;---- No images available for deletion ----&quot;
  else
    docker rmi -f $DOCKER_IMAGE_IDS
  fi
}

# Versions of fabric known not to work with the test network
BLACKLISTED_VERSIONS=&quot;^1\.0\. ^1\.1\. ^1\.2\. ^1\.3\. ^1\.4\.&quot;

# 这里检查一下现有的二进制文件以及镜像是否可用，免得后续出现问题
# Do some basic sanity checking to make sure that the appropriate versions of fabric
# binaries/images are available. In the future, additional checking for the presence
# of go or other items could be added.
function checkPrereqs() {
  ## Check if your have cloned the peer binaries and configuration files.
  peer version &gt; /dev/null 2&gt;&amp;1

  if [[ $? -ne 0 || ! -d &quot;../config&quot; ]]; then
    echo &quot;ERROR! Peer binary and configuration files not found..&quot;
    echo
    echo &quot;Follow the instructions in the Fabric docs to install the Fabric Binaries:&quot;
    echo &quot;https://hyperledger-fabric.readthedocs.io/en/latest/install.html&quot;
    exit 1
  fi
  # 检查docker镜像以及二进制文件是否匹配
  # use the fabric tools container to see if the samples and binaries match your
  # docker images
  LOCAL_VERSION=$(peer version | sed -ne 's/ Version: //p')
  DOCKER_IMAGE_VERSION=$(docker run --rm hyperledger/fabric-tools:$IMAGETAG peer version | sed -ne 's/ Version: //p' | head -1)

  echo &quot;LOCAL_VERSION=$LOCAL_VERSION&quot;
  echo &quot;DOCKER_IMAGE_VERSION=$DOCKER_IMAGE_VERSION&quot;

  if [ &quot;$LOCAL_VERSION&quot; != &quot;$DOCKER_IMAGE_VERSION&quot; ]; then
    echo &quot;=================== WARNING ===================&quot;
    echo &quot;  Local fabric binaries and docker images are  &quot;
    echo &quot;  out of  sync. This may cause problems.       &quot;
    echo &quot;===============================================&quot;
  fi

  for UNSUPPORTED_VERSION in $BLACKLISTED_VERSIONS; do
    echo &quot;$LOCAL_VERSION&quot; | grep -q $UNSUPPORTED_VERSION
    if [ $? -eq 0 ]; then
      echo &quot;ERROR! Local Fabric binary version of $LOCAL_VERSION does not match the versions supported by the test network.&quot;
      exit 1
    fi

    echo &quot;$DOCKER_IMAGE_VERSION&quot; | grep -q $UNSUPPORTED_VERSION
    if [ $? -eq 0 ]; then
      echo &quot;ERROR! Fabric Docker image version of $DOCKER_IMAGE_VERSION does not match the versions supported by the test network.&quot;
      exit 1
    fi
  done
}

# 下面简单介绍了cryptogen这个工具以及CA
# Before you can bring up a network, each organization needs to generate the crypto
# material that will define that organization on the network. Because Hyperledger
# Fabric is a permissioned blockchain, each node and user on the network needs to
# use certificates and keys to sign and verify its actions. In addition, each user
# needs to belong to an organization that is recognized as a member of the network.
# You can use the Cryptogen tool or Fabric CAs to generate the organization crypto
# material.

# By default, the sample network uses cryptogen. Cryptogen is a tool that is
# meant for development and testing that can quicky create the certificates and keys
# that can be consumed by a Fabric network. The cryptogen tool consumes a series
# of configuration files for each organization in the &quot;organizations/cryptogen&quot;
# directory. Cryptogen uses the files to generate the crypto  material for each
# org in the &quot;organizations&quot; directory.

# You can also Fabric CAs to generate the crypto material. CAs sign the certificates
# and keys that they generate to create a valid root of trust for each organization.
# The script uses Docker Compose to bring up three CAs, one for each peer organization
# and the ordering organization. The configuration file for creating the Fabric CA
# servers are in the &quot;organizations/fabric-ca&quot; directory. Within the same diectory,
# the &quot;registerEnroll.sh&quot; script uses the Fabric CA client to create the identites,
# certificates, and MSP folders that are needed to create the test network in the
# &quot;organizations/ordererOrganizations&quot; directory.

# Create Organziation crypto material using cryptogen or CAs
function createOrgs() {

  if [ -d &quot;organizations/peerOrganizations&quot; ]; then
    rm -Rf organizations/peerOrganizations &amp;&amp; rm -Rf organizations/ordererOrganizations
  fi

  # Create crypto material using cryptogen
  if [ &quot;$CRYPTO&quot; == &quot;cryptogen&quot; ]; then
    which cryptogen
    if [ &quot;$?&quot; -ne 0 ]; then
      echo &quot;cryptogen tool not found. exiting&quot;
      exit 1
    fi
    echo
    echo &quot;##########################################################&quot;
    echo &quot;##### Generate certificates using cryptogen tool #########&quot;
    echo &quot;##########################################################&quot;
    echo

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Org1 Identities ######################&quot;
    echo &quot;##########################################################&quot;

    set -x
    cryptogen generate --config=./organizations/cryptogen/crypto-config-org1.yaml --output=&quot;organizations&quot;
    res=$?
    set +x
    if [ $res -ne 0 ]; then
      echo &quot;Failed to generate certificates...&quot;
      exit 1
    fi

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Org2 Identities ######################&quot;
    echo &quot;##########################################################&quot;

    set -x
    cryptogen generate --config=./organizations/cryptogen/crypto-config-org2.yaml --output=&quot;organizations&quot;
    res=$?
    set +x
    if [ $res -ne 0 ]; then
      echo &quot;Failed to generate certificates...&quot;
      exit 1
    fi

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Orderer Org Identities ###############&quot;
    echo &quot;##########################################################&quot;

    set -x
    cryptogen generate --config=./organizations/cryptogen/crypto-config-orderer.yaml --output=&quot;organizations&quot;
    res=$?
    set +x
    if [ $res -ne 0 ]; then
      echo &quot;Failed to generate certificates...&quot;
      exit 1
    fi

  fi

  # Create crypto material using Fabric CAs
  if [ &quot;$CRYPTO&quot; == &quot;Certificate Authorities&quot; ]; then

    fabric-ca-client version &gt; /dev/null 2&gt;&amp;1
    if [ $? -ne 0 ]; then
      echo &quot;Fabric CA client not found locally, downloading...&quot;
      cd ..
      curl -s -L &quot;https://github.com/hyperledger/fabric-ca/releases/download/v1.4.4/hyperledger-fabric-ca-${OS_ARCH}-1.4.4.tar.gz&quot; | tar xz || rc=$?
    if [ -n &quot;$rc&quot; ]; then
        echo &quot;==&gt; There was an error downloading the binary file.&quot;
        echo &quot;fabric-ca-client binary is not available to download&quot;
    else
        echo &quot;==&gt; Done.&quot;
      cd test-network
    fi
    fi

    echo
    echo &quot;##########################################################&quot;
    echo &quot;##### Generate certificates using Fabric CA's ############&quot;
    echo &quot;##########################################################&quot;

    IMAGE_TAG=$IMAGETAG docker-compose -f $COMPOSE_FILE_CA up -d 2&gt;&amp;1

    . organizations/fabric-ca/registerEnroll.sh

    sleep 10

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Org1 Identities ######################&quot;
    echo &quot;##########################################################&quot;

    createOrg1

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Org2 Identities ######################&quot;
    echo &quot;##########################################################&quot;

    createOrg2

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Orderer Org Identities ###############&quot;
    echo &quot;##########################################################&quot;

    createOrderer

  fi

  echo
  echo &quot;Generate CCP files for Org1 and Org2&quot;
  ./organizations/ccp-generate.sh
}

# 使用cryptogen（cryptogen用于配置网络中的证书、组织等）配置完网络组织后
# 这里使用configtxgen配置创世区块、channel以及锚节点
# 有一个&quot;configtx.yaml&quot;文件帮助配置网络中的组织创世区块，组织成员等内容
# 创建每个channel的MSP
# Once you create the organization crypto material, you need to create the
# genesis block of the orderer system channel. This block is required to bring
# up any orderer nodes and create any application channels.

# The configtxgen tool is used to create the genesis block. Configtxgen consumes a
# &quot;configtx.yaml&quot; file that contains the definitions for the sample network. The
# genesis block is defiend using the &quot;TwoOrgsOrdererGenesis&quot; profile at the bottom
# of the file. This profile defines a sample consortium, &quot;SampleConsortium&quot;,
# consisting of our two Peer Orgs. This consortium defines which organizations are
# recognized as members of the network. The peer and ordering organizations are defined
# in the &quot;Profiles&quot; section at the top of the file. As part of each organization
# profile, the file points to a the location of the MSP directory for each member.
# This MSP is used to create the channel MSP that defines the root of trust for
# each organization. In essense, the channel MSP allows the nodes and users to be
# recognized as network members. The file also specifies the anchor peers for each
# peer org. In future steps, this same file is used to create the channel creation
# transaction and the anchor peer updates.
#
#
# If you receive the following warning, it can be safely ignored:
#
# [bccsp] GetDefault -&gt; WARN 001 Before using BCCSP, please call InitFactories(). Falling back to bootBCCSP.
#
# You can ignore the logs regarding intermediate certs, we are not using them in
# this crypto implementation.

# Generate orderer system channel genesis block.
function createConsortium() {

  which configtxgen
  if [ &quot;$?&quot; -ne 0 ]; then
    echo &quot;configtxgen tool not found. exiting&quot;
    exit 1
  fi

  echo &quot;#########  Generating Orderer Genesis block ##############&quot;

  # Note: For some unknown reason (at least for now) the block file can't be
  # named orderer.genesis.block or the orderer will fail to launch!
  set -x
  configtxgen -profile TwoOrgsOrdererGenesis -channelID system-channel -outputBlock ./system-genesis-block/genesis.block
  res=$?
  set +x
  if [ $res -ne 0 ]; then
    echo &quot;Failed to generate orderer genesis block...&quot;
    exit 1
  fi
}

# 之后，启动peer节点和排序服务，创建相应的docker实体
# After we create the org crypto material and the system channel genesis block,
# we can now bring up the peers and orderering service. By default, the base
# file for creating the network is &quot;docker-compose-test-net.yaml&quot; in the ``docker``
# folder. This file defines the environment variables and file mounts that
# point the crypto material and genesis block that were created in earlier.

# Bring up the peer and orderer nodes using docker compose.
function networkUp() {

  checkPrereqs
  # generate artifacts if they don't exist
  if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then
    createOrgs
    createConsortium
  fi

  COMPOSE_FILES=&quot;-f ${COMPOSE_FILE_BASE}&quot;

  if [ &quot;${DATABASE}&quot; == &quot;couchdb&quot; ]; then
    COMPOSE_FILES=&quot;${COMPOSE_FILES} -f ${COMPOSE_FILE_COUCH}&quot;
  fi

  IMAGE_TAG=$IMAGETAG docker-compose ${COMPOSE_FILES} up -d 2&gt;&amp;1

  docker ps -a
  if [ $? -ne 0 ]; then
    echo &quot;ERROR !!!! Unable to start network&quot;
    exit 1
  fi
}

# 将peer加入通道
## call the script to join create the channel and join the peers of org1 and org2
function createChannel() {

## Bring up the network if it is not arleady up.

  if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then
    echo &quot;Bringing up network&quot;
    networkUp
  fi

  # now run the script that creates a channel. This script uses configtxgen once
  # more to create the channel creation transaction and the anchor peer updates.
  # configtx.yaml is mounted in the cli container, which allows us to use it to
  # create the channel artifacts
 scripts/createChannel.sh $CHANNEL_NAME $CLI_DELAY $MAX_RETRY $VERBOSE
  if [ $? -ne 0 ]; then
    echo &quot;Error !!! Create channel failed&quot;
    exit 1
  fi

}
# 实例化链码
## Call the script to isntall and instantiate a chaincode on the channel
function deployCC() {

  scripts/deployCC.sh $CHANNEL_NAME $CC_SRC_LANGUAGE $VERSION $CLI_DELAY $MAX_RETRY $VERBOSE

  if [ $? -ne 0 ]; then
    echo &quot;ERROR !!! Deploying chaincode failed&quot;
    exit 1
  fi

  exit 0
}

# 关闭网络
# Tear down running network
function networkDown() {
  # stop org3 containers also in addition to org1 and org2, in case we were running sample to add org3
  docker-compose -f $COMPOSE_FILE_BASE -f $COMPOSE_FILE_COUCH -f $COMPOSE_FILE_CA down --volumes --remove-orphans
  docker-compose -f $COMPOSE_FILE_COUCH_ORG3 -f $COMPOSE_FILE_ORG3 down --volumes --remove-orphans
  # Don't remove the generated artifacts -- note, the ledgers are always removed
  if [ &quot;$MODE&quot; != &quot;restart&quot; ]; then
    # Bring down the network, deleting the volumes
    #Cleanup the chaincode containers
    clearContainers
    #Cleanup images
    removeUnwantedImages
    # remove orderer block and other channel configuration transactions and certs
    rm -rf system-genesis-block/*.block organizations/peerOrganizations organizations/ordererOrganizations
    ## remove fabric ca artifacts
    rm -rf organizations/fabric-ca/org1/msp organizations/fabric-ca/org1/tls-cert.pem organizations/fabric-ca/org1/ca-cert.pem organizations/fabric-ca/org1/IssuerPublicKey organizations/fabric-ca/org1/IssuerRevocationPublicKey organizations/fabric-ca/org1/fabric-ca-server.db
    rm -rf organizations/fabric-ca/org2/msp organizations/fabric-ca/org2/tls-cert.pem organizations/fabric-ca/org2/ca-cert.pem organizations/fabric-ca/org2/IssuerPublicKey organizations/fabric-ca/org2/IssuerRevocationPublicKey organizations/fabric-ca/org2/fabric-ca-server.db
    rm -rf organizations/fabric-ca/ordererOrg/msp organizations/fabric-ca/ordererOrg/tls-cert.pem organizations/fabric-ca/ordererOrg/ca-cert.pem organizations/fabric-ca/ordererOrg/IssuerPublicKey organizations/fabric-ca/ordererOrg/IssuerRevocationPublicKey organizations/fabric-ca/ordererOrg/fabric-ca-server.db
    rm -rf addOrg3/fabric-ca/org3/msp addOrg3/fabric-ca/org3/tls-cert.pem addOrg3/fabric-ca/org3/ca-cert.pem addOrg3/fabric-ca/org3/IssuerPublicKey addOrg3/fabric-ca/org3/IssuerRevocationPublicKey addOrg3/fabric-ca/org3/fabric-ca-server.db


    # remove channel and script artifacts
    rm -rf channel-artifacts log.txt fabcar.tar.gz fabcar

  fi
}

# Obtain the OS and Architecture string that will be used to select the correct
# native binaries for your platform, e.g., darwin-amd64 or linux-amd64
OS_ARCH=$(echo &quot;$(uname -s | tr '[:upper:]' '[:lower:]' | sed 's/mingw64_nt.*/windows/')-$(uname -m | sed 's/x86_64/amd64/g')&quot; | awk '{print tolower($0)}')
# Using crpto vs CA. default is cryptogen
CRYPTO=&quot;cryptogen&quot;
# timeout duration - the duration the CLI should wait for a response from
# another container before giving up
MAX_RETRY=5
# default for delay between commands
CLI_DELAY=3
# channel name defaults to &quot;mychannel&quot;
CHANNEL_NAME=&quot;mychannel&quot;
# use this as the default docker-compose yaml definition
COMPOSE_FILE_BASE=docker/docker-compose-test-net.yaml
# docker-compose.yaml file if you are using couchdb
COMPOSE_FILE_COUCH=docker/docker-compose-couch.yaml
# certificate authorities compose file
COMPOSE_FILE_CA=docker/docker-compose-ca.yaml
# use this as the docker compose couch file for org3
COMPOSE_FILE_COUCH_ORG3=addOrg3/docker/docker-compose-couch-org3.yaml
# use this as the default docker-compose yaml definition for org3
COMPOSE_FILE_ORG3=addOrg3/docker/docker-compose-org3.yaml
#
# use golang as the default language for chaincode
CC_SRC_LANGUAGE=golang
# Chaincode version
VERSION=1
# default image tag
IMAGETAG=&quot;latest&quot;
# default database
DATABASE=&quot;leveldb&quot;

# Parse commandline args

## Parse mode
if [[ $# -lt 1 ]] ; then
  printHelp
  exit 0
else
  MODE=$1
  shift
fi

# parse a createChannel subcommand if used
if [[ $# -ge 1 ]] ; then
  key=&quot;$1&quot;
  if [[ &quot;$key&quot; == &quot;createChannel&quot; ]]; then
      export MODE=&quot;createChannel&quot;
      shift
  fi
fi

# parse flags

while [[ $# -ge 1 ]] ; do
  key=&quot;$1&quot;
  case $key in
  -h )
    printHelp
    exit 0
    ;;
  -c )
    CHANNEL_NAME=&quot;$2&quot;
    shift
    ;;
  -ca )
    CRYPTO=&quot;Certificate Authorities&quot;
    ;;
  -r )
    MAX_RETRY=&quot;$2&quot;
    shift
    ;;
  -d )
    CLI_DELAY=&quot;$2&quot;
    shift
    ;;
  -s )
    DATABASE=&quot;$2&quot;
    shift
    ;;
  -l )
    CC_SRC_LANGUAGE=&quot;$2&quot;
    shift
    ;;
  -v )
    VERSION=&quot;$2&quot;
    shift
    ;;
  -i )
    IMAGETAG=&quot;$2&quot;
    shift
    ;;
  -verbose )
    VERBOSE=true
    shift
    ;;
  * )
    echo
    echo &quot;Unknown flag: $key&quot;
    echo
    printHelp
    exit 1
    ;;
  esac
  shift
done

# Are we generating crypto material with this command?
if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then
  CRYPTO_MODE=&quot;with crypto from '${CRYPTO}'&quot;
else
  CRYPTO_MODE=&quot;&quot;
fi

# Determine mode of operation and printing out what we asked for
if [ &quot;$MODE&quot; == &quot;up&quot; ]; then
  echo &quot;Starting nodes with CLI timeout of '${MAX_RETRY}' tries and CLI delay of '${CLI_DELAY}' seconds and using database '${DATABASE}' ${CRYPTO_MODE}&quot;
  echo
elif [ &quot;$MODE&quot; == &quot;createChannel&quot; ]; then
  echo &quot;Creating channel '${CHANNEL_NAME}'.&quot;
  echo
  echo &quot;If network is not up, starting nodes with CLI timeout of '${MAX_RETRY}' tries and CLI delay of '${CLI_DELAY}' seconds and using database '${DATABASE} ${CRYPTO_MODE}&quot;
  echo
elif [ &quot;$MODE&quot; == &quot;down&quot; ]; then
  echo &quot;Stopping network&quot;
  echo
elif [ &quot;$MODE&quot; == &quot;restart&quot; ]; then
  echo &quot;Restarting network&quot;
  echo
elif [ &quot;$MODE&quot; == &quot;deployCC&quot; ]; then
  echo &quot;deploying chaincode on channel '${CHANNEL_NAME}'&quot;
  echo
else
  printHelp
  exit 1
fi

if [ &quot;${MODE}&quot; == &quot;up&quot; ]; then
  networkUp
elif [ &quot;${MODE}&quot; == &quot;createChannel&quot; ]; then
  createChannel
elif [ &quot;${MODE}&quot; == &quot;deployCC&quot; ]; then
  deployCC
elif [ &quot;${MODE}&quot; == &quot;down&quot; ]; then
  networkDown
elif [ &quot;${MODE}&quot; == &quot;restart&quot; ]; then
  networkDown
  networkUp
else
  printHelp
  exit 1
fi

</code></pre>
<h2 id="启动test-network">启动test-network</h2>
<pre><code class="language-shell">root@lizonglin-virtual-machine:/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network# ./network.sh up
# 可以看到，默认使用leveldb
Starting nodes with CLI timeout of '5' tries and CLI delay of '3' seconds and using database 'leveldb' with crypto from 'cryptogen'

LOCAL_VERSION=2.2.1
DOCKER_IMAGE_VERSION=2.2.1
/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network/../bin/cryptogen

# 首先使用cryptogen创建证书
##########################################################
##### Generate certificates using cryptogen tool #########
##########################################################

# 组织1
##########################################################
############ Create Org1 Identities ######################
##########################################################
+ cryptogen generate --config=./organizations/cryptogen/crypto-config-org1.yaml --output=organizations
org1.example.com
+ res=0
+ set +x
# 组织2
##########################################################
############ Create Org2 Identities ######################
##########################################################
+ cryptogen generate --config=./organizations/cryptogen/crypto-config-org2.yaml --output=organizations
org2.example.com
+ res=0
+ set +x
# 排序服务
##########################################################
############ Create Orderer Org Identities ###############
##########################################################
+ cryptogen generate --config=./organizations/cryptogen/crypto-config-orderer.yaml --output=organizations
+ res=0
+ set +x

Generate CCP files for Org1 and Org2
/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network/../bin/configtxgen
# 排序节点的创世区块
#########  Generating Orderer Genesis block ##############
+ configtxgen -profile TwoOrgsOrdererGenesis -channelID system-channel -outputBlock ./system-genesis-block/genesis.block
2021-01-21 18:53:34.963 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration
2021-01-21 18:53:35.017 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 002 orderer type: etcdraft
2021-01-21 18:53:35.017 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 003 Orderer.EtcdRaft.Options unset, setting to tick_interval:&quot;500ms&quot; election_tick:10 heartbeat_tick:1 max_inflight_blocks:5 snapshot_interval_size:16777216 
2021-01-21 18:53:35.017 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 004 Loaded configuration: /home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network/configtx/configtx.yaml
2021-01-21 18:53:35.019 CST [common.tools.configtxgen] doOutputBlock -&gt; INFO 005 Generating genesis block
2021-01-21 18:53:35.020 CST [common.tools.configtxgen] doOutputBlock -&gt; INFO 006 Writing genesis block
+ res=0
+ set +x
Creating network &quot;net_test&quot; with the default driver
Creating volume &quot;net_orderer.example.com&quot; with default driver
Creating volume &quot;net_peer0.org1.example.com&quot; with default driver
Creating volume &quot;net_peer0.org2.example.com&quot; with default driver
Creating peer0.org2.example.com ... done
Creating orderer.example.com    ... done
Creating peer0.org1.example.com ... done
# 现在的docker中包含的容器，test-network到这里就是初步启动成功了
CONTAINER ID   IMAGE                               COMMAND             CREATED          STATUS                  PORTS                              NAMES
ae8899485a40   hyperledger/fabric-peer:latest      &quot;peer node start&quot;   18 seconds ago   Up Less than a second   0.0.0.0:7051-&gt;7051/tcp             peer0.org1.example.com
e8e4acee2cdd   hyperledger/fabric-orderer:latest   &quot;orderer&quot;           18 seconds ago   Up Less than a second   0.0.0.0:7050-&gt;7050/tcp             orderer.example.com
c0c720b03c4a   hyperledger/fabric-peer:latest      &quot;peer node start&quot;   18 seconds ago   Up 1 second             7051/tcp, 0.0.0.0:9051-&gt;9051/tcp   peer0.org2.example.com

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VMware使用宿主机的小飞机]]></title>
        <id>https://lizonglin313.github.io/post/vmware-shi-yong-su-zhu-ji-de-xiao-fei-ji</id>
        <link href="https://lizonglin313.github.io/post/vmware-shi-yong-su-zhu-ji-de-xiao-fei-ji">
        </link>
        <updated>2021-01-17T11:13:49.000Z</updated>
        <content type="html"><![CDATA[<p>首先，在小飞机客户端设置允许本地代理允许来自局域网的连接</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/01/17/lyS2NionqGdw6Hc.png" alt="image.png" loading="lazy"></figure>
<p>然后，设置VMware的网络适配器的网络连接为桥接模式，复制连接物理网络状态，设置Ubuntu的网络，所有代理和主机都设置为宿主机的IP（如果宿主机为无线连接到网络就是WLAN的IPv4），注意端口号</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/01/17/fvbXAFNuGBZSx3i.png" alt="image.png" loading="lazy"></figure>
<p>最后，设置Ubuntu的IP地址、网关、DNS信息，与宿主机在同一局域网</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/01/17/y51ZmLcb3i7hsS2.png" alt="image.png" loading="lazy"></figure>
<p>Apply</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/01/17/6t4dfXCBHNG29RK.png" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>转载自：<a href="https://bbs.huaweicloud.com/blogs/107105">VMware下ubuntu通过主机Shadowsocks上外网VMware下ubuntu通过主机Shadowsocks上外网-云社区-华为云 (huaweicloud.com)</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git使用]]></title>
        <id>https://lizonglin313.github.io/post/git-shi-yong</id>
        <link href="https://lizonglin313.github.io/post/git-shi-yong">
        </link>
        <updated>2021-01-15T15:14:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>有关git使用中的学习记录</p>
</blockquote>
<h2 id="clone速度太慢">clone速度太慢</h2>
<h3 id="方法一">方法一</h3>
<ul>
<li>调整http提交缓存(亲测有效，使用https方式clone)</li>
</ul>
<pre><code class="language-bash">$ git config --global http.postBuffer 524288000
</code></pre>
<p>调整前：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/01/15/giAKeOhscXGqUrN.png" alt="LA0@_`KKOXC5IKFKPJ_~PRX.png" loading="lazy"></figure>
<p>调整后：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/01/15/hlJu5ioR4yxzrvg.png" alt="5DU1LP__L__P_K482P_C83O.png" loading="lazy"></figure>
]]></content>
    </entry>
</feed>