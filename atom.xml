<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lizonglin313.github.io/</id>
    <title>Big Carrot</title>
    <updated>2020-03-06T14:36:00.209Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lizonglin313.github.io/"/>
    <link rel="self" href="https://lizonglin313.github.io/atom.xml"/>
    <subtitle>人们依然相信 什么未来会更精彩</subtitle>
    <logo>https://lizonglin313.github.io/images/avatar.png</logo>
    <icon>https://lizonglin313.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Big Carrot</rights>
    <entry>
        <title type="html"><![CDATA[高数第一章 函数、极限、连续]]></title>
        <id>https://lizonglin313.github.io/post/高数第一章函数极限连续</id>
        <link href="https://lizonglin313.github.io/post/高数第一章函数极限连续">
        </link>
        <updated>2020-03-06T13:49:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一节-函数">第一节 函数</h2>
<h3 id="考试内容概要">考试内容概要</h3>
<h4 id="一-函数的概念及常见函数">一、函数的概念及常见函数</h4>
<ol>
<li>函数概念</li>
<li>复合函数</li>
<li>反函数</li>
<li>初等函数</li>
</ol>
<h4 id="二-函数的性质">二、函数的性质</h4>
<ol>
<li>单调性</li>
<li>奇偶性</li>
<li>周期性</li>
<li>有界性</li>
</ol>
<h3 id="常考题型">常考题型</h3>
<h4 id="一-函数有界性-单调性-周期性及奇偶性的判定">一、函数有界性、单调性、周期性及奇偶性的判定</h4>
<h4 id="二-复合函数">二、复合函数</h4>
<h2 id="第二节-极限">第二节 极限</h2>
<h3 id="考试内容概要-2">考试内容概要</h3>
<h4 id="一-极限的概念">一、极限的概念</h4>
<ol>
<li>数列的极限</li>
<li>函数的极限
<ul>
<li>自变量趋于无穷大时函数的极限</li>
<li>自变量趋于有限值时函数的极限</li>
</ul>
</li>
</ol>
<h4 id="二-极限的性质">二、极限的性质</h4>
<ol>
<li>有界性
<ul>
<li>数列</li>
<li>函数</li>
</ul>
</li>
<li>保号性
<ul>
<li>数列</li>
<li>函数</li>
</ul>
</li>
<li>极限与无穷小之间的关系</li>
</ol>
<h4 id="三-极限的存在准则">三、极限的存在准则</h4>
<ol>
<li>夹逼准则</li>
<li>单调有界准则</li>
</ol>
<h4 id="四-无穷小量">四、无穷小量</h4>
<ol>
<li>无穷小量的概念</li>
<li>无穷小的比较</li>
<li>无穷小的性质</li>
</ol>
<h4 id="五-无穷大量">五、无穷大量</h4>
<ol>
<li>无穷大量的概念</li>
<li>常用的一些无穷大量的比较</li>
<li>无穷大量的性质</li>
<li>无穷大量与无界变量的关系</li>
<li>无穷大量与无穷小量的关系</li>
</ol>
<h3 id="常考题型-2">常考题型</h3>
<h4 id="一-极限的概念-性质及存在准则">一、极限的概念、性质及存在准则</h4>
<h4 id="二-求极限">二、求极限</h4>
<p>常用的8种求极限的方法</p>
<ul>
<li>
<p>方法1 利用基本极限求极限</p>
<ol>
<li>常用的基本极限</li>
<li>$ 1^{无穷} $型极限常用结论</li>
</ol>
</li>
<li>
<p>方法2 利用等价无穷小代换求极限</p>
<ol>
<li>
<p>代换原则</p>
<p>1)乘除可换</p>
<p>2)加减在一定关系下可以换(相减不正、相加不负)</p>
</li>
<li>
<p>常用的等价无穷小</p>
</li>
</ol>
</li>
<li>
<p>方法3 利用有理运算法则求极限</p>
</li>
<li>
<p>方法4 利用洛必达法则求极限</p>
</li>
<li>
<p>方法5 利用泰勒公式求极限</p>
</li>
<li>
<p>方法6 利用夹逼原理求极限</p>
</li>
<li>
<p>方法7 利用单调有界准则求极限</p>
</li>
<li>
<p>方法8 利用定积分定义求极限</p>
</li>
</ul>
<h4 id="三-无穷小量阶的比较">三、无穷小量阶的比较</h4>
<h2 id="第三节-函数的连续性">第三节 函数的连续性</h2>
<h3 id="考试内容概要-3">考试内容概要</h3>
<h4 id="一-连续性的概念">一、连续性的概念</h4>
<h4 id="二-间断点及其分类">二、间断点及其分类</h4>
<ol>
<li>间断点的定义</li>
<li>间断点的分类</li>
</ol>
<h4 id="三-连续性的运算与性质">三、连续性的运算与性质</h4>
<h4 id="四-闭区间上连续函数的性质">四、闭区间上连续函数的性质</h4>
<ul>
<li>最值定理</li>
<li>有界性定理</li>
<li>介值定理</li>
<li>零点定理</li>
</ul>
<h3 id="常考题型-3">常考题型</h3>
<h4 id="一-讨论函数的连续性及间断点类型">一、讨论函数的连续性及间断点类型</h4>
<h4 id="二-有关闭区间上连续函数性质的证明题">二、有关闭区间上连续函数性质的证明题</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode线性问题合辑（数组、链表、栈、队列）]]></title>
        <id>https://lizonglin313.github.io/post/leetcode-lian-biao-he-ji</id>
        <link href="https://lizonglin313.github.io/post/leetcode-lian-biao-he-ji">
        </link>
        <updated>2020-02-22T13:39:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="leetcode001-两数之和">leetcode001-两数之和</h2>
<h3 id="题目重述">题目重述</h3>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<h3 id="题解">题解</h3>
<blockquote>
<p>程序员小吴(C++) Karl Xavier(Go)</p>
</blockquote>
<h5 id="c版本思路及代码">C++版本思路及代码</h5>
<p>设置一个<code>map</code>容器和<code>record</code>用来记录元素的值与索引，然后遍历数组<code>nums</code>。</p>
<ul>
<li>每次遍历中使用临时变量<code>complement</code>用来保存目标值与当前值的差值</li>
<li>在此次遍历中查找<code>record</code>，查看是否有与<code>complement</code>一致的值，如果查找成功则返回查找值的索引与当前<code>nums</code>中变量值的索引<code>i</code></li>
<li>如果未找到，则在<code>record</code>中保存该元素与索引值<code>i</code></li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
using namespace std;

class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {
        unordered_map&lt;int, int&gt; record;
        for (int i = 0; i &lt; nums.size(); ++i) {
            int complement = target - nums[i];
            if (record.find(complement) != record.end()) {  // 如果在 map 里没有查找到，就返回 end()
                int res[] = {i, record[complement]};
                cout &lt;&lt; res &lt;&lt; endl;
                cout &lt;&lt; res + 2 &lt;&lt; endl;
                return vector&lt;int&gt;(res, res + 2);
            }
            record[nums[i]] = i;    // 查到了， 将原数组值变为其下标
        }
        return vector&lt;int&gt;();
    }
};

// [2,7,11,15]
// 9
int main() {
    vector&lt;int&gt; nums = {2, 7, 11, 15};
    vector&lt;int&gt; res;
    int target = 9;
    Solution s = *new Solution();
    res = s.twoSum(nums, target);
    for (int i = 0; i &lt; res.size(); ++i) {
        cout &lt;&lt; res[i] &lt;&lt; endl;
    }
}


</code></pre>
<h5 id="go版本思路及代码">Go版本思路及代码</h5>
<ul>
<li>创建<code>map</code>映射<code>v</code>，存放目标数组的相关信息</li>
<li>遍历目标数组，并获取目标值<code>target</code>与数组元素<code>nums[i]</code>的差值<code>dif</code></li>
<li>将差值<code>dif</code>作为<code>map</code>中的<code>key</code>，目标数组<code>nums</code>的索引作为<code>map</code>中的<code>value</code></li>
<li>判断<code>map</code>中是否包含差值<code>dif</code>，如果包含则返回对应的<code>value</code></li>
<li>如果<code>map</code>中没有，则把其放到<code>map</code>中</li>
</ul>
<pre><code class="language-go">package main
import &quot;fmt&quot;

func twoSum(nums []int, target int) []int {
	v := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		dif := target - nums[i]
		c, ok := v[dif]
		if ok != false {
			return []int{c, i}
		}
		v[nums[i]] = i
	}
	return []int{-1, -1}
}
// [2,7,11,15]
// 9
func main() {
	target := 9
	nums := []int{2, 7, 11, 15}
	fmt.Print(twoSum(nums, target))
    
}
</code></pre>
<h2 id="leetcode002-两数相加">leetcode002-两数相加</h2>
<h3 id="题目重述-2">题目重述</h3>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807
</code></pre>
<h3 id="题解-2">题解</h3>
<blockquote>
<p>陈乐乐(c++) dp0qb(go)</p>
</blockquote>
<h5 id="c版本思路及代码-2">C++版本思路及代码</h5>
<p>将长度较短的链表在末尾补<code>0</code>使得两个链表长度相等，然后再一个一个元素对其相加，需要注意的是要考虑进位。</p>
<ul>
<li>获取两个链表的长度</li>
<li>较短的链表末尾补零</li>
<li>对齐相加，注意考虑进位</li>
</ul>
<pre><code class="language-c++">struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}    // 定义链表的构造方法
};
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        int len1 = 1;   // 记录L1的长度
        int len2 = 1;   // 记录L2的长度
        ListNode *p = l1;
        ListNode *q = l2;
        while (p-&gt;next != NULL) {
            // 获取 L1 的长度
            len1++;
            p = p-&gt;next;
        }
        while (q-&gt;next != NULL) {
            // 获取 L2 的长度
            len2++;
            q = q-&gt;next;
        }
        if (len1 &gt; len2) {
            // 如果 L1 比 L2 长，在 L2 末尾补零
            for (int i = 0; i &lt;= len1 - len2; ++i) {
                q-&gt;next = new ListNode(0);
                q = q-&gt;next;
            }
        } else {
            // L2 长 就在 L1 后面补 0
            for (int i = 0; i &lt;= len2 - len1; ++i) {
                p-&gt;next = new ListNode(0);
                p = p-&gt;next;
            }
        }
        p = l1;
        q = l2;
        bool count = false;     // 记录进位
        ListNode *l3 = new ListNode(-1);    // 结果链表
        ListNode *w = l3;       // L3 的移动指针
        int i = 0;                // 记录相加结果
        while (p != NULL &amp;&amp; q != NULL) {
            i = count + p-&gt;val + q-&gt;val;
            w-&gt;next = new ListNode(i % 10);
            count = i &gt;= 10 ? true : false;
            w = w-&gt;next;
            p = p-&gt;next;
            q = q-&gt;next;
        }
        if (count) {
            // 如果最后还有进位
            w-&gt;next = new ListNode(1);
            w = w-&gt;next;
        }
        return l3-&gt;next;    // L3 头为 -1
    }
};
</code></pre>
<h5 id="go版本思路及代码-2">Go版本思路及代码</h5>
<ul>
<li>依次正常遍历链表，按照对应位两数相加，如果超过<code>10</code>，则取结果的个位数，下一位加<code>1</code></li>
<li>如果一个链表比另一个链表短，那么长的链表就直接加<code>0</code></li>
<li>如果最后一位相加之和大于<code>10</code>，那么最后不要忘记加上一个<code>1</code>结点</li>
</ul>
<pre><code class="language-go">/**  Definition for singly-linked list.  **/
type ListNode struct {
	Val  int
	Next *ListNode
}
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	var i, s int             // 分别表示 相加是否大于10 ，以及 两数之和
	res := &amp;ListNode{Val: 0} // 头结点
	now := res               // 当前节点
	for true {
		if i &gt; 0 {
			// 前面两数之和大于10，当前的和加 1
			s = l1.Val + l2.Val + 1
		} else {
			s = l1.Val + l2.Val
		}
		if s &gt;= 10 {
			// 两数之和大于10 该位 s-10 否则就是 本身，并设置 i标记
			now.Next = &amp;ListNode{Val: s - 10}
			i = 1
		} else {
			now.Next = &amp;ListNode{Val: s}
			i = 0
		}
		now = now.Next
		// 当 l1 和 l2 移到最后
		if l1.Next == nil &amp;&amp; l2.Next == nil {
			// 如果 l1 l2 最后的和大于10 即i==1 那么后面还需要加一个 1
			if i == 1 {
				now.Next = &amp;ListNode{Val: 1}
			}
			break;
		}
		// l1 到最后 如果是 l2 没结束，把 l1 当前结点设置为0 继续和 l2 相加，否则后移指针
		if l1.Next == nil {
			l1.Val = 0
		} else {
			l1 = l1.Next
		}
		// 同理 对 l2 有
		if l2.Next == nil {
			l2.Val = 0
		} else {
			l2 = l2.Next
		}
	}
	// 返回头结点的下一个结点指针
	return res.Next
}
</code></pre>
<h2 id="leetcode020-有效的括号">leetcode020-有效的括号</h2>
<h3 id="题目重述-3">题目重述</h3>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>
左括号必须以正确的顺序闭合。<br>
注意空字符串可被认为是有效字符串。</p>
<pre><code>示例 1:
输入: &quot;()&quot;
输出: true

示例 2:
输入: &quot;()[]{}&quot;
输出: true

示例 3:
输入: &quot;(]&quot;
输出: false

示例 4:
输入: &quot;([)]&quot;
输出: false

示例 5:
输入: &quot;{[]}&quot;
输出: true
</code></pre>
<h3 id="题解-3">题解</h3>
<blockquote>
<p>c***6(c++) chris(go)</p>
</blockquote>
<h5 id="c版本思路及代码-3">C++版本思路及代码</h5>
<ul>
<li>使用<code>vector</code>来模拟栈</li>
<li>每次取前半括号包括<code>(</code>、<code>[</code>、<code>{</code>都将其入栈</li>
<li>如果取到的是后半括号<code>)</code>、<code>]</code>、<code>}</code>就与取栈顶元素进行匹配，如果匹配就进行出栈操作，不匹配就返回错误</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    bool isValid(string s) {
        int len = s.length();
        int tmp;
        // 用 vector 模拟栈
        vector&lt;char&gt; hp;
        for (int i = 0; i &lt; len; i++) {
            // 入栈
            if (s[i] == '(' || s[i] == '[' || s[i] == '{')
                hp.push_back(s[i]);	// 进栈
            else {
                // 栈空
                if (hp.size() == 0)return false;
                // 取栈顶元素，注意这不是出栈
                tmp = hp.back();
                // 出栈
                if (tmp == '(' &amp;&amp; s[i] == ')' || tmp == '[' &amp;&amp; s[i] == ']' || tmp == '{' &amp;&amp; s[i] == '}')
                    hp.pop_back();  // 出栈
                else
                    return false;
            }
        }
        return hp.size() == 0;
    }
};
</code></pre>
<h5 id="go版本思路及代码-3">Go版本思路及代码</h5>
<p>利用数组切片模拟栈进行操作。</p>
<ul>
<li>使用<code>map</code>用<code>symbol</code>变量保存匹配规则，只有到右括号的时候才取左括号</li>
<li>申请<code>c</code>保存左括号</li>
<li>依次对字符串<code>s</code>进行遍历
<ul>
<li>用<code>clen</code>保存<code>c</code>的长度，先判断<code>clen</code>长度是否大于零
<ul>
<li>不大于零，将这个字符<code>value</code>加入</li>
<li>大于零，同时如果<code>symbol</code>中存在这个字符的<code>key</code>，就和<code>clen</code>最新加入的值进行匹配，匹配成功对<code>c</code>进行切片，把最新加入的值切掉</li>
</ul>
</li>
</ul>
</li>
<li>最后判断<code>c</code>是否为空，空了说明都匹配了</li>
</ul>
<pre><code class="language-go">func isValid(s string) bool {
	var c []byte
	symbol := map[byte]byte{
		')': '(',
		']': '[',
		'}': '{',
	}
	for _, value := range s {
		clen := len(c)
		if clen &gt; 0 {
			if _, ok := symbol[byte(value)]; ok {
				if c[clen-1] == symbol[byte(value)] {
					c = c[:clen-1]
					continue
				}
			}
		}
		c = append(c, byte(value))
	}
	return len(c) == 0
</code></pre>
<h2 id="leetcode026-删除排序数组中的重复项">leetcode026-删除排序数组中的重复项</h2>
<h3 id="题目重述-4">题目重述</h3>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<pre><code>示例 1:
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。

示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<h3 id="题解-4">题解</h3>
<blockquote>
<p>题解：陈乐乐(C++)  BeYanJin(Go)</p>
<p>这个题目两种代码版本的思路基本相同，以Golang代码为例。</p>
</blockquote>
<p>使用快慢指针的思想来操作数组元素。</p>
<ul>
<li>定义慢指针<code>low</code>让它始终指向数组的有序无重复序列的最后一项，即其所指位置的后一项就是有重复元素的项</li>
<li>定义快指针<code>fast</code>让它始终指向数组中没有加入有序无重复序列的第一项</li>
<li>如果<code>nums[fast] != nums[low]</code>，就有<code>nums[low+1] = nums[fast]</code>，然后<code>low++</code>；否则<code>fast++</code>，寻找没有加入无重复序列的那项</li>
</ul>
<h5 id="c版本思路及代码-4">C++版本思路及代码</h5>
<pre><code class="language-c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt; &amp;nums) {
        if (nums.size() == 0) return 0;
        int i = 0;
        for (int j = 1; j &lt; nums.size(); ++j) {
            if (nums[j] != nums[i]) {
                i++;
                nums[i] = nums[j];
            }
        }
        return i + 1;
    }
};
</code></pre>
<h5 id="go版本思路及代码-4">Go版本思路及代码</h5>
<pre><code class="language-go">func removeDuplicates(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	low := 0
	for fast := 0; fast &lt; len(nums); fast++ {
		if nums[low] != nums[fast] {
			nums[low+1] = nums[fast]
			low++
		}
	}
	return low + 1
}
</code></pre>
<h2 id="leetcode053-最大子序和">leetcode053-最大子序和</h2>
<h3 id="题目重述-5">题目重述</h3>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre>
<h3 id="题解-5">题解</h3>
<blockquote>
<p>题解：pinku-2</p>
</blockquote>
<h5 id="动态规划">动态规划</h5>
<ul>
<li>动态规划的关键点我认为有两个部分：
<ul>
<li>确定dp数组：<code>dp[i]</code>表示以<code>i</code>结尾的字段的和的最大值</li>
<li>建立状态转移方程：<code>dp[i]</code>的值等于<code>max(dp[i-1],0)+nums[i]</code>，这是因为：如果<code>dp[i]</code>最大并且<code>dp[i-1]</code>大于<code>0</code>，那么<code>dp[i-1]</code>也最大；如果<code>dp[i-1]</code>小于<code>0</code>，那么前面的数就不用加上去了，所以干脆直接取<code>nums[i]</code>。</li>
</ul>
</li>
<li>故有递推公式：$ dp[i] = max(dp[i-1], 0) + nums[i] $</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/02/05/nYuqp5Z1sa6DBoO.png" alt="e6ca21377d5533204c3149e0b5cdcc146ada4efe1ed2294b3e0615cdb4754853-file_1576478143560.png" loading="lazy"></figure>
<pre><code class="language-c++">class Solution1 {
public:
    int maxSubArray(vector&lt;int&gt; &amp;nums) {
        int result = INT_MIN;
        int numsSize = int(nums.size());
        vector&lt;int&gt; dp(numsSize);   // dp[i]表示nums中以nums[i]结尾的最大子序和
        dp[0] = nums[0];
        result = dp[0];
        for (int i = 1; i &lt; numsSize; ++i) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            result = max(result, dp[i]);
        }
        return result;
    }
};
</code></pre>
<h5 id="分治法">分治法</h5>
<p>最大子序和是使用分治法解决问题的典型的例子，并且可以用与合并排序相似的算法求解。下面是用分治法解决问题的模板：</p>
<ul>
<li>定义基本情况。</li>
<li>将问题分解为子问题并递归地解决它们。</li>
<li>合并子问题的解以获得原始问题的解。</li>
</ul>
<p>当最大子数组有 <code>n</code> 个数字时：</p>
<ul>
<li>若 <code>n==1</code>，返回此元素。</li>
<li><code>left_sum</code> 为最大子数组前 <code>n/2</code> 个元素，在索引为 <code>(left + right) / 2</code> 的元素属于左子数组。</li>
<li><code>right_sum</code> 为最大子数组的右子数组，为最后 <code>n/2</code> 的元素。</li>
<li><code>mid_sum</code> 是包含左右子数组且含索引 <code>(left + right) / 2</code> 的最大值。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/02/05/1LZbIoUg9JYdVqH.png" alt="11.png" loading="lazy"></figure>
<pre><code class="language-c++">class Solution2 {
public:
    int maxSubArray(vector&lt;int&gt; &amp;nums) {
        int result = INT_MIN;
        int numsSize = int(nums.size());
        result = maxSubArrayHelper(nums, 0, numsSize - 1);
        return result;
    }

    int maxSubArrayHelper(vector&lt;int&gt; &amp;nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }
        int mid = (left + right) / 2;
        int leftSum = maxSubArrayHelper(nums, left, mid);
        int rightSum = maxSubArrayHelper(nums, mid + 1, right);
        int midSum = findMaxCrossingSubarray(nums, left, mid, right);
        int result = max(leftSum, rightSum);
        result = max(result, midSum);
        return result;
    }

    int findMaxCrossingSubarray(vector&lt;int&gt; &amp;nums, int left, int mid, int right) {
        int leftSum = INT_MIN;
        int sum = 0;
        for (int i = mid; i &gt;= left; i--) {
            sum += nums[i];
            leftSum = max(leftSum, sum);
        }

        int rightSum = INT_MIN;
        sum = 0;
        for (int i = mid + 1; i &lt;= right; i++) {
            sum += nums[i];
            rightSum = max(rightSum, sum);
        }
        return (leftSum + rightSum);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用三角函数公式]]></title>
        <id>https://lizonglin313.github.io/post/chang-yong-san-jiao-han-shu-gong-shi</id>
        <link href="https://lizonglin313.github.io/post/chang-yong-san-jiao-han-shu-gong-shi">
        </link>
        <updated>2020-02-11T07:12:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>高中学的好多都忘了...整理一下</p>
</blockquote>
<h2 id="函数关系">函数关系</h2>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/02/11/RWAUhDECZ6G2abp.png" alt="关系.png" loading="lazy"></figure>
<h2 id="基本公式">基本公式</h2>
<h3 id="二角和差公式">二角和差公式</h3>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/02/11/wyML91GqsVTf2rh.png" alt="关系.png" loading="lazy"></figure>
<h3 id="二倍角公式">二倍角公式</h3>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/02/11/nvOeFSYBCuRQhGd.png" alt="关系.png" loading="lazy"></figure>
<h3 id="半角公式">半角公式</h3>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/02/11/1XDxmbOgrtjdwY4.png" alt="TIM截图20200211162330.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录不熟的单词]]></title>
        <id>https://lizonglin313.github.io/post/ji-lu-bu-shou-de-dan-ci</id>
        <link href="https://lizonglin313.github.io/post/ji-lu-bu-shou-de-dan-ci">
        </link>
        <updated>2020-02-07T07:45:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="名词">名词</h2>
<ul>
<li>attorney n. 律师</li>
<li>approval n.批准，赞成</li>
<li>accord n.协议，条约；v.与...相符，配合</li>
<li>barrel n.桶；v.飞驰</li>
<li>beast n.野兽</li>
<li>berry n.浆果</li>
<li>crane n.起重机，鹤；v.探头</li>
<li>compromise n.妥协，让步；v.妥协，让步；adj.妥协的，折中的</li>
<li>celebrity n.名人，明星；名声</li>
<li>credentials n.资历；资历证明</li>
<li>departure n.启程；脱离</li>
<li>demand n.需求；v.需求</li>
<li>doom n.死亡；v.注定失败的</li>
<li>devil n. 恶魔，淘气鬼； v. 困扰，折磨</li>
<li>descent n.下降下落；血统，出身</li>
<li>dose n.一剂，一服；v.给..服药</li>
<li>foam n.气泡，泡沫</li>
<li>enzyme n.酶</li>
<li>jungle n.热带丛林；杂乱无章的地方</li>
<li>haste n.匆忙 v.赶快</li>
<li>horror n.战栗，恐怖</li>
<li>identification n.鉴别，确认；身份证明；密切联系；认同</li>
<li>incentive n.刺激，奖励</li>
<li>instability n.不稳定性</li>
<li>intuition n.直觉</li>
<li>idiot n.蠢货</li>
<li>genius n.天才，天赋</li>
<li>grant n.拨款，补助金；v.给予；承认</li>
<li>grape n.葡萄</li>
<li>genre n.体裁，类型</li>
<li>mosaic n. 马赛克</li>
<li>precedent n.先例</li>
<li>property n.财产，资产；特性，性能</li>
<li>parcel n.包裹；v.打包</li>
<li>quota n.限额</li>
<li>strait n.海峡，水道；困境</li>
<li>siege n.包围，围攻</li>
<li>strife n.冲突</li>
<li>statue n.法令，规则</li>
<li>solidarity n.团结</li>
<li>tournament n. 锦标赛</li>
<li>sack n.麻布袋；</li>
<li>spectacle n.眼镜；壮观的景象</li>
<li>sediment n.沉渣，沉淀物</li>
<li>symptom n.症状</li>
<li>seminar n.研讨会</li>
<li>estate n.私有土地，庄园</li>
<li>dwelling n.住所</li>
<li>debut n.首次登台，问世；v.首次登台，问世</li>
<li>lamb n.羔羊</li>
<li>lavatory n.厕所</li>
<li>legacy n.遗物</li>
<li>refuge n.庇护，避难所</li>
<li>reservoir n.蓄水池；储藏</li>
<li>rib n.肋骨</li>
<li>revolt n.反抗；v.反抗</li>
<li>amber n.琥珀</li>
<li>reptile n.爬行动物</li>
<li>racket n.喧哗；诈骗；v.吵闹</li>
<li>riddle n.谜语</li>
<li>reproach n.责备，指责; vt.责备指责</li>
<li>timber n.树林，原木</li>
<li>vigilance n.警戒</li>
<li>vaccine n.疫苗</li>
<li>vibration n.振动，颤动</li>
<li>verdict n.裁定，定论</li>
</ul>
<h2 id="动词">动词</h2>
<ul>
<li>aggravate v.加重，恶化</li>
<li>accommodate v.容纳，适应</li>
<li>acknowledge v.承认，接受</li>
<li>deteriorate vi.恶化，衰退</li>
<li>disrupt v.使中断，扰乱</li>
<li>denote v.象征，意指</li>
<li>disseminate v.散步，传播</li>
<li>discharge v.准许离开，释放；完成任务，履行职务</li>
<li>derive v.起源，来自于</li>
<li>combat v.与...战斗；n.战斗</li>
<li>commend v.赞成；推荐</li>
<li>counsel n.给予咨询，建议；n.律师，法律顾问</li>
<li>clutch v.抓紧</li>
<li>chill v.使冰冷；使镇定；n.寒冷，害怕；adj.寒冷的，令人沮丧的</li>
<li>hunt v.搜寻，寻找，打猎；n.寻找，打猎</li>
<li>engrave v.雕刻</li>
<li>encompass v.包含；包围</li>
<li>extinguish v.扑灭，使熄灭</li>
<li>lubricate v.润滑；促进</li>
<li>mourn v.哀悼，为失去感到悲哀</li>
<li>maintain v.维持，保养吗；坚称，主张</li>
<li>meditate v.沉思，打坐</li>
<li>regain v.恢复；重新得到；重返</li>
<li>rally v.聚集，扶持；n.群众大会，集会</li>
<li>rob v.夺走；抢劫</li>
<li>revive v.恢复，复活</li>
<li>gesture v.打手势，示意；n.手势，示意动作</li>
<li>graze v.放牧</li>
<li>sparkle v.闪闪发光，光点；聪明活泼</li>
<li>soothe v.使平静，安抚</li>
<li>stun v.使震惊；使昏迷</li>
<li>necessitate v.迫使，使得成为必要</li>
<li>seal v.密封，印章，封锁</li>
<li>snap v.一声绷断，打响指；adj.迅速的，突然的</li>
<li>spicy adj.辛辣的</li>
<li>sneeze v.打喷嚏</li>
<li>swarm v.蜂拥；n.一大群</li>
<li>shrivel v.枯萎，使得束手无策</li>
<li>jeer v.嘲讽</li>
<li>foster v.促进，助长，抚养；adj.代养的</li>
<li>inlet n.水湾；机器上的进口</li>
<li>initiate v.开始；发起；吸纳；n.创始人</li>
<li>preach v.讲道，传教；宣传，鼓吹</li>
<li>pinch v.捏，掐；n.少量</li>
<li>transcend v.超出</li>
<li>torture v.拷问；n.拷问</li>
<li>thumb v.用拇指翻动，翻阅；n.拇指</li>
</ul>
<h2 id="形容词">形容词</h2>
<ul>
<li>analogue adj.模拟的；n.相似物</li>
<li>bland adj.无聊的</li>
<li>bleak adj.寒冷的；暗淡的(形势)</li>
<li>comprehensive adj.全面的，广泛的</li>
<li>simultaneous adj.同时出现的，同步的</li>
<li>selective adj.选择性的，仔细挑选的</li>
<li>subjective adj.主观上的；个人的</li>
<li>sociable adj.友善的，喜欢交际的</li>
<li>solitary adj.单独的，独自的</li>
<li>tragic adj.悲惨的，悲剧的</li>
<li>viable adj.切实可行的</li>
<li>indicative adj.显示的，象征的，指示的；n.陈述语气</li>
<li>exceptional adj.优异的，非凡的</li>
<li>legible adj.清楚的，易读的</li>
<li>lame adj.跛的，瘸的；站不住脚的</li>
<li>dental adj.牙科的</li>
<li>denounce v.谴责，抨击</li>
<li>dense adj.稠密的，浓重的</li>
<li>diligent adj.勤奋的</li>
<li>earnest adj.热心的</li>
<li>hasty adj.仓促的</li>
<li>monetary adj.货币的，金融的</li>
<li>militant adj.好战的；n.激进分子</li>
<li>naive adj.天真的</li>
<li>naughty adj.顽皮的</li>
<li>plural adj.复数的 n.复数</li>
<li>opaque adj.不透明的，浑浊的，晦涩的</li>
<li>occasional adj.偶然的，非正式的</li>
<li>rotten adj.腐烂的</li>
<li>redundant adj.累赘的，冗长的</li>
</ul>
<h2 id="副词">副词</h2>
<ul>
<li>namely adv.即，也就是</li>
<li>furthermore adv.而且，此外</li>
<li>accordingly adv.因此，相应地</li>
<li>alike adv.相同的，相似的；adj.彼此相似的</li>
</ul>
<h2 id="介词">介词</h2>
<ul>
<li>notwithstanding prep.虽然，尽管</li>
<li>in spite of 尽管，不顾，虽然</li>
<li>via prep.经由，通过</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ Vector的简单说明]]></title>
        <id>https://lizonglin313.github.io/post/c-vector-rong-qi-de-jian-dan-shuo-ming</id>
        <link href="https://lizonglin313.github.io/post/c-vector-rong-qi-de-jian-dan-shuo-ming">
        </link>
        <updated>2020-02-03T16:10:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>整理自wiki、菜鸟教程、W3Cschool</p>
</blockquote>
<h3 id="什么是vector">什么是Vector</h3>
<p><strong>Vector</strong> 是<a href="https://zh.wikipedia.org/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E7%A8%8B%E5%BC%8F%E5%BA%AB">C++标准程序库</a>中的一个<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">类</a>，可视为会自动扩展容量的数组，以循序(Sequential)的方式维护变量集合。vector的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。vector是<a href="https://zh.wikipedia.org/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E7%A8%8B%E5%BC%8F%E5%BA%AB">C++标准程序库</a>中的众多<a href="https://zh.wikipedia.org/wiki/%E5%AE%B9%E5%99%A8_(%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B)">容器</a>（<em>container</em>）之一。 vector以<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF_(C%2B%2B)">模板</a>(泛型)方式实现，可以保存任意类型的变量，包括用户自定义的数据类型，例如：它可以是放置整数（int）类型的 vector、也可以是放置字符串（string）类型的 vector、或者放置用户自定类别（user-defined class）的 vector。(from:wiki)</p>
<p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。(from:runoob)</p>
<p>在c++中，vector是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。(from:w3cschool)</p>
<h3 id="特性">特性</h3>
<ul>
<li>顺序序列：顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</li>
<li>动态数组：支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</li>
<li>内存分配器感知：容器使用一个内存分配器对象来动态地处理它的存储需求。</li>
</ul>
<blockquote>
<p>注意⚠</p>
<ol>
<li>
<p>如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p>
</li>
<li>
<p>Vector作为函数的参数或者返回值时，需要注意它的写法：</p>
<p><code>double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b)</code></p>
</li>
</ol>
</blockquote>
<h3 id="使用方法">使用方法</h3>
<h4 id="基本方法">基本方法</h4>
<ul>
<li>引入头文件</li>
</ul>
<pre><code class="language-c++">#include &lt;vector&gt;
</code></pre>
<ul>
<li>创建vector对象</li>
</ul>
<pre><code class="language-c++">vector&lt;int&gt; vec;
</code></pre>
<ul>
<li>在尾部插入一个元素</li>
</ul>
<pre><code class="language-c++">vec.push_back(a);
</code></pre>
<ul>
<li>在尾部删除一个元素</li>
</ul>
<pre><code class="language-c++">vec.pop_back();
</code></pre>
<ul>
<li>使用下标访问</li>
</ul>
<pre><code class="language-c++">cout &lt;&lt; vec[0] &lt;&lt; endl;
</code></pre>
<ul>
<li>使用迭代器访问</li>
</ul>
<pre><code class="language-c++">vector&lt;int&gt;::iterator it;
for (it = vec.begin(); it != vec.end(); it++)
    cout &lt;&lt; *it &lt;&lt; endl;
</code></pre>
<ul>
<li>在第<code>i+1</code>个元素前插入<code>a</code></li>
</ul>
<pre><code class="language-c++">vec.insert(vec.begin()+i,a);
</code></pre>
<ul>
<li>删除第三个元素</li>
</ul>
<pre><code class="language-c++">vec.erase(vec.begin()+2);
</code></pre>
<ul>
<li>删除区间<code>[i,j-1]</code>，区间从<code>0</code>开始</li>
</ul>
<pre><code class="language-c++">vec.erase(vec.begin()+i,vec.end()+j);
</code></pre>
<ul>
<li>获取长度</li>
</ul>
<pre><code class="language-c++">vec.size();
</code></pre>
<ul>
<li>清空</li>
</ul>
<pre><code class="language-c++">vec.clear();
</code></pre>
<ul>
<li>逆序，需要引入头文件<code>#include&lt;algorithm&gt;</code></li>
</ul>
<pre><code class="language-c++">reverse(vec.begin(),vec.end());
</code></pre>
<ul>
<li>使用<code>sort</code>排序，需要引入头文件<code>#include&lt;algorithm&gt;</code></li>
</ul>
<pre><code class="language-c++">sort(vec.begin(),vec.end());	// 默认升序

/* 通过重写排序算法降序排列 */
bool Comp(const int &amp;a,const int &amp;b)
{
    return a&gt;b;
}
sort(vec.begin(),vec.end(),Comp);	// 调用
</code></pre>
<h4 id="二维数组定义">二维数组定义</h4>
<p>方法1：</p>
<pre><code class="language-c++">#include &lt;string.h&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()
{
    int N = 5, M = 6; 
    vector&lt;vector&lt;int&gt;&gt; obj(N); 	//定义二维动态数组大小5行 
    for(int i = 0; i &lt; obj.size(); i++)	//动态二维数组为5行6列，值全为0 
    { 
        obj[i].resize(M);	
        // resize()改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 
    } 
 
    for(int i = 0; i&lt; obj.size(); i++)//输出二维动态数组 
    {
        for(int j = 0; j &lt; obj[i].size(); j++)
        {
            cout &lt;&lt; obj[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre>
<p>方法2：</p>
<pre><code class="language-c++">#include &lt;string.h&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
 
int main()
{
    int N = 5, M = 6; 
    vector&lt;vector&lt;int&gt;&gt; obj(N, vector&lt;int&gt;(M)); //定义二维动态数组5行6列 
 
    for(int i = 0; i &lt; obj.size(); i++)	//输出二维动态数组 
    {
        for(int j = 0; j &lt; obj[i].size(); j++)
        {
            cout &lt;&lt; obj[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre>
<h4 id="结构体类型元素">结构体类型元素</h4>
<blockquote>
<p>注意⚠：结构体要定义为全局！</p>
</blockquote>
<pre><code class="language-c++">#include&lt;stdio.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;iostream&gt;  
using namespace std;  
typedef struct rect  
{  
    int id;  
    int length;  
    int width;  
　　//对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。  
　　bool operator&lt; (const rect &amp;a)  const  
    {  
        if(id!=a.id)  
            return id&lt;a.id;  
        else  
        {  
            if(length!=a.length)  
                return length&lt;a.length;  
            else  
                return width&lt;a.width;  
        }  
    }  
}Rect;  
int main()  
{  
    vector&lt;Rect&gt; vec;  
    Rect rect;  
    rect.id=1;  
    rect.length=2;  
    rect.width=3;  
    vec.push_back(rect);  
    vector&lt;Rect&gt;::iterator it=vec.begin();  
    cout&lt;&lt;(*it).id&lt;&lt;' '&lt;&lt;(*it).length&lt;&lt;' '&lt;&lt;(*it).width&lt;&lt;endl;      
return 0;  
}  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020能不能重新开始]]></title>
        <id>https://lizonglin313.github.io/post/geng-zi-nian-jian-nan-de-kai-ju</id>
        <link href="https://lizonglin313.github.io/post/geng-zi-nian-jian-nan-de-kai-ju">
        </link>
        <updated>2020-01-24T15:06:31.000Z</updated>
        <content type="html"><![CDATA[<p>⏮</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见的排序算法总结]]></title>
        <id>https://lizonglin313.github.io/post/常见的排序算法总结</id>
        <link href="https://lizonglin313.github.io/post/常见的排序算法总结">
        </link>
        <updated>2019-11-21T11:36:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>整理常用的排序算法，主要包括：</p>
<ul>
<li>选择排序</li>
<li>冒泡排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>插入排序</li>
<li>堆排序</li>
</ul>
</blockquote>
<h2 id="策略以及时间开销">策略以及时间开销</h2>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>基于的思想</th>
<th>时间开销</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>蛮力法</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>蛮力法</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>归并排序</td>
<td>分治法</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>快速排序</td>
<td>分治法</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>插入排序</td>
<td>减治法</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>堆排序</td>
<td>减治法</td>
<td>O(nlogn)</td>
</tr>
</tbody>
</table>
<h2 id="部分排序的核心算法">部分排序的核心算法</h2>
<h3 id="归并排序">归并排序</h3>
<h4 id="图解">图解</h4>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/11/21/IwoPu7Eb6VrLYiR.png" alt="" loading="lazy"></figure>
<h4 id="代码">代码</h4>
<pre><code class="language-c++">/*
输入：待排序的数组r[n]，待排序区间[s,t]
输出：升序序列r[s]~r[t]
1. 如果s==t，则待排序区间只有一个元素，返回
2. 计算划分重点：m=(s+t)/2
3. 对于前半个子序列以 r[s]~r[m]进行递归，继续划分
4. 对于后半个子序列以 r[m+1]~r[t]进行递归，继续划分
5. 合并划分后的子序列：
	5.1 令i=s,j=m+1,k=s 在 i&lt;=m&amp;&amp;j&lt;=t时进行循环
		5.1.1 按照升序依次在两个子序列选择元素放入r1[]临时数组，同时改变两个子序列的索引位置
6. 处理某个子序列未放完的元素
7. 将r1复制到r中
8. 待所有递归过程结束，打印r[]
*/

void MergeSort(int r[],int s,int t){
    int m,r1[1000];
    
    if(s==t) return;		// 此时划分至只有一个元素了
	
    else{
        m = (s+t)/2;		// 继续划分
        MergeSort(r,s,m);	// 划分前半个子序列
        MergeSort(r,m+1,t);	// 划分后半个子序列
        Merge(r,r1,s,m,t);	// 合并划分后的结果
        
        for(int i=s;i&lt;=t;i++){
            r[i]=r1[i];
        }   
    }
}

/* 合并函数 */
void Merge(int r[],int r1[],int s,int m,int t){
    
    int i=s;
    int j=m+1;		// 分别标记原数组两个子序列的起始位置
    int k=s;		// 标记r1临时数组
    
    while(i&lt;=m&amp;&amp;j&lt;=t){
        if(r[i]&lt;=r[j])	r1[k++]=r[i++];
        else	r1[k++]=r[j++];
    }
    
    // 进行收尾工作
    while(i&lt;=m) r1[k++]=r[i++];
    while(j&lt;=t) r1[k++]=r[j++];
    
}
</code></pre>
<h3 id="快速排序">快速排序</h3>
<h4 id="图解-2">图解</h4>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/11/21/qRtJ6xVDgNPfHwe.jpg" alt="" loading="lazy"></figure>
<h4 id="代码-2">代码</h4>
<pre><code class="language-c++">/*
伪代码：
（假设以首元素为轴值）
输入：r[n]，first，end
输出：升序排序的r[n]
1. 选定首元素即 r[first] 为轴值
2. 如果first&lt;end
	2.1 划分左右区间，获得轴值位置
		2.1.1 令 i=first j=end, if i&lt;j 做：
		2.1.2 右侧扫描，if r[j]&gt;轴值 j-- ；反之 swap(r[i],r[j])
		2.1.3 左侧扫描，if r[i]&lt;轴值 i++ ；反之 swap(r[i],r[j])
	2.2 返回最后的i即为轴值的最新位置，pivot&lt;-i
	2.3 左孩子序列以：r,first,pivot-1 快排
    2.4 右孩子序列以：r,pivot+1,end 快排
3. 最后输出排完序的r[n]
*/

void QuickSort(int r[],int first,int end){
    int pivot;		// 轴值
    
    if(first&lt;end){
    	pivot=Partition(r,first,end);	// 划分子序列，pivot是轴值所在位置的索引
        QuickSort(r,first,pivot-1);		// 左子序列快排
        QuickSort(r,pivot+1,end);		// 右子序列快排
    }
}

/* 划分子序列，求解轴值位置 */
int Partition(int r[],int first,int end){
    int i=first;
    int j=end;
    
    while(i&lt;j){
        while(i&lt;j&amp;&amp;r[i]&lt;=r[j])	j--;
        
        if(i&lt;j){
        	int temp=r[i];
            r[i]=r[j];
            r[j]=temp;
            i++;
        }
        
        while(i&lt;j&amp;&amp;r[i]&lt;=r[j])	i++;
        
        if(i&lt;j){
            int temp=r[i];
        	r[i]=r[j];
            r[j]=temp;
            j--;
        }
    }
    return i;
}
</code></pre>
<h3 id="插入排序">插入排序</h3>
<h4 id="图解-3">图解</h4>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2019/11/21/IxXUsw3nHOTzJV2.png" alt="" loading="lazy"></figure>
<h4 id="代码-3">代码</h4>
<pre><code class="language-c++">// 设r[0]为哨兵，实际的数据从r[1]开始
for(int i=2;i&lt;=n;i++){
    r[0]=r[i];		// 使得r[0]一直为无序序列的第一个一个元素
    for(int j=i-1;r[0]&lt;r[j];j--){
        r[j+1]=r[j];		// 如果待插入元素比有序序列中某个元素小，这个元素后移
    }
    r[j+1]=r[0];
}
</code></pre>
<h3 id="堆排序">堆排序</h3>
<h4 id="图解-4">图解</h4>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2019/11/21/oLHMUvJ9eVZIXCf.jpg" alt="" loading="lazy"></figure>
<h4 id="代码-4">代码</h4>
<pre><code class="language-c++">/*
伪代码：
输入：r(k+1)~r(n)满足堆的条件，待筛选记录rk
输出：{r(k)',r(k+1)',...r(n)'}为大根堆
1. 设置i和j，分别指向要筛选的结点和其左孩子结点
2. 若ri已是叶子，则筛选完毕
	否则，比较要筛选结点的左右孩子结点，并将j指向较大的结点
3. 将ri和rj进行比较，有以下两种情况：
	3.1 如果ri&gt;rj，则完全二叉树已是堆，筛选完毕
	3.2 否则将ri和rj进行交换；令i=j，转步骤2继续执行
*/

void HeapSort(int r[],int n){
    int i,temp;
    
    for(i=(n-1)/2;i&gt;=0;i--){		// 初始建堆，最后一个分支下标为(n-1)/2
        SiftHeap(r,i,n);
    }
    
    for(i=1;i&lt;=n-1;i++){
        temp=r[0];
        r[0]=r[n-i];
        r[n-i]=temp;
        SiftHeap(r,0,n-i);			// 只需要调整根节点
    }
}

void SiftHeap(int r[],int k,int n){
    int i,j,temp;					// 置i为要筛的结点，j为i的左孩子
    i=k;
    j=i*2+1;
    while(j&lt;n){
        if(j&lt;n-1&amp;&amp;r[j]&lt;r[j+1]) j++;		// 比较i的左右孩子，j为较大者
        if(r[i]&gt;r[j]) 	break;
        else{
            // 将被筛结点与结点j交换
            temp=r[i];
            r[i]=r[j];
            r[j]=temp;
            // 被筛节点位于原来结点j的位置
            i=j;
            j=2*i+1;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用不同算法解决0/1背包问题]]></title>
        <id>https://lizonglin313.github.io/post/用不同算法解决01背包问题</id>
        <link href="https://lizonglin313.github.io/post/用不同算法解决01背包问题">
        </link>
        <updated>2019-11-21T06:34:04.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>0/1背包问题是算法中很经典的问题，具体内容题目内容不再赘述，需要请自行搜索..</p>
</blockquote>
<h2 id="蛮力法">蛮力法</h2>
<ul>
<li>
<p>思想</p>
<p>蛮力法的基本思想就是<strong>遍历</strong></p>
</li>
<li>
<p>时间复杂度</p>
<p>Ω(2^n)</p>
</li>
<li>
<p>代码</p>
<pre><code class="language-c++">// 伪代码如下
输入：重量{w1,w2,w3,...,wn} 价值{v1,v2,v3,...,vn} 容量C
输出：装入背包物品的编号和最大价值

1. maxValue=0；结果子集S={}

2. 对集合{1,2,3,...,n}每一个子集T，都有：

	2.1 初始化背包价值value=0，背包重量weight=0
    
    2.2 对每个子集里的每个元素j
    	2.2.1 if weight+wj &lt;= C then weight+=wj value+=vj
    	2.2.2 else 子集元素还没选完就超重，转2进行下一个子集
    
    2.3 进行到此处某个子集中的元素全部放入背包
    	2.3.1 if value &gt; maxValue then maxValue&lt;-value S&lt;-T

3. 输出S中的元素和maxValue，结束
</code></pre>
</li>
</ul>
<h2 id="回溯法">回溯法</h2>
<ul>
<li>
<p>思想</p>
<p><strong>解空间树</strong> + 使用<strong>限定条件</strong>进行<strong>剪枝</strong></p>
<p>在状态空间树的任意一个部分解结点处应该有以下两个判定函数：</p>
<p>1）当前部分解的总重量小于背包容量</p>
<p>2）当前问题状态下继续向前搜索搜索可以找到比目前已知解的总价值更大的解</p>
</li>
<li>
<p>时间复杂度</p>
<p>本质是蛮力法，时间通常也为<strong>指数阶</strong></p>
</li>
<li>
<p>代码</p>
<pre><code class="language-c++">// 伪代码如下
输入：重量W={w0,w1,w2,...,wn} 价值V={v0,v1,v2,...,vn} 容量C
输出：装入背包物品的编号和最大价值

1. maxValue=0；结果子集S={}

2. 将背包的物品按照单位价值降序排序，相应的改变集合W和V

3. 解空间树的层数layer=0，当前重量cw=0，当前价值cv=0，当前所选物品集合cs={}，进行如下的递归
    3.1 if layer==n 到达叶子结点
    	3.1.1 if cv &gt; maxValue then maxValue=cv S=cs
    3.2 没有到达叶子结点，for j=1 to 0
    	3.2.1 判断在此节点处是否满足这两个条件：
    		1）装入第layer个物品后不超重 
    		2）此节点处期望最大值大于maxValue
    		如果两个不同时满足，剪枝	
    		如果同时满足：根据j=1或j=0更新cv,cw,cs
    	3.2.2 进行下一层 layer+1，cv，cw，cs递归
    	3.2.3 回滚cv,cw,cs到递归前的值

4. 输出S中的元素和maxValue，结束


// 核心代码

// 计算剩余物品都装下时的最大价值
int Bound_sv(int layer, int cv) {

    int i = layer;
    int sv = cv;

    for (i; i &lt; set_number; i++) {
        sv += goods[i].value;		// 剩余物品都装下时的最大价值
    }

    return sv;

}

// 计算期望最大价值
double Bound(int layer,int cv,int cw){
    int i = layer;

    double sv = double(cv);
    int cr = capacity - cw;

    while (i&lt;set_number &amp;&amp; goods[i].weight &lt;= cr)
    {
        cr -= goods[i].weight;
        sv = sv + goods[i].value;
        i++;
    }

    if (i &lt; set_number)
        sv = sv + goods[i].ave_value * cr;

    return sv;
}


// Using back track method to get max value
void BackTrack(int layer, int current_value, int current_weight) {
    // layer代表回溯层数，其余参数分别代表当前价值以及当前重量
    //double expect_sumValue = 0;		// 记录期望价值总和

    if (layer == set_number) {		// if layer bigger than number, over
        // 注意这个地方，不用大于 ！！！

        if (current_value &gt; maxValue) {

            maxValue = current_value;

            for (int i = 0; i &lt; set_number; i++) {
                max_set[i] = current_set[i];

            }
        }
    }
    else
    {
        for (int j = 0; j &lt;= 1; j++) {

            current_set[layer] = j;

            /************************剪枝**************************/


            if (
                current_weight + current_set[layer] * goods[layer].weight &lt;= capacity
                &amp;&amp; Bound_sv(layer,current_value) &gt;= maxValue &amp;&amp; Bound(layer,current_value,current_weight) &gt; maxValue
            )
            {
                // 更新当前背包物品的总重量，目前背包物品的总价值
                current_weight += (goods[layer].weight * current_set[layer]);
                current_value += (goods[layer].value * current_set[layer]);

                // 继续进行子树的递归
                BackTrack(layer + 1, current_value, current_weight);

                // 递归出来后回滚数据
                current_weight -= (goods[layer].weight * current_set[layer]);
                current_value -= (goods[layer].value * current_set[layer]);

            }
        }
    }

}


</code></pre>
</li>
</ul>
<h2 id="分支限界法">分支限界法</h2>
<ul>
<li>
<p>思想</p>
<p><strong>广度优先策略</strong>搜索解空间树，对待处理的根节点根据<strong>限界函数</strong>估算目标函数的可能取值，选择目标函数<strong>极大或者极小</strong>的结点<strong>优先进行广度搜索</strong>，不断<strong>调整搜索方向</strong>，尽可能早的找到最优解。</p>
</li>
<li>
<p>时间复杂度</p>
<p>本质还是<strong>蛮力法</strong>，最坏情况下时间复杂度还是指数阶</p>
</li>
<li>
<p>代码</p>
</li>
</ul>
<pre><code class="language-c++">// 伪代码如下
输入：n个物品的重量w[n]，价值v[n]，背包容量W
输出：背包获得的最大价值和装入背包的物品
1. 根据界限函数计算目标函数的上界up，使用贪心法计算目标函数的下界down
2. 计算根节点的目标函数值并且加入PT表
3. 循环直到某个叶子节点的目标函数值在表PT中去取极大值
	3.1 i=PT表中具有最大值的结点
	3.2 对结点i的每个孩子结点x执行下述操作：
		3.2.1 如果孩子x结点不满足约束条件，则丢弃该节点
		3.2.2 否则，估算结点x的目标函数的取值lb，将其加入表PT中
4. 将叶子节点对应的最优解输出，回溯得到最优解的各个分量

int tree_node_id = 1;		// 解空间树结点id 1开始

int lower_bound = 0;		// 目标函数的下界

// 贪心法求背包容量的下界
int greed() {

    int temp[MAX] = { 0 };		// 定义临时数组，用来表示货物向量，并初始化为0
    int cap = capacity;			// 暂存背包容量
    int w = 0;					// 当前背包容量
    int updown = 0;				// 下界

    // 对背包物品按照单位价值进行排序
    sort_set();

    // 求解
    for (int i = 0; i &lt; set_number; i++) {

        // 如果超重，跳出
        if ((w+goods[i].weight) &gt; cap) {
            continue;
        }

        temp[i] = 1;
        w += goods[i].weight;
        updown += (temp[i] * goods[i].value);
    }

    cout &lt;&lt; &quot;解的下界是：&quot; &lt;&lt; updown &lt;&lt; endl;

    return updown;

}


// 限界函数求上界
void limit(ND &amp;n)				        //计算分枝结点的上界
{
    // 下一个要选的物品就是第layer层物品
    int w = n.current_weight;
    double v = n.current_value;
    int i = n.layer;

    while (i &lt; set_number &amp;&amp; w + goods[i].weight &lt;= capacity) {
        w += goods[i].weight;
        v += goods[i].value;
        i++;
    }

    if (i &lt; set_number) {  // 装部分物品
        n.ub = v + (capacity - w)*goods[i].ave_value;
    }
    else
    {
        n.ub = v;
    }
}

// 优先队列进队操作
void EnQueue(ND n, priority_queue&lt;ND&gt; &amp;q) {
    if (n.layer == set_number) {		// 已经到达叶子结点

        if (n.current_value &gt; maxValue) {		// 更新maxValue
            maxValue = n.current_value;
            for (int i = 0; i &lt; set_number; i++) {
                max_set[i] = n.cset[i];
            }
        }
    }
    else {
        q.push(n);			// 非叶子结点进队
    }
}

// 分支限界法
void branchAndbound() {

    // 首先使用贪心法求解此goods集合的目标值下界
    lower_bound = greed();

    priority_queue&lt;ND&gt; q;		// 优先队列
    ND n0, n1, n2;				// 先定义根结点，左孩子结点，右孩子结点

    /*初始化根节点*/
    n0.id = tree_node_id++;		
    n0.layer = 0;
    n0.current_value = 0;
    n0.current_weight = 0;
    for (int i = 0; i &lt; set_number; i++) {
        n0.cset[i] = 0;
    }
    limit(n0);					// 求根结点上界
    q.push(n0);					// 根结点进队

    while (!q.empty())			// 队不空循环
    {
        n0 = q.top();				// 取队头
        q.pop();				// 出队
        if (n0.current_weight + goods[n0.layer].weight &lt;= capacity &amp;&amp; n0.ub &gt;= lower_bound) {	// 超重剪枝 小于最小期望重量剪枝

            // 设置左孩子结点
            n1.id = tree_node_id++;
            n1.layer = n0.layer + 1;
            n1.current_weight = n0.current_weight + goods[n0.layer].weight;
            n1.current_value = n0.current_value + goods[n0.layer].value;
            /*复制解向量*/
            for (int i = 0; i &lt; set_number; i++) {
                n1.cset[i] = n0.cset[i];
            }
            n1.cset[n1.layer-1] = 1;			// 更新解向量
            limit(n1);						// 求限界函数上界
            EnQueue(n1, q);					// 左孩子进队
        }

        // 设置右孩子结点
        n2.id = tree_node_id++;
        n2.layer = n0.layer + 1;
        n2.current_value = n0.current_value;
        n2.current_weight = n0.current_weight;

        // 复制解向量
        for (int i = 0; i &lt; set_number; i++) {
            n2.cset[i] = n0.cset[i];
        }


        n2.cset[n2.layer-1] = 0;		 // 更新解向量
        limit(n2);					// 求界限函数上界

        if (n2.ub &gt; maxValue &amp;&amp; n2.ub &gt;= lower_bound) {		// 剪枝，期望最大值小于已有最大值就剪枝  小于最小期望重量剪枝
            EnQueue(n2, q);
        }

    }
}

</code></pre>
<h2 id="动态规划">动态规划</h2>
<ul>
<li>
<p>思想</p>
<p>处理<strong>多阶段决策最优化问题</strong>，多阶段决策过程满足<strong>最优性原理</strong></p>
<p>1）划分子问题</p>
<p>2）确定动态规划函数</p>
<p>3）填表</p>
</li>
</ul>
<h2 id="贪心法">贪心法</h2>
<p><strong>对于0/1背包来说，贪心法在一些时候是无法求得最优解的，所以不要万不得已还是不要选择贪心法了</strong></p>
<pre><code class="language-c++">/*
分别用、蛮力法、回溯法和分支限界法 实现0/1背包问题的求解
*/
// 蛮力法求解0/1背包

#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;sys/timeb.h&gt;
#include &lt;math.h&gt;
using namespace std;

#define MAX 100000

// Good is the struct of good which has three elememt
typedef struct Good
{
	int value = 0;
	int weight = 0;
	double ave_value = 0;
}GD;


// 定义按照单位重量降序排序的规则
struct sort_rule {
	bool operator()(const GD &amp;good1, const GD &amp;good2) {
		return good1.ave_value &gt; good2.ave_value;
	}
};

// 定义用于分支限界法的树结点结构体
/*
typedef struct Node {

	int current_weight = 0;				// 到达此结点时背包所有物品的总重量
	int current_value = 0;				// 到达此结点时背包所有物品的总价值
	
	double result_of_Obj_func = 0;		// 此结点的目标函数的值

	// bool biggest = true;				// 是否是此时的最大结点

}ND;
*/
typedef struct Node { // 分支限界法树结点
	int id;								// 结点编号
	int layer;							// 当前结点所在树的层数
	int current_weight = 0;				// 当前结点的总重量
	int current_value = 0;				// 当前结点的总价值
	double ub = 0;						// 当前结点的限界函数值

	int cset[MAX] = { 0 };				// 当前背包的解向量

	bool operator&lt;(const Node&amp; nd) const {		// 定义优先队列出队规则，限界函数值越大越先出队
		return ub &lt; nd.ub;
	}
}ND;

// 公用 -&gt; 获取时间函数
long long getSystemTime() {
	timeb t;
	ftime(&amp;t);
	return t.time * 1000 + t.millitm;
}


class Bag {		// 基类，用作蛮力法

	protected:
		int set_number;					// 集合元素个数
		int capacity;					// 背包容量
		int maxValue = -1;					// 最大重量

		// 定义时间变量
		long long t1;
		long long t2;
		long long sum_time = 0;

		GD goods[MAX];
		int max_set[MAX] = { 0 };		// max_set为标志数组
		int current_set[MAX] = { 0 };	// define current_set to save current set


		// 初始化重量集合
		void set_weights(int N) {
			
			int sum_w = 0;
			for (int i = 0; i &lt; N; i++) {
				goods[i].weight = (rand() % 10) + 1;
				sum_w += goods[i].weight;
			}
			capacity = sum_w / 2;
		
		}

		// 初始化价值集合
		void set_values(int N) {
			
			for (int i = 0; i &lt; N; i++) {
				//values[i] = (rand() % 5 + 1) * 10 + ((rand() % 10) + 1);		// 产生10-60之间的数值
				goods[i].value = (rand() % 5 + 1) * 10 + ((rand() % 11));
			}
			
		}

		// 初始化集合
		void initialize_set(int N) {
			set_weights(N);
			set_values(N);
		}

		// 打印重量和价值
		void print_wv(int N) {
			cout &lt;&lt; &quot;物品重量集合为：{ &quot;;
			for (int i = 0; i &lt; N; i++) {
				//cout &lt;&lt; weights[i] &lt;&lt; &quot; &quot;;
				cout &lt;&lt; goods[i].weight &lt;&lt; &quot; &quot;;
			}
			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl &lt;&lt; &quot;物品价值集合为：{ &quot;;
			for (int i = 0; i &lt; N; i++) {
				//cout &lt;&lt; values[i] &lt;&lt; &quot; &quot;;
				cout &lt;&lt; goods[i].value &lt;&lt; &quot; &quot;;
			}
			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
			cout &lt;&lt; &quot;背包容量为：&quot; &lt;&lt; capacity &lt;&lt; endl;
		}


		void print_set() {		// 打印集合
	// 输出最大重量以及对应的元素序号
	// 如果输出 0 / 1 表示的子集情况例如 {0 1 0 1 1 0 0} 就修改本函数
			cout &lt;&lt; &quot;背包能装的最大价值为：&quot; &lt;&lt; maxValue &lt;&lt; endl;
			cout &lt;&lt; &quot;包含的物品有：{ &quot;;
			for (int i = 0; i &lt; set_number; i++) {
				// 输出序号 or 向量
				if (max_set[i])
				{
					cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;;
				}
			}
			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
		}

		void brute_force(int layer, int current_value, int current_weight) {
			// layer代表回溯层数，其余参数分别代表当前价值以及当前重量

			if (layer == set_number) {		// if layer bigger than number, over
				// 注意这个地方，不用大于 ！！！

				if (current_value &gt; maxValue &amp;&amp; current_weight &lt;= capacity) {

					maxValue = current_value;

					for (int i = 0; i &lt; set_number; i++) {
						max_set[i] = current_set[i];

					}
				}
			}
			else
			{
				for (int j = 1; j &gt;= 0; j--) {

					current_set[layer] = j;

					current_weight += (goods[layer].weight * current_set[layer]);
					current_value += (goods[layer].value * current_set[layer]);

					// 继续进行子树的递归
					brute_force(layer + 1, current_value, current_weight);

					// 递归出来后回滚数据
					current_weight -= (goods[layer].weight * current_set[layer]);
					current_value -= (goods[layer].value * current_set[layer]);

				}
			}

		}



	public:

		Bag(int N) {
			maxValue = 0;			// 最大价值初始化为0
			set_number = N;			// 初始化元素个数
			initialize_set(N);		// 初始化集合
			print_wv(N);			// 打印信息
		}

		

		// 求解最大价值
		void get_maxValue(int layer, int cv, int cw) {

			// 蛮力法求解
			t1 = getSystemTime();		// 开始计时
			brute_force(layer, cv, cw);
			t2 = getSystemTime();		// 结束计时

			//打印时间
			sum_time = t2 - t1;
			cout &lt;&lt; &quot;蛮力法求解规模为 &quot; &lt;&lt; set_number &lt;&lt; &quot; 的0/1背包所需要的时间为：&quot; &lt;&lt; sum_time &lt;&lt; &quot;ms.&quot; &lt;&lt; endl;

			// 打印结果
			print_set();

		}

		// 根据货物单位价值进行排序
		void sort_set() {		// 计算权值

			for (int i = 0; i &lt; set_number; i++) {
				goods[i].ave_value = double(goods[i].value) / double(goods[i].weight);
			}

			// 根据权值排序
			sort(goods, goods + sizeof(goods) / sizeof(GD), sort_rule());

			// 打印根据权值排序后的内容
			cout &lt;&lt; &quot;根据单位价值排序后的物品重量以及对应的价值为：&quot; &lt;&lt; endl &lt;&lt; &quot;weight -&gt; { &quot;;

			for (int i = 0; i &lt; set_number; i++) {
				cout &lt;&lt; goods[i].weight &lt;&lt; &quot; &quot;;
			}

			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl &lt;&lt; &quot;value -&gt; { &quot;;

			for (int i = 0; i &lt; set_number; i++)
			{
				cout &lt;&lt; goods[i].value &lt;&lt; &quot; &quot;;
			}

			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
		}
};				// 蛮力法，作为基类

class Bag_with_backtrack : public Bag {		// 继承 Bag 的保护以及公用成员
	
	protected:
		int current_set[MAX] = { 0 };		// define current_set to save current set


		int Bound_sv(int layer, int cv) {

			int i = layer;
			int sv = cv;

			for (i; i &lt; set_number; i++) {
				sv += goods[i].value;		// 剩余物品都装下时的最大价值
			}

			return sv;

		}
		
		double Bound(int layer,int cv,int cw){
			int i = layer;
			
			double sv = double(cv);
			int cr = capacity - cw;

			while (i&lt;set_number &amp;&amp; goods[i].weight &lt;= cr)
			{
				cr -= goods[i].weight;
				sv = sv + goods[i].value;
				i++;
			}

			if (i &lt; set_number)
				sv = sv + goods[i].ave_value * cr;

			return sv;
		}
		

		// Using back track method to get max value
		void BackTrack(int layer, int current_value, int current_weight) {
			// layer代表回溯层数，其余参数分别代表当前价值以及当前重量
			//double expect_sumValue = 0;		// 记录期望价值总和

			if (layer == set_number) {		// if layer bigger than number, over
				// 注意这个地方，不用大于 ！！！

				if (current_value &gt; maxValue) {

					maxValue = current_value;

					for (int i = 0; i &lt; set_number; i++) {
						max_set[i] = current_set[i];

					}
				}
			}
			else
			{
				for (int j = 0; j &lt;= 1; j++) {

					current_set[layer] = j;

					/************************剪枝**************************/
					

					if (
						current_weight + current_set[layer] * goods[layer].weight &lt;= capacity
						&amp;&amp; Bound_sv(layer,current_value) &gt;= maxValue &amp;&amp; Bound(layer,current_value,current_weight) &gt; maxValue
						)
					{
						// 更新当前背包物品的总重量，目前背包物品的总价值
						current_weight += (goods[layer].weight * current_set[layer]);
						current_value += (goods[layer].value * current_set[layer]);

						// 继续进行子树的递归
						BackTrack(layer + 1, current_value, current_weight);

						// 递归出来后回滚数据
						current_weight -= (goods[layer].weight * current_set[layer]);
						current_value -= (goods[layer].value * current_set[layer]);

					}
				}
			}

		}


	public:

		Bag_with_backtrack(int N) :Bag(N) {
			cout &lt;&lt; &quot;回溯法对象实例化...&quot; &lt;&lt; endl;
		}


		void get_maxValue_by_backTrack(int layer, int current_value, int current_weight) {

			// 按照单位价值进行排序
			t1 = getSystemTime(); // 开始计时
			sort_set();

			// 使用回溯法进行求解
			BackTrack(layer, current_value, current_weight);
			t2 = getSystemTime();	// 结束计时
			
			// 打印时间
			sum_time = t2 - t1;
			cout &lt;&lt; &quot;回溯法求解规模为 &quot; &lt;&lt; set_number &lt;&lt; &quot; 的0/1背包问题所需要的时间为：&quot; &lt;&lt; sum_time &lt;&lt; &quot;ms.&quot; &lt;&lt; endl;

			// 打印集合
			print_set();
		}

		
};		// 回溯法，继承基类Bag


class Bag_with_branchAndbound :public Bag {		// 从 Bag 类中派生

	protected:
		
		int tree_node_id = 1;		// 解空间树结点id 1开始
		
		int lower_bound = 0;		// 目标函数的下界

		// 贪心法求背包容量的下界
		int greed() {

			int temp[MAX] = { 0 };		// 定义临时数组，用来表示货物向量，并初始化为0
			int cap = capacity;			// 暂存背包容量
			int w = 0;					// 当前背包容量
			int updown = 0;				// 下界
			
			// 对背包物品按照单位价值进行排序
			sort_set();

			// 求解
			for (int i = 0; i &lt; set_number; i++) {

				// 如果超重，跳出
				if ((w+goods[i].weight) &gt; cap) {
					continue;
				}

				temp[i] = 1;
				w += goods[i].weight;
				updown += (temp[i] * goods[i].value);
			}

			cout &lt;&lt; &quot;解的下界是：&quot; &lt;&lt; updown &lt;&lt; endl;

			return updown;

		}


		// 限界函数求上界
		void limit(ND &amp;n)				        //计算分枝结点的上界
		{
			// 下一个要选的物品就是第layer层物品
			int w = n.current_weight;
			double v = n.current_value;
			int i = n.layer;

			while (i &lt; set_number &amp;&amp; w + goods[i].weight &lt;= capacity) {
				w += goods[i].weight;
				v += goods[i].value;
				i++;
			}

			if (i &lt; set_number) {  // 装部分物品
				n.ub = v + (capacity - w)*goods[i].ave_value;
			}
			else
			{
				n.ub = v;
			}
		}

		// 优先队列进队操作
		void EnQueue(ND n, priority_queue&lt;ND&gt; &amp;q) {
			if (n.layer == set_number) {		// 已经到达叶子结点

				if (n.current_value &gt; maxValue) {		// 更新maxValue
					maxValue = n.current_value;
					for (int i = 0; i &lt; set_number; i++) {
						max_set[i] = n.cset[i];
					}
				}
			}
			else {
				q.push(n);			// 非叶子结点进队
			}
		}

		// 分支限界法
		void branchAndbound() {

			// 首先使用贪心法求解此goods集合的目标值下界
			lower_bound = greed();

			priority_queue&lt;ND&gt; q;		// 优先队列
			ND n0, n1, n2;				// 先定义根结点，左孩子结点，右孩子结点

			/*初始化根节点*/
			n0.id = tree_node_id++;		
			n0.layer = 0;
			n0.current_value = 0;
			n0.current_weight = 0;
			for (int i = 0; i &lt; set_number; i++) {
				n0.cset[i] = 0;
			}
			limit(n0);					// 求根结点上界
			q.push(n0);					// 根结点进队

			while (!q.empty())			// 队不空循环
			{
				n0 = q.top();				// 取队头
				q.pop();				// 出队
				if (n0.current_weight + goods[n0.layer].weight &lt;= capacity &amp;&amp; n0.ub &gt;= lower_bound) {	// 超重剪枝 小于最小期望重量剪枝

					// 设置左孩子结点
					n1.id = tree_node_id++;
					n1.layer = n0.layer + 1;
					n1.current_weight = n0.current_weight + goods[n0.layer].weight;
					n1.current_value = n0.current_value + goods[n0.layer].value;
					/*复制解向量*/
					for (int i = 0; i &lt; set_number; i++) {
						n1.cset[i] = n0.cset[i];
					}
					n1.cset[n1.layer-1] = 1;			// 更新解向量
					limit(n1);						// 求限界函数上界
					EnQueue(n1, q);					// 左孩子进队
				}

				// 设置右孩子结点
				n2.id = tree_node_id++;
				n2.layer = n0.layer + 1;
				n2.current_value = n0.current_value;
				n2.current_weight = n0.current_weight;

				// 复制解向量
				for (int i = 0; i &lt; set_number; i++) {
					n2.cset[i] = n0.cset[i];
				}

				
				n2.cset[n2.layer-1] = 0;		 // 更新解向量
				limit(n2);					// 求界限函数上界
				
				if (n2.ub &gt; maxValue &amp;&amp; n2.ub &gt;= lower_bound) {		// 剪枝，期望最大值小于已有最大值就剪枝  小于最小期望重量剪枝
					EnQueue(n2, q);
				}

			}
		}


	public:

		Bag_with_branchAndbound(int N) :Bag(N) {

			cout &lt;&lt; &quot;分支限界法对象实例化...&quot; &lt;&lt; endl;
		
		}

		void get_maxValue_by_branchAndbound() {
			
			// 分支限界法
			t1 = getSystemTime();		// 开始计时
			branchAndbound();
			t2 = getSystemTime();		// 结束计时

			// 计算并打印时间
			sum_time = t2 - t1;
			cout &lt;&lt; &quot;使用分支限界法求解问题规模为&quot; &lt;&lt; set_number &lt;&lt; &quot; 的0/1背包问题所需要的时间为：&quot; &lt;&lt; sum_time &lt;&lt; &quot;ms.&quot; &lt;&lt; endl;
			
			// 打印集合
			print_set();
		}
		

};		// 


int main() {

	srand((unsigned)time(NULL));
	
	/*************蛮力法************/
	//for (int i = 0; i &lt; 40; i++) {
	//	Bag bag = Bag(i);
	//	bag.get_maxValue(0, 0, 0);
	//}
	
	
	/************回溯法*************/
	//int n = 1;
	//for (int i = 512; i &lt; 2000; i+=100) {
	//	n *= 2;
	//Bag_with_backtrack bag = Bag_with_backtrack(4);
	//bag.get_maxValue_by_backTrack(0, 0, 0);
	//}
	
	

	/************分支限界法*************/
	//Bag_with_branchAndbound bag = Bag_with_branchAndbound(5);
	//bag.get_maxValue_by_branchAndbound();

	//for (int n = 1; n &lt;= 5000; n*=2) {
		Bag_with_branchAndbound bag = Bag_with_branchAndbound(4);
		bag.get_maxValue_by_branchAndbound();
	//}
	

	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《热风》节选]]></title>
        <id>https://lizonglin313.github.io/post/《热风》节选</id>
        <link href="https://lizonglin313.github.io/post/《热风》节选">
        </link>
        <updated>2019-10-11T14:40:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能<br>
做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点<br>
光，不必等候炬火。<br>
　　此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的<br>
消失，不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在<br>
内。<br>
　　我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。<br>
　　尼采说：<br>
　　<br>
　　“真的，人是一个浊流。应该是海了，能容这浊流使他干净。<br>
　　“咄，我教你们超人：这便是海，在他这里，能容下你们的大侮蔑。”（《札拉图<br>
如是说》的《序言》第三节）</p>
<p>纵令不过一洼浅水，也可以学学大海；横竖都是水，可以相通。几粒石子，任他们暗地<br>
里掷来；几滴秽水，任他们从背后泼来就是了。<br>
　　这还算不到“大侮蔑”——因为大侮蔑也须有胆力。<br>
　　																		                                                   ----    鲁迅《热风》</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Google Bigtable论文要点整理]]></title>
        <id>https://lizonglin313.github.io/post/Google-Bigtable论文要点整理</id>
        <link href="https://lizonglin313.github.io/post/Google-Bigtable论文要点整理">
        </link>
        <updated>2019-10-07T06:53:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="google-bigtable">Google Bigtable</h1>
<blockquote>
<p>Google Bigtable论文要点整理</p>
</blockquote>
<h2 id="摘要">摘要</h2>
<h3 id="本质及用途">本质及用途</h3>
<ul>
<li>分布式的结构化数据存储系统</li>
<li>被设计用来处理海量数据（通常是分布在数千台普通服务器上的 PB 级的数据）</li>
</ul>
<h3 id="应用">应用</h3>
<ul>
<li>Web索引</li>
<li>Google Earth</li>
<li>Google Finanace</li>
</ul>
<h3 id="本文所做的">本文所做的</h3>
<p>本论文描述了 Bigtable 提供的简单的数据模型。利用这个模型，用户可以动态的控制数据的分布和格式。<br>
我们还将描述 Bigtable 的设计和实现。</p>
<h2 id="介绍">介绍</h2>
<h3 id="bigtable的目标">Bigtable的目标</h3>
<ul>
<li>适用性广泛</li>
<li>可扩展</li>
<li>高性能</li>
<li>高可用性</li>
</ul>
<h3 id="与传统数据库的异同">与传统数据库的异同</h3>
<p>相同点：</p>
<ul>
<li>使用很多数据库的实现策略</li>
</ul>
<p>不同点：</p>
<ul>
<li>Bigtable 不支持完整的关系数据模型</li>
<li>Bigtable 为客户提供了简单的数据模型，利用这个模型，客户可以动态控制数据的分布和格式，用户也可以自己推测底层存储数据的位置相关性</li>
</ul>
<h3 id="数据">数据</h3>
<ul>
<li>数据的下标是行和列的名字</li>
<li>名字可以是任意字符串</li>
<li>存储的数据均视为字符串</li>
<li>Bigtable本身不会去解析</li>
<li>客户存入结构化或半结构化数据，通过选择数据模式，用户可以控制数据位置的相关性</li>
<li>通过参数调节存放位置：内存 | 硬盘</li>
</ul>
<h2 id="数据模型">数据模型</h2>
<p>Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序 Map。Map 的索引是行关键字、列关键字<br>
以及时间戳；Map 中的每个 value 都是一个未经解析的 byte 数组。</p>
<pre><code class="language-cpp"> (row:string, column:string,time:int64)-&gt;string
</code></pre>
<p>Webtable</p>
<ul>
<li>行关键字：URL</li>
<li>列名：网页的某些属性</li>
<li>contents列：存储网页的某些属性</li>
<li>标识：网页的时间戳</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/10/07/R1ZUGxPod82NriE.png" alt="" loading="lazy"></figure>
<center/>图1 一个存储Web网页的例子的表的片段
<ul>
<li>行名：反向URL</li>
<li>contents列族：网页的内容</li>
<li>anchor列族：引用该网页的锚链接文本</li>
</ul>
<h3 id="行">行</h3>
<p>行关键字：</p>
<ul>
<li>任意字符串（最大支持64KB）</li>
<li>同一行关键字读写操作都为原子操作</li>
</ul>
<p>Tablet</p>
<ul>
<li>Bigtable通过行关键字字典顺序组织数据</li>
<li>表中每行可以动态分区，每个分区叫Tablet，是数据分布和负载均衡调整的最小单位</li>
</ul>
<h3 id="列族">列族</h3>
<ul>
<li>列关键字组成的集合叫做“列族“，是访问控制的基本单位</li>
<li>同一列族下的所有数据通常都属于同一个类型</li>
<li>列族在使用之前必须先创建，然后才能在列族中任何的列关键字下存放数据</li>
<li>创建后，其中的任何一个列关键字下都可以存放数据</li>
<li>一张表中列族不能太多（最多几百个）</li>
<li>但是一张表中可以有无限多个列</li>
</ul>
<h4 id="列关键字命名">列关键字命名</h4>
<p>语法：</p>
<pre><code>列族：限定词
</code></pre>
<p>列组名字：可打印字符串</p>
<p>限定词：任意的字符串</p>
<blockquote>
<p>比如，Webtable 有个列族 language，language 列族用来存放撰写网页的语言。我们在 language列族中只使用一个列关键字，用来存放每个网页的语言标识 ID。Webtable 中另一个有用的列族是 anchor；这个列族的每一个列关键字代表一个锚链接，如图一所示。Anchor 列族的限定词是引用该网页的站点名；Anchor列族每列的数据项存放的是链接文本。</p>
</blockquote>
<h4 id="控制权限">控制权限</h4>
<ul>
<li>访问控制、磁盘和内存的使用统计都是在列族层面进行</li>
</ul>
<p>在我们的 Webtable 的例子中，上述的控制权限能帮助我们管理不同类型的应用：</p>
<ul>
<li>允许一些应用可以添加新的基本数据</li>
<li>一些应用可以读取基本数据并创建继承的列族</li>
<li>一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）</li>
</ul>
<h3 id="时间戳">时间戳</h3>
<p>在 Bigtable 中，表的每一个数据项都可以包含同一份数据的不同版本；不同版本的数据通过<strong>时间戳</strong>来索引。</p>
<p>时间戳：</p>
<ul>
<li>64位整型</li>
<li>Bigtable可以给时间戳赋值，精确到ms</li>
<li>用户可以给时间戳赋值</li>
<li>不同版本数据按照时间戳倒序排序，最新的数据在最前面</li>
</ul>
<p>垃圾回收：</p>
<p>为了减轻多个版本数据的管理负担，我们对每一个列族配有两个设置参数，Bigtable 通过这两个参数可以对废弃版本的数据自动进行垃圾收集。用户可以指定只保存最后 n 个版本的数据，或者只保存“足够新”的版本的数据（比如，只保存最近 7 天的内容写入的数据）。 、</p>
<h2 id="api">API</h2>
<h3 id="bigtable提供的api">Bigtable提供的API</h3>
<ul>
<li>建立和删除表以及列族的API函数</li>
<li>修改集群、表和列族的元数据的API</li>
</ul>
<p>例如修改访问权限：</p>
<pre><code class="language-c++"> // Open the table 
Table *T = OpenOrDie(“/bigtable/web/webtable”); 
// Write a new anchor and delete an old anchor 
RowMutation r1(T, “com.cnn.www”); 
r1.Set(“anchor:www.c-span.org”, “CNN”); 
r1.Delete(“anchor:www.abc.com”); 
Operation op; 
Apply(&amp;op, &amp;r1);

/*
 *客户程序可以对 Bigtable 进行如下的操作：写入或者删除 Bigtable 中的值、从每个行中查找值、或者遍历表中 
 *的一个数据子集。图 2 中的Ｃ++代码使用 RowMutation 抽象对象进行了一系列的更新操作。（为了保持示例代码的 
 *简洁，我们忽略了一些细节相关代码）。调用 Apply 函数对Ｗebtable 进行了一个原子修改操作：它为
 *www.cnn.com 增加了一个锚点，同时删除了另外一个锚点。
 */
</code></pre>
<pre><code class="language-cpp">Scanner scanner(T); 
ScanStream *stream; 
stream = scanner.FetchColumnFamily(“anchor”); 
stream-&gt;SetReturnAllVersions(); 
scanner.Lookup(“com.cnn.www”); 
for (; !stream-&gt;Done(); stream-&gt;Next()) { 
    printf(“%s %s %lld %s\n”, 
    scanner.RowName(), 
    stream-&gt;ColumnName(), 
    stream-&gt;MicroTimestamp(), 
    stream-&gt;Value()); 
} 

/*
 *C++代码使用 Scanner 抽象对象遍历一个行内的所有锚点。客户程序可以遍历多个列族，有几种方法可以对扫描输出 
 *的行、列和时间戳进行限制。例如，我们可以限制上面的扫描，让它只输出那些匹配正则表达式*.cnn.com 的锚点，
 *或者那些时间戳在当前时间前 10 天的锚点
*/
</code></pre>
<h3 id="支持的其他特性">支持的其他特性</h3>
<ol>
<li>Bigtable 支持单行上的事务处理：利用这个功能，用户可以对存储在一个行关键字下的数据进行原子性的读-更新-写操作</li>
<li>Bigtable 允许把数据项用做整数计数器</li>
<li>Bigtable 允许用户在服务器的地址空间内执行脚本程序</li>
</ol>
<p>Bigtable 可以和 MapReduce 一起使用，MapReduce 是 Google 开发的大规模并行计算框架。我们已经开发了一些 Wrapper 类，通过使用这些 Wrapper 类，Bigtable 可以作为 MapReduce 框架的输入和输出。</p>
<h2 id="bigtable构建">BigTable构建</h2>
<h3 id="gfs">GFS</h3>
<ul>
<li>BigTable 使用 Google 的分布式文件系统(GFS)存储日志文件和数据文件</li>
</ul>
<h3 id="集群">集群</h3>
<ul>
<li>BigTable 集群通常运行在一个共享的机器池中，池中的机器还会运行其它的各种各样的分布式应用程序，BigTable 的进程经常要和其它应用的进程共享机器</li>
<li>BigTable 依赖集群管理系统来调度任务、管理共享的机器上的资源、处理机器的故障、以及监视机器的状态</li>
</ul>
<h3 id="google-sstable">Google SSTable</h3>
<ul>
<li>BigTable 内部存储数据的文件是 Google SSTable 格式的</li>
</ul>
<blockquote>
<p>SSTable 是一个持久化的、排序的、不可更改的Map 结构，而 Map 是一个 key-value 映射的数据结构，key 和 value 的值都是任意的 Byte 串。可以对 SSTable进行如下的操作：查询与一个 key 值相关的 value，或者遍历某个 key 值范围内的所有的 key-value 对。从内部看，SSTable 是一系列的数据块（通常每个块的大小是 64KB，这个大小是可以配置的）。SSTable 使用块索引（通常存储在 SSTable 的最后）来定位数据块；在打开 SSTable 的时候，索引被加载到内存。每次查找都可以通过一次磁盘搜索完成：首先使用二分查找法在内存中的索引里找到数据块的位置，然后再从硬盘读取相应的数据块。也可以选择把整个 SSTable 都放在内存中，这样就不必访问硬盘了。</p>
</blockquote>
<h3 id="chubby">Chubby</h3>
<ul>
<li>BigTable 还依赖一个高可用的、序列化的分布式锁服务组件，叫做 Chubby</li>
</ul>
<blockquote>
<p>一个 Chubby 服务包括了 5 个活动的副本，其中的一个副本被选为 Master，并且处理请求。只有在大多数副本都是正常运行的，并且彼此之间能够互相通信的情况下，Chubby 服务才是可用的。当有副本失效的时候，Chubby 使用 Paxos 算法来保证副本的一致性。Chubby 提供了一个名字空间，里面包括了目录和小文件。每个目录或者文件可以当成一个锁，读写文件的操作都是原子的。Chubby 客户程序库提供对 Chubby 文件的一致性缓存。每个<br>
Chubby 客户程序都维护一个与 Chubby 服务的会话。如果客户程序不能在租约到期的时间内重新签订会话的租约，这个会话就过期失效了9。当一个会话失效时，它拥有的锁和打开的文件句柄都失效了。Chubby 客户程序可以在文件和目录上注册回调函数，当文件或目录改变、或者会话过期时，回调函数会通知客户程序。</p>
</blockquote>
<p>Bigtable 使用 Chubby 完成以下的几个任务：</p>
<ol>
<li>确保在任何给定的时间内最多只有一个活动的 Master 副本；</li>
<li>存储 BigTable 数据的自引导指令的位置（参考 5.1 节）；</li>
<li>查找 Tablet 服务器，以及在 Tablet 服务器失效时进行善后（5.2 节）；</li>
<li>存储 BigTable 的模式信息（每张表的列族信息）；</li>
<li>以及存储访问控制列表。</li>
</ol>
<p>如果Chubby长时间无法访问，BigTable就会失效。</p>
<h2 id="介绍-2">介绍</h2>
<p>Bigtable包括了主要的三个组件：</p>
<ol>
<li>链接到客户程序中的库</li>
<li>一个Master服务器</li>
<li>多个Tablet服务器</li>
</ol>
<p>根据系统工作负载的变化，BigTable动态的向集群中添加（或删除）Tablet服务器。</p>
<h4 id="master服务器">Master服务器</h4>
<p>Master服务器主要负责以下工作：</p>
<ol>
<li>为 Tablet 服务器分配 Tablets</li>
<li>检测新加入的或者过期失效的 Table 服务器</li>
<li>对 Tablet 服务器进行负载均衡</li>
<li>对保存在 GFS 上的文件进行垃圾收集</li>
<li>处理对模式的相关修改操作，例如建立表和列族</li>
</ol>
<h4 id="tablet服务器">Tablet服务器</h4>
<p>每个 Tablet 服务器都管理一个 <strong>Tablet 的集合</strong>（通常每个服务器有大约数十个至上千个 Tablet）。每个 Tablet服务器负责处理它所加载的 Tablet 的读写操作，以及在 Tablets 过大时，对其进行分割。</p>
<blockquote>
<p>和很多 Single-Master 类型的分布式存储系统【17.21】类似，客户端读取的数据都不经过 Master 服务器：客户程序直接和 Tablet 服务器通信进行读写操作。由于 BigTable 的客户程序不必通过 Master 服务器来获取<br>
Tablet 的位置信息，因此，大多数客户程序甚至完全不需要和 Master 服务器通信。在实际应用中，Master服务器的负载是很轻的。<br>
一个 BigTable 集群存储了很多表，每个表包含了一个 Tablet 的集合，而每个 Tablet 包含了某个范围内的行的所有相关数据。初始状态下，一个表只有一个 Tablet。随着表中数据的增长，它被自动分割成多个Tablet，缺省情况下，每个 Tablet 的尺寸大约是 100MB 到 200MB。</p>
</blockquote>
<h3 id="tablet的位置">Tablet的位置</h3>
<p>我们使用一个三层的、类似Ｂ+树[10]的结构存储 Tablet 的位置信息。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/10/07/3CMUyWopYFdP8D1.png" alt="" loading="lazy"></figure>
<center/>图2 Tablet location hierarchy
<ol>
<li>第一层是一个存储在 Chubby 中的文件，包含 Root Tablet 的位置信息。</li>
<li>Root Tablet 包含一个特殊的 METADATA 表里所有的 Tablet 的位置信息。</li>
<li>METADATA 表的每个 Tablet 包含了一个用户 Tablet 的集合。</li>
<li>Root Tablet 是 METADATA 表的第一个 Tablet，对它的处理比较特殊 ，Root Tablet 永远不会被分割 ，这就保证了 Tablet 的位置信息存储结构不会超过三层。</li>
<li>METADATA 表中每个 Tablet 的位置信息都存放在一个行关键字下面，而这个行关键字是由 Tablet所在的表的标识符和 Tablet 的最后一行编码而成的。</li>
<li>METADATA 的每一行都存储了大约 1KB 的内存数据。</li>
<li>在一个大小适中的、容量限制为 128MB 的 METADATA Tablet 中，采用这种三层结构的存储模式，可以标识<br>
2^34 个 Tablet 的地址（如果每个 Tablet 存储 128MB 数据，那么一共可以存储 2^61 字节数据）。</li>
</ol>
<blockquote>
<p>客户程序使用的库会缓存 Tablet 的位置信息。如果客户程序没有缓存某个 Tablet 的地址信息，或者发现它缓存的地址信息不正确，客户程序就在树状的存储结构中递归的查询 Tablet 位置信息；如果客户端缓存是的，那么寻址算法需要通过三次网络来回通信寻址，这其中包括了一次 Chubby 读操作；如果客户端缓存的地址信息过期了，那么寻址算法可能需要最多６次网络来回通信才能更新数据，因为只有在缓存中没有查到数据的时候才能发现数据过期。</p>
<p>尽管 Tablet 的地址信息是存放在内存里的，对它的操作不必访问 GFS 文件系统，但是，通常我们会通过预取 Tablet 地址来进一步的减少访问的开销：每次需要从 METADATA 表中读取一个 Tablet 的元数据的时候，它都会多读取几个 Tablet 的元数据。</p>
<p>在 METADATA 表中还存储了次级信息，包括每个 Tablet 的事件日志（例如，什么时候一个服务器开始为该 Tablet 提供服务）。这些信息有助于排查错误和性能分析。</p>
</blockquote>
<h3 id="tablet分配">Tablet分配</h3>
<ul>
<li><strong>在任何一个时刻，一个Tablet只能分配给一个Tablet服务器。</strong></li>
</ul>
<p>Master服务器记录了：</p>
<ol>
<li>当前有哪些活跃的Tablet服务器</li>
<li>哪些 Tablet 分配给了哪些 Tablet 服务器</li>
<li>哪些 Tablet 还没有被分配</li>
</ol>
<p>当一个 Tablet 还没有被分配、并且刚好有一个 Tablet 服务器有足够的空闲空间装载该 Tablet 时，Master 服务器会给这个 Tablet 服务器发送一个装载请求，把 Tablet 分配给这个服务器。</p>
<ul>
<li><strong>BigTable 使用 Chubby 跟踪记录 Tablet 服务器的状态。</strong></li>
</ul>
<ol>
<li>当一个 Tablet 服务器启动，它在 Chubby 的一个指定目录下建立一个有唯一性名字的文件，获取该文件的独占锁</li>
<li>Master 服务器实时监控着这个目录（服务器目录），因此 Master 服务器能够知道有新的 Tablet 服务器加入了</li>
<li>如果 Tablet 服务器丢失了 Chubby 上的独占锁，比如由于网络断开导致 Tablet 服务器和 Chubby 的会话丢失，它就停止对 Tablet 提供服务</li>
<li>只要文件还存在，Tablet 服务器就会试图重新获得对该文件的独占锁；如果文件不存在了，那么Tablet 服务器就不能再提供服务了，它会自行退出</li>
<li>当 Tablet 服务器终止时（比如，集群的管理系统将运行该 Tablet 服务器的主机从集群中移除），它会尝试释放它持有的文件锁，这样一来，Master 服务器就能尽快把Tablet 分配到其它的 Tablet 服务器</li>
</ol>
<ul>
<li><strong>Master 服务器负责检查一个 Tablet 服务器是否已经不再为它的 Tablet 提供服务了，并且要尽快重新分配<br>
它加载的 Tablet。</strong></li>
</ul>
<ol>
<li>Master 服务器通过轮询 Tablet 服务器文件锁的状态来检测何时 Tablet 服务器不再为 Tablet提供服务。</li>
<li>如果一个 Tablet 服务器报告它丢失了文件锁，或者 Master 服务器最近几次尝试和它通信都没有得到响应，Master 服务器就会尝试获取该 Tablet 服务器文件的独占锁；如果 Master 服务器成功获取了独占锁，那么就说明 Chubby 是正常运行的，而 Tablet 服务器要么是宕机了、要么是不能和 Chubby 通信了，因此，Master<br>
服务器就删除该 Tablet 服务器在 Chubby 上的服务器文件以确保它不再给 Tablet 提供服务。一旦 Tablet 服务器在 Chubby 上的服务器文件被删除了，Master 服务器就把之前分配给它的所有的 Tablet 放入未分配的 Tablet集合中。</li>
<li>为了确保 Bigtable 集群在 Master 服务器和 Chubby 之间网络出现故障的时候仍然可以使用，Master服务器在它的 Chubby 会话过期后主动退出。但是不管怎样，如同我们前面所描述的，Master 服务器的故障不会改变现有 Tablet 在 Tablet 服务器上的分配状态。</li>
</ol>
<p>当集群管理系统启动了一个 Master 服务器之后，Master 服务器首先要了解当前 Tablet 的分配状态，之后才能够修改分配状态。Master 服务器在启动的时候执行以下步骤：</p>
<ol>
<li>Master 服务器从 Chubby 获取一个唯一的 Master 锁，用来阻止创建其它的 Master 服务器实例；</li>
<li>Master 服务器扫描 Chubby 的服务器文件锁存储目录，获取当前正在运行的服务器列表；</li>
<li>Master 服务器和所有的正在运行的 Tablet 表服务器通信，获取每个 Tablet 服务器上 Tablet 的分配信息；</li>
<li>Master 服务器扫描 METADATA 表获取所有的 Tablet 的集合。</li>
</ol>
<p>在扫描的过程中，当 Master 服务器发现了一个还没有分配的 Tablet，Master 服务器就将这个 Tablet 加入未分配的 Tablet 集合等待合适的时机分配。</p>
<h3 id="tablet服务">Tablet服务</h3>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2019/10/07/QKMJ6qhC42G8E7x.png" alt="" loading="lazy"></figure>
<center/>图5 Tablet Representation
<ul>
<li>Tablet 的持久化状态信息保存在 GFS 上</li>
<li>更新操作提交到 REDO 日志中</li>
</ul>
<h4 id="memtable-和-sstable">MEMTABLE 和 SSTABLE</h4>
<p>Tablet 的持久化状态信息保存在 GFS 上。更新操作提交到 REDO 日志中。</p>
<p>在这些更新操作中，最近提交的那些存放在一个排序的缓存中，我们称这个缓存为 memtable；较早的更新存放在一系列SSTable 中。</p>
<p>为了恢复一个 Tablet，Tablet 服务器首先从 METADATA 表中读取它的元数据。</p>
<p>Tablet 的元数据包含了组成这个 Tablet 的SSTable 的列表，以及一系列的 Redo Point，这些 Redo Point 指向可能含有该 Tablet数据的已提交的日志记录。Tablet 服务器把 SSTable 的索引读进内存，之后通过重复 Redo Point 之后提交的更新来重建 memtable。</p>
<p>当对 Tablet 服务器进行写操作时，Tablet 服务器首先要检查这个操作格式是否正确、操作发起者是否有执行这个操作的权限。一个有效的读操作在一个由一系列 SSTable 和 memtable 合并的视图里执行。由于 SSTable 和 memtable 是按字典排序的数据结构，因此可以高效生成合并视图。</p>
<p>另外，当进行 Tablet 的合并和分割时，正在进行的读写操作能够继续进行。</p>
<h3 id="空间收缩">空间收缩</h3>
<ul>
<li>随着写操作的执行，memtable 的大小不断增加。当 memtable 的尺寸到达一个门限值的时候，这个 memtable就会被冻结，然后创建一个新的 memtable</li>
<li>被冻结住 memtable 会被转换成 SSTable，然后写入 GFS</li>
</ul>
<h4 id="目的">目的</h4>
<p>shrink Tablet 服务器使用的内存，以及在服务器灾难恢复过程中，减少必须从提交日志里读取的数据量。</p>
<h4 id="流程">流程</h4>
<ol>
<li>每一次 Minor Compaction 都会创建一个新的 SSTable。</li>
<li>如果 Minor Compaction 过程不停滞的持续进行下去，读操作可能需要合并来自多个 SSTable 的更新；否则，我们通过定期在后台执行 Merging Compaction 过程合并文件，限制这类文件的数量。</li>
<li>Merging Compaction 过程读取一些 SSTable 和 memtable 的内容，合并成一个新的 SSTable。只要Merging Compaction 过程完成了，输入的这些 SSTable 和 memtable 就可以删除了。</li>
<li>合并所有的 SSTable 并生成一个新的 SSTable 的 Merging Compaction 过程叫作 Major Compaction。由非<br>
Major Compaction 产生的 SSTable 可能含有特殊的删除条目，这些删除条目能够隐藏在旧的、但是依然有效的SSTable中已经删除的数据。</li>
<li>Major Compaction过程生成的SSTable不包含已经删除的信息或数据。</li>
<li>Bigtable循环扫描它所有的 Tablet，并且定期对它们执行 Major Compaction。Major Compaction 机制允许 Bigtable 回收已经删除的数据占有的资源，并且确保 BigTable 能及时清除已经删除的数据。</li>
</ol>
<h2 id="优化">优化</h2>
<h3 id="局部性群组">局部性群组</h3>
<h4 id="特性">特性</h4>
<ul>
<li>
<p>多个列族组合成一个局部性群组</p>
</li>
<li>
<p>Tablet中每个局部性群组都会生成一个单独的SSTable</p>
</li>
<li>
<p>通常将不会一起访问的列族分割成不同的局部性群组可以提高读取效率</p>
<blockquote>
<p>例如，在 Webtable表中，网页的元数据（比如语言和 Checksum）可以在一个局部性群组中，网页的内容可以在另外一个群组：当一个应用程序要读取网页的元数据的时候，它没有必要去读取所有的页面内容。</p>
</blockquote>
</li>
<li>
<p>可以以局部性群组为单位设定一些有用的调试参数</p>
<blockquote>
<p>比如，可以把一个局部性群组设定为全部存储在内存中。Tablet 服务器依照惰性加载的策略将设定为放入内存的局部性群组的 SSTable 装载进内存。加载完成之后，访问属于该局部性群组的列族的时候就不必读取硬盘了。这个特性对于需要频繁访问的小块数据特别有用：在 Bigtable 内部，我们利用这个特性提高 METADATA 表中具有位置相关性的列族的访问速度。</p>
</blockquote>
</li>
</ul>
<h3 id="压缩">压缩</h3>
<h4 id="两遍压缩">两遍压缩</h4>
<p>第一遍采用 Bentley and McIlroy’s 方式，这种方式在一个很大的扫描窗口里对常见的长字符串进行压缩。</p>
<p>第二遍是采用快速压缩算法，即在一个 16KB 的小扫描窗口中寻找重复数据。</p>
<h3 id="通过缓存提高读操作性能">通过缓存提高读操作性能</h3>
<p><strong>二级缓存</strong></p>
<ul>
<li>目的：为例提高读操作的性能</li>
<li>流程：
<ol>
<li>扫描缓存是第一级缓存，主要缓存 Tablet服务器通过 SSTable 接口获取的 Key-Value 对（对于经常要重复读取相同数据的应用程序来说，扫描缓存非常有效）</li>
<li>Block 缓存是二级缓存，缓存的是从 GFS 读取的 SSTable 的 Block（对于经常要读取刚刚读过的数据附近的数据的应用程序来说，Block 缓存更有用）</li>
</ol>
</li>
</ul>
<h4 id="bloom过滤器">Bloom过滤器</h4>
<p>一个读操作必须读取构成 Tablet 状态的所有 SSTable 的数据。如果这些 SSTable 不在内存中，那么就需要多次访问硬盘。我们通过允许客户程序对特定局部性群组的 SSTable 指定 Bloom 过滤器来__减少硬盘访问的次数__。</p>
<h4 id="commit日志的实现">Commit日志的实现</h4>
<p>如果我们把对每个 Tablet 的操作的 Commit 日志都存在一个单独的文件的话，那么就会产生大量的文件，并且这些文件会并行的写入 GFS。根据 GFS 服务器底层文件系统实现的方案，要把这些文件写入不同的磁盘日志文件时，会有大量的磁盘 Seek 操作。另外，由于批量提交25中操作的数目一般比较少，因此，对每个Tablet 设置单独的日志文件也会给批量提交本应具有的优化效果带来很大的负面影响。</p>
<p>为了避免这些问题，我们__设置每个 Tablet 服务器一个 Commit 日志文件，把修改操作的日志以追加方式写入同一个日志文件__，因此__一个实际的日志文件中混合了对多个 Tablet 修改的日志记录__。</p>
<p>使用单个日志显著提高了普通操作的性能，但是将恢复的工作复杂化了。</p>
<p>为了避免多次读取日志文件：</p>
<ol>
<li>把日志按照关键字（table，row name，log sequence number）排序；</li>
<li>排序之后，对同一个 Tablet 的修改操作的日志记录就连续存放在了一起。</li>
</ol>
<p>因此，我们只要一次磁盘 Seek 操作， 之后顺序读取就可以。</p>
<h3 id="tablet恢复提速">Tablet恢复提速</h3>
<ol>
<li>Master 服务器将一个 Tablet 从一个 Tablet 服务器移到另外一个 Tablet 服务器时，源 Tablet 服务器会对这个 Tablet 做一次 Minor Compaction；</li>
<li>这个 Compaction 操作减少了 Tablet 服务器的日志文件中没有归并的记录，从而减少了恢复的时间。</li>
<li>Compaction 完成之后，该服务器就停止为该 Tablet 提供服务；</li>
<li>在卸载 Tablet 之前，源 Tablet 服务器还会再做一次（通常会很快）Minor Compaction，以消除前面在一次压缩过程中又产生的未归并的记录；</li>
<li>第二次 Minor Compaction 完成以后，Tablet 就可以被装载到新的 Tablet 服务器上了，并且不需要从日志中进行恢复。</li>
</ol>
<h3 id="利用不变性">利用不变性</h3>
<ul>
<li>在使用 Bigtable 时，除了 SSTable 缓存之外的其它部分产生的 SSTable 都是不变的，我们可以利用这一点对系统进行简化：例如，当从 SSTable 读取数据的时候，我们不必对文件系统访问操作进行同步，这样一来，就可以非常高效的实现对行的并行操作；</li>
<li>memtable 是唯一一个能被读和写操作同时访问的可变数据结构；</li>
<li>对内存表采用 COW(Copy-on-write)机制，这样就允许读写操作并行执行；</li>
<li>可以把永久删除被标记为“删除”的数据的问题，转换成对废弃的SSTable 进行垃圾收集的问题；</li>
<li>每个 Tablet 的 SSTable 都在 METADATA 表中注册了Master 服务器采用“标记-删除”的垃圾回收方式删除 SSTable 集合中废弃的 SSTable；</li>
<li>METADATA 表保存了 Root SSTable的集合；</li>
<li>SSTable 的不变性使得分割 Tablet 的操作非常快捷。我们不必为每个分割出来的 Tablet 建立新的SSTable 集合，而是共享原来的 Tablet 的 SSTable 集合。</li>
</ul>
<h2 id="译者">译者</h2>
<p>作者/编著者：</p>
<p>阎伟</p>
<p>邮件: andy.yanwei@163.com</p>
<p>博客: http://andyblog.sinaapp.com</p>
<p>微博：http://weibo.com/2152410864</p>
]]></content>
    </entry>
</feed>