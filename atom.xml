<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lizonglin313.github.io/</id>
    <title>Big Carrot</title>
    <updated>2021-01-24T14:40:25.138Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lizonglin313.github.io/"/>
    <link rel="self" href="https://lizonglin313.github.io/atom.xml"/>
    <subtitle>人们依然相信 什么未来会更精彩</subtitle>
    <logo>https://lizonglin313.github.io/images/avatar.png</logo>
    <icon>https://lizonglin313.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Big Carrot</rights>
    <entry>
        <title type="html"><![CDATA[$ ./network.sh up =>ENTER后发生了什么？]]></title>
        <id>https://lizonglin313.github.io/post/dollar-networksh-up-greaterenter-hou-fa-sheng-liao-shi-me</id>
        <link href="https://lizonglin313.github.io/post/dollar-networksh-up-greaterenter-hou-fa-sheng-liao-shi-me">
        </link>
        <updated>2021-01-24T14:32:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Fabric2.X中，用fabric-samples替换掉原来的first-network，提供给开发人员快速上手。fabric-samples中的test-network为我们提供了一系列脚本和配置文件，让我们可以简单的启动一个fabric网络。</p>
<p>本文以广度优先的方法解读network.sh的内容</p>
</blockquote>
<h2 id="networksh">network.sh</h2>
<h4 id="a设置环境变量">a.设置环境变量</h4>
<pre><code class="language-shell">export PATH=${PWD}/../bin:${PWD}:$PATH
export FABRIC_CFG_PATH=${PWD}/configtx
export VERBOSE=false
</code></pre>
<ul>
<li><code>bin</code>目录内容如下</li>
</ul>
<pre><code>├─bin
│      configtxgen
│      configtxlator
│      cryptogen
│      discover
│      fabric-ca-client
│      fabric-ca-server
│      idemixgen
│      orderer
│      peer
</code></pre>
<p><code>cryptogen</code>以及<code>configtxgen</code>这两个重要的工具通过编译生成，用来创建参与网络实体的证书，生成创世区块和通道的配置文件以及组织的锚节点。相应的，<code>bin</code>目录中还有其他需要使用到的工具。</p>
<p><code>configtx</code>中的文件是用来配置网络的，<code>configtxgen</code>这个工具就是依靠<code>configtx</code>中的<code>configtx.yaml</code>文件来定义网络。</p>
<h4 id="b提供函数">b.提供函数</h4>
<ul>
<li><code>clearContainers()</code></li>
</ul>
<p>清除启动、运行网络时，在docker中创建的镜像；这个函数在关闭网络时被调用。</p>
<ul>
<li><code>removeUnwantedImages()</code></li>
</ul>
<p>清除不想要的镜像</p>
<ul>
<li><code>checkPrereqs()</code></li>
</ul>
<p>检查网络组件、二进制文件、镜像文件的版本，依托于上级目录的<code>config</code>文件夹，该文件夹的内容中包含了Fabric网络中的基本属性的配置，其内容如下：</p>
<pre><code class="language-shell">├─config
│      configtx.yaml
│      core.yaml	
│      orderer.yaml
</code></pre>
<p>检查<code>peer</code>版本、<code>docker_image</code>版本。</p>
<blockquote>
<p>一般来说，拉取Fabric项目后，使用<code>bootstrap.sh</code>脚本，都可以得到对应版本的文件以及环境。</p>
</blockquote>
<ul>
<li><code>createOrgs()</code></li>
</ul>
<p>该函数使用<code>cryptogen</code>工具或者<code>CAs</code>创建组织的身份材料，它在运行时首先清理掉现有的身份，然后一步步执行。在<code>test-network</code>中，首先使用<code>cryptogen</code>或者<code>CAs</code>工具创建<code>Org1</code>，<code>Org2</code>的身份，然后创建<code>Orderer Org</code>的身份。</p>
<blockquote>
<p>一旦创建了组织的身份后，我们就需要生成<code>genesis block</code>，并且创建应用的<code>channel</code>让<code>Orderer</code>节点加入。</p>
</blockquote>
<ul>
<li><code>createConsortium()</code></li>
</ul>
<p>该函数使用<code>configtxgen</code>这个工具生成<code>channel</code>的<code>orderer genesis block</code>。</p>
<blockquote>
<p>在创建组织实体身份以及创世区块后，就可以开启<code>peers</code>和<code>orderering</code>服务了。</p>
</blockquote>
<ul>
<li><code>networkUp()</code></li>
</ul>
<p>该函数使用<code>docker compose</code>开启<code>peer</code>和<code>orderer</code>节点。成功后，为我们打印出当前的<code>docker images</code>。</p>
<blockquote>
<p>对于运行的Fabric网络，可以创建<code>channel</code>实现应用数据的隔离。</p>
</blockquote>
<ul>
<li><code>createChannel()</code></li>
</ul>
<p>该函数创建一个<code>channel</code>让<code>Org1</code>和<code>Org2</code>的<code>peers</code>节点加入。首先，它检查网络是否启动，如果没有，就先把网络开启，然后再创建。它使用<code>createChannel.sh</code>脚本创建通道。</p>
<ul>
<li><code>deployCC()</code></li>
</ul>
<p>该函数把链码安装到通道上并将链码实例化，它调用<code>deployCC.sh</code>这个脚本实现。</p>
<ul>
<li><code>networkDown()</code></li>
</ul>
<p>该函数断开正在运行的网络，它首先删除<code>docker compose</code>中的镜像，清除容器，删除<code>genesis block</code>各个组织的<code>ca</code>，卸载<code>chaincode</code>。也就是说，<code>down</code>掉网络后，我们在上面创建的实体、通道，安装的链码等等全部被清除掉了，如果再次启动时还需从头开始配置。</p>
<h2 id="up-down">Up &amp; Down</h2>
<h4 id="networksh-up">./network.sh up</h4>
<p>这个命令其实就是调用函数<code>networkUp()</code>，函数中依次调用：</p>
<ol>
<li><code>createOrgs()</code></li>
<li><code>createConsortium()</code></li>
<li>开启<code>docker-compose</code></li>
<li>打印<code>docker ps -a</code>存在的镜像</li>
</ol>
<h4 id="networksh-down">./network.sh down</h4>
<p>这个命令调用函数<code>networkDown()</code>，函数中依次调用：</p>
<ol>
<li><code>docker-compose -f</code>删除镜像</li>
<li><code>clearContainers()</code></li>
<li><code>removeUnwantedImages</code></li>
<li><code>rm -rf system-genesis-block</code></li>
<li><code>rm -rf organizations/fabric-ca/org...</code></li>
<li><code>rm -rf channel-artifacts log.txt chaincode.tar.gz chaincode</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang常用工具]]></title>
        <id>https://lizonglin313.github.io/post/golang-chang-yong-gong-ju</id>
        <link href="https://lizonglin313.github.io/post/golang-chang-yong-gong-ju">
        </link>
        <updated>2021-01-23T11:35:32.000Z</updated>
        <content type="html"><![CDATA[<p>一般格式：<code>go command [arguments]</code></p>
<h3 id="build">build</h3>
<ul>
<li>
<p><code>build</code></p>
<p>最常用的命令，用来编译go文件</p>
<p>跨平台编译，如<code>env GOOS=linux GOARCH=amd64 go build</code>在Linux系统、amd64架构编译</p>
</li>
</ul>
<h3 id="install">install</h3>
<ul>
<li>
<p><code>install</code></p>
<p>同为编译，和<code>build</code>的不同在于编译后会将输出文件打包成库放在pkg下面</p>
</li>
</ul>
<h3 id="get">get</h3>
<ul>
<li>
<p><code>get</code></p>
<p>用于获取go第三方包，默认从git repo获取最新版本，如<code>go get -u github.com/go-sql-driver/mysql</code></p>
</li>
</ul>
<h3 id="fmt">fmt</h3>
<ul>
<li>
<p><code>fmt</code></p>
<p>统一代码风格，<code>go fmt</code></p>
</li>
</ul>
<h3 id="test">test</h3>
<ul>
<li>
<p><code>test</code></p>
<p>运行当前包目录下的test，如<code>go test</code>或<code>go test -v</code>，test文件命名是<code>xxx_test.go</code></p>
</li>
</ul>
<p>关于写test case：</p>
<ul>
<li>
<p>test命名为<code>TestXxxx</code></p>
</li>
<li>
<p>test case 的参数为：<code>t *testing.T</code> 或者 <code>b *testing.B</code> (用于测试性能)</p>
</li>
<li>
<p><code>t.Errorf()</code> 用于打印错误信息，同时跳过整个test case</p>
</li>
<li>
<p><code>t.SkipNow()</code> 为跳过当前test，并且直接处理下一个test case，要写在test case的第一行</p>
</li>
<li>
<p><code>t.Run()</code> 来执行subtests，可以做到控制test输出以及test的顺序</p>
</li>
<li>
<p><code>TestMain(m *testing.M)</code> 初始化test，使用<code>m.Run()</code>来调用其他tests，可以用来完成一些初始化；如果没有调用<code>m.Run()</code>，那么处了TestMain以外其他的tests就不会被执行</p>
</li>
</ul>
<p>关于benchmark：</p>
<ul>
<li>benchmark函数一般以Benchmark开头，如<code>BenchmarkXxx</code></li>
<li>参数为： <code>b *testing.B</code></li>
<li>每次执行一般会跑<code>b.N</code>次</li>
<li>在执行过程中根据实际case的执行时间是否稳定来调整<code>b.N</code>的次数直至稳定</li>
<li>命令行中，命令为：<code>go test -bench=.</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fabric2.X_fabric-samples_test-network解读]]></title>
        <id>https://lizonglin313.github.io/post/fabric2x_fabric-samples_test-network-jie-du</id>
        <link href="https://lizonglin313.github.io/post/fabric2x_fabric-samples_test-network-jie-du">
        </link>
        <updated>2021-01-21T12:41:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Fabric2.X中，<code>fabric-samples</code>将作为Fabric1.X中的<code>first-network</code>的替代。也就是说，在2.X版本及以后，使用<code>fabric-samples</code>作为fabric的测试网络了。</p>
</blockquote>
<p>在配置好基本环境之后，来看一下它为我们提供了哪些内容。</p>
<h2 id="目录结构">目录结构</h2>
<pre><code class="language-shell">root@lizonglin-virtual-machine:/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples# ll
total 100
drwxr-xr-x 15 lizonglin lizonglin  4096 1月  21 10:55 ./
drwxr-xr-x  3 lizonglin lizonglin  4096 1月  21 10:17 ../
drwxr-xr-x  2 lizonglin lizonglin  4096 10月  1 03:52 bin/
drwxr-xr-x  8 lizonglin lizonglin  4096 1月  21 10:55 chaincode/
drwxr-xr-x  3 lizonglin lizonglin  4096 1月  21 10:55 chaincode-docker-devmode/
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 10:55 ci/
-rw-r--r--  1 lizonglin lizonglin   597 1月  17 18:50 CODE_OF_CONDUCT.md
-rw-r--r--  1 lizonglin lizonglin   109 1月  17 18:50 CODEOWNERS
drwxr-xr-x  3 lizonglin lizonglin  4096 1月  21 10:55 commercial-paper/
drwxr-xr-x  2 lizonglin lizonglin  4096 10月  1 02:41 config/
-rw-r--r--  1 lizonglin lizonglin   935 1月  17 18:50 CONTRIBUTING.md
drwxr-xr-x  5 lizonglin lizonglin  4096 1月  21 10:55 fabcar/
drwxr-xr-x  6 lizonglin lizonglin  4096 1月  21 11:24 first-network/
drwxr-xr-x  8 lizonglin lizonglin  4096 1月  21 10:55 .git/
-rw-r--r--  1 lizonglin lizonglin   189 1月  21 10:55 .gitignore
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 10:55 high-throughput/
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 10:55 interest_rate_swaps/
-rw-r--r--  1 lizonglin lizonglin 11358 1月  17 18:50 LICENSE
-rw-r--r--  1 lizonglin lizonglin  1644 1月  21 10:55 MAINTAINERS.md
drwxr-xr-x  2 lizonglin lizonglin  4096 1月  21 10:55 off_chain_data/
-rw-r--r--  1 lizonglin lizonglin  1694 1月  21 10:55 README.md
-rw-r--r--  1 lizonglin lizonglin  1035 1月  17 18:50 SECURITY.md
drwxr-xr-x  8 lizonglin lizonglin  4096 1月  21 18:52 test-network/
</code></pre>
<p>fabric-samples的目录结构如下，可以看到还是暂时为我们保留了first-network，但是新版的启动网络脚本则是在test-network中。</p>
<pre><code class="language-shell">root@lizonglin-virtual-machine:/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network# ll
total 68
drwxr-xr-x  8 lizonglin lizonglin  4096 1月  21 18:52 ./
drwxr-xr-x 15 lizonglin lizonglin  4096 1月  21 10:55 ../
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 10:55 addOrg3/
drwxr-xr-x  2 lizonglin lizonglin  4096 1月  21 10:55 configtx/
drwxr-xr-x  2 lizonglin lizonglin  4096 1月  21 10:55 docker/
-rw-r--r--  1 lizonglin lizonglin    69 1月  17 18:50 .env
-rw-r--r--  1 lizonglin lizonglin   349 1月  21 10:55 .gitignore
-rwxr-xr-x  1 lizonglin lizonglin 20570 1月  21 10:55 network.sh*
drwxr-xr-x  4 lizonglin lizonglin  4096 1月  21 20:05 organizations/
-rw-r--r--  1 lizonglin lizonglin   788 1月  21 10:55 README.md
drwxr-xr-x  3 lizonglin lizonglin  4096 1月  21 10:55 scripts/
drwxr-xr-x  2 lizonglin lizonglin  4096 1月  21 20:05 system-genesis-block/
</code></pre>
<h2 id="networksh">network.sh</h2>
<p>其中，network.sh*即启动脚本，在新的脚本中，为我们进行了大量的配置工作，使得新版本的脚本很长，省略一些不必要的内容：</p>
<pre><code class="language-shell">#!/bin/bash
# 首先是一些说明：
# 两个组织，每个组织一个peer节点
# 一个使用Raft单节点的排序服务
# This script brings up a Hyperledger Fabric network for testing smart contracts
# and applications. The test network consists of two organizations with one
# peer each, and a single node Raft ordering service. Users can also use this
# script to create a channel deploy a chaincode on the channel
#
# prepending $PWD/../bin to PATH to ensure we are picking up the correct binaries
# this may be commented out to resolve installed version of tools if desired
export PATH=${PWD}/../bin:${PWD}:$PATH
export FABRIC_CFG_PATH=${PWD}/configtx
export VERBOSE=false

# Print the usage message
function printHelp() {
  echo &quot;Usage: &quot;
  echo &quot;  network.sh &lt;Mode&gt; [Flags]&quot;
  echo &quot;    &lt;Mode&gt;&quot;
  echo &quot;      - 'up' - bring up fabric orderer and peer nodes. No channel is created&quot;
  echo &quot;      - 'up createChannel' - bring up fabric network with one channel&quot;
  echo &quot;      - 'createChannel' - create and join a channel after the network is created&quot;
  echo &quot;      - 'deployCC' - deploy the fabcar chaincode on the channel&quot;
  echo &quot;      - 'down' - clear the network with docker-compose down&quot;
  echo &quot;      - 'restart' - restart the network&quot;
  echo
  echo &quot;    Flags:&quot;
  echo &quot;    -ca &lt;use CAs&gt; -  create Certificate Authorities to generate the crypto material&quot;
  echo &quot;    -c &lt;channel name&gt; - channel name to use (defaults to \&quot;mychannel\&quot;)&quot;
  echo &quot;    -s &lt;dbtype&gt; - the database backend to use: goleveldb (default) or couchdb&quot;
  echo &quot;    -r &lt;max retry&gt; - CLI times out after certain number of attempts (defaults to 5)&quot;
  echo &quot;    -d &lt;delay&gt; - delay duration in seconds (defaults to 3)&quot;
  echo &quot;    -l &lt;language&gt; - the programming language of the chaincode to deploy: go (default), java, javascript, typescript&quot;
  echo &quot;    -v &lt;version&gt;  - chaincode version. Must be a round number, 1, 2, 3, etc&quot;
  echo &quot;    -i &lt;imagetag&gt; - the tag to be used to launch the network (defaults to \&quot;latest\&quot;)&quot;
  echo &quot;    -verbose - verbose mode&quot;
  echo &quot;  network.sh -h (print this message)&quot;
  echo
  echo &quot; Possible Mode and flags&quot;
  echo &quot;  network.sh up -ca -c -r -d -s -i -verbose&quot;
  echo &quot;  network.sh up createChannel -ca -c -r -d -s -i -verbose&quot;
  echo &quot;  network.sh createChannel -c -r -d -verbose&quot;
  echo &quot;  network.sh deployCC -l -v -r -d -verbose&quot;
  echo
  echo &quot; Taking all defaults:&quot;
  echo &quot;	network.sh up&quot;
  echo
  echo &quot; Examples:&quot;
  echo &quot;  network.sh up createChannel -ca -c mychannel -s couchdb -i 2.0.0&quot;
  echo &quot;  network.sh createChannel -c channelName&quot;
  echo &quot;  network.sh deployCC -l javascript&quot;
}
# 清理docker容器
# Obtain CONTAINER_IDS and remove them
# TODO Might want to make this optional - could clear other containers
# This function is called when you bring a network down
function clearContainers() {
  CONTAINER_IDS=$(docker ps -a | awk '($2 ~ /dev-peer.*/) {print $1}')
  if [ -z &quot;$CONTAINER_IDS&quot; -o &quot;$CONTAINER_IDS&quot; == &quot; &quot; ]; then
    echo &quot;---- No containers available for deletion ----&quot;
  else
    docker rm -f $CONTAINER_IDS
  fi
}
# 删除docker镜像
# Delete any images that were generated as a part of this setup
# specifically the following images are often left behind:
# This function is called when you bring the network down
function removeUnwantedImages() {
  DOCKER_IMAGE_IDS=$(docker images | awk '($1 ~ /dev-peer.*/) {print $3}')
  if [ -z &quot;$DOCKER_IMAGE_IDS&quot; -o &quot;$DOCKER_IMAGE_IDS&quot; == &quot; &quot; ]; then
    echo &quot;---- No images available for deletion ----&quot;
  else
    docker rmi -f $DOCKER_IMAGE_IDS
  fi
}

# Versions of fabric known not to work with the test network
BLACKLISTED_VERSIONS=&quot;^1\.0\. ^1\.1\. ^1\.2\. ^1\.3\. ^1\.4\.&quot;

# 这里检查一下现有的二进制文件以及镜像是否可用，免得后续出现问题
# Do some basic sanity checking to make sure that the appropriate versions of fabric
# binaries/images are available. In the future, additional checking for the presence
# of go or other items could be added.
function checkPrereqs() {
  ## Check if your have cloned the peer binaries and configuration files.
  peer version &gt; /dev/null 2&gt;&amp;1

  if [[ $? -ne 0 || ! -d &quot;../config&quot; ]]; then
    echo &quot;ERROR! Peer binary and configuration files not found..&quot;
    echo
    echo &quot;Follow the instructions in the Fabric docs to install the Fabric Binaries:&quot;
    echo &quot;https://hyperledger-fabric.readthedocs.io/en/latest/install.html&quot;
    exit 1
  fi
  # 检查docker镜像以及二进制文件是否匹配
  # use the fabric tools container to see if the samples and binaries match your
  # docker images
  LOCAL_VERSION=$(peer version | sed -ne 's/ Version: //p')
  DOCKER_IMAGE_VERSION=$(docker run --rm hyperledger/fabric-tools:$IMAGETAG peer version | sed -ne 's/ Version: //p' | head -1)

  echo &quot;LOCAL_VERSION=$LOCAL_VERSION&quot;
  echo &quot;DOCKER_IMAGE_VERSION=$DOCKER_IMAGE_VERSION&quot;

  if [ &quot;$LOCAL_VERSION&quot; != &quot;$DOCKER_IMAGE_VERSION&quot; ]; then
    echo &quot;=================== WARNING ===================&quot;
    echo &quot;  Local fabric binaries and docker images are  &quot;
    echo &quot;  out of  sync. This may cause problems.       &quot;
    echo &quot;===============================================&quot;
  fi

  for UNSUPPORTED_VERSION in $BLACKLISTED_VERSIONS; do
    echo &quot;$LOCAL_VERSION&quot; | grep -q $UNSUPPORTED_VERSION
    if [ $? -eq 0 ]; then
      echo &quot;ERROR! Local Fabric binary version of $LOCAL_VERSION does not match the versions supported by the test network.&quot;
      exit 1
    fi

    echo &quot;$DOCKER_IMAGE_VERSION&quot; | grep -q $UNSUPPORTED_VERSION
    if [ $? -eq 0 ]; then
      echo &quot;ERROR! Fabric Docker image version of $DOCKER_IMAGE_VERSION does not match the versions supported by the test network.&quot;
      exit 1
    fi
  done
}

# 下面简单介绍了cryptogen这个工具以及CA
# Before you can bring up a network, each organization needs to generate the crypto
# material that will define that organization on the network. Because Hyperledger
# Fabric is a permissioned blockchain, each node and user on the network needs to
# use certificates and keys to sign and verify its actions. In addition, each user
# needs to belong to an organization that is recognized as a member of the network.
# You can use the Cryptogen tool or Fabric CAs to generate the organization crypto
# material.

# By default, the sample network uses cryptogen. Cryptogen is a tool that is
# meant for development and testing that can quicky create the certificates and keys
# that can be consumed by a Fabric network. The cryptogen tool consumes a series
# of configuration files for each organization in the &quot;organizations/cryptogen&quot;
# directory. Cryptogen uses the files to generate the crypto  material for each
# org in the &quot;organizations&quot; directory.

# You can also Fabric CAs to generate the crypto material. CAs sign the certificates
# and keys that they generate to create a valid root of trust for each organization.
# The script uses Docker Compose to bring up three CAs, one for each peer organization
# and the ordering organization. The configuration file for creating the Fabric CA
# servers are in the &quot;organizations/fabric-ca&quot; directory. Within the same diectory,
# the &quot;registerEnroll.sh&quot; script uses the Fabric CA client to create the identites,
# certificates, and MSP folders that are needed to create the test network in the
# &quot;organizations/ordererOrganizations&quot; directory.

# Create Organziation crypto material using cryptogen or CAs
function createOrgs() {

  if [ -d &quot;organizations/peerOrganizations&quot; ]; then
    rm -Rf organizations/peerOrganizations &amp;&amp; rm -Rf organizations/ordererOrganizations
  fi

  # Create crypto material using cryptogen
  if [ &quot;$CRYPTO&quot; == &quot;cryptogen&quot; ]; then
    which cryptogen
    if [ &quot;$?&quot; -ne 0 ]; then
      echo &quot;cryptogen tool not found. exiting&quot;
      exit 1
    fi
    echo
    echo &quot;##########################################################&quot;
    echo &quot;##### Generate certificates using cryptogen tool #########&quot;
    echo &quot;##########################################################&quot;
    echo

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Org1 Identities ######################&quot;
    echo &quot;##########################################################&quot;

    set -x
    cryptogen generate --config=./organizations/cryptogen/crypto-config-org1.yaml --output=&quot;organizations&quot;
    res=$?
    set +x
    if [ $res -ne 0 ]; then
      echo &quot;Failed to generate certificates...&quot;
      exit 1
    fi

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Org2 Identities ######################&quot;
    echo &quot;##########################################################&quot;

    set -x
    cryptogen generate --config=./organizations/cryptogen/crypto-config-org2.yaml --output=&quot;organizations&quot;
    res=$?
    set +x
    if [ $res -ne 0 ]; then
      echo &quot;Failed to generate certificates...&quot;
      exit 1
    fi

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Orderer Org Identities ###############&quot;
    echo &quot;##########################################################&quot;

    set -x
    cryptogen generate --config=./organizations/cryptogen/crypto-config-orderer.yaml --output=&quot;organizations&quot;
    res=$?
    set +x
    if [ $res -ne 0 ]; then
      echo &quot;Failed to generate certificates...&quot;
      exit 1
    fi

  fi

  # Create crypto material using Fabric CAs
  if [ &quot;$CRYPTO&quot; == &quot;Certificate Authorities&quot; ]; then

    fabric-ca-client version &gt; /dev/null 2&gt;&amp;1
    if [ $? -ne 0 ]; then
      echo &quot;Fabric CA client not found locally, downloading...&quot;
      cd ..
      curl -s -L &quot;https://github.com/hyperledger/fabric-ca/releases/download/v1.4.4/hyperledger-fabric-ca-${OS_ARCH}-1.4.4.tar.gz&quot; | tar xz || rc=$?
    if [ -n &quot;$rc&quot; ]; then
        echo &quot;==&gt; There was an error downloading the binary file.&quot;
        echo &quot;fabric-ca-client binary is not available to download&quot;
    else
        echo &quot;==&gt; Done.&quot;
      cd test-network
    fi
    fi

    echo
    echo &quot;##########################################################&quot;
    echo &quot;##### Generate certificates using Fabric CA's ############&quot;
    echo &quot;##########################################################&quot;

    IMAGE_TAG=$IMAGETAG docker-compose -f $COMPOSE_FILE_CA up -d 2&gt;&amp;1

    . organizations/fabric-ca/registerEnroll.sh

    sleep 10

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Org1 Identities ######################&quot;
    echo &quot;##########################################################&quot;

    createOrg1

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Org2 Identities ######################&quot;
    echo &quot;##########################################################&quot;

    createOrg2

    echo &quot;##########################################################&quot;
    echo &quot;############ Create Orderer Org Identities ###############&quot;
    echo &quot;##########################################################&quot;

    createOrderer

  fi

  echo
  echo &quot;Generate CCP files for Org1 and Org2&quot;
  ./organizations/ccp-generate.sh
}

# 使用cryptogen（cryptogen用于配置网络中的证书、组织等）配置完网络组织后
# 这里使用configtxgen配置创世区块、channel以及锚节点
# 有一个&quot;configtx.yaml&quot;文件帮助配置网络中的组织创世区块，组织成员等内容
# 创建每个channel的MSP
# Once you create the organization crypto material, you need to create the
# genesis block of the orderer system channel. This block is required to bring
# up any orderer nodes and create any application channels.

# The configtxgen tool is used to create the genesis block. Configtxgen consumes a
# &quot;configtx.yaml&quot; file that contains the definitions for the sample network. The
# genesis block is defiend using the &quot;TwoOrgsOrdererGenesis&quot; profile at the bottom
# of the file. This profile defines a sample consortium, &quot;SampleConsortium&quot;,
# consisting of our two Peer Orgs. This consortium defines which organizations are
# recognized as members of the network. The peer and ordering organizations are defined
# in the &quot;Profiles&quot; section at the top of the file. As part of each organization
# profile, the file points to a the location of the MSP directory for each member.
# This MSP is used to create the channel MSP that defines the root of trust for
# each organization. In essense, the channel MSP allows the nodes and users to be
# recognized as network members. The file also specifies the anchor peers for each
# peer org. In future steps, this same file is used to create the channel creation
# transaction and the anchor peer updates.
#
#
# If you receive the following warning, it can be safely ignored:
#
# [bccsp] GetDefault -&gt; WARN 001 Before using BCCSP, please call InitFactories(). Falling back to bootBCCSP.
#
# You can ignore the logs regarding intermediate certs, we are not using them in
# this crypto implementation.

# Generate orderer system channel genesis block.
function createConsortium() {

  which configtxgen
  if [ &quot;$?&quot; -ne 0 ]; then
    echo &quot;configtxgen tool not found. exiting&quot;
    exit 1
  fi

  echo &quot;#########  Generating Orderer Genesis block ##############&quot;

  # Note: For some unknown reason (at least for now) the block file can't be
  # named orderer.genesis.block or the orderer will fail to launch!
  set -x
  configtxgen -profile TwoOrgsOrdererGenesis -channelID system-channel -outputBlock ./system-genesis-block/genesis.block
  res=$?
  set +x
  if [ $res -ne 0 ]; then
    echo &quot;Failed to generate orderer genesis block...&quot;
    exit 1
  fi
}

# 之后，启动peer节点和排序服务，创建相应的docker实体
# After we create the org crypto material and the system channel genesis block,
# we can now bring up the peers and orderering service. By default, the base
# file for creating the network is &quot;docker-compose-test-net.yaml&quot; in the ``docker``
# folder. This file defines the environment variables and file mounts that
# point the crypto material and genesis block that were created in earlier.

# Bring up the peer and orderer nodes using docker compose.
function networkUp() {

  checkPrereqs
  # generate artifacts if they don't exist
  if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then
    createOrgs
    createConsortium
  fi

  COMPOSE_FILES=&quot;-f ${COMPOSE_FILE_BASE}&quot;

  if [ &quot;${DATABASE}&quot; == &quot;couchdb&quot; ]; then
    COMPOSE_FILES=&quot;${COMPOSE_FILES} -f ${COMPOSE_FILE_COUCH}&quot;
  fi

  IMAGE_TAG=$IMAGETAG docker-compose ${COMPOSE_FILES} up -d 2&gt;&amp;1

  docker ps -a
  if [ $? -ne 0 ]; then
    echo &quot;ERROR !!!! Unable to start network&quot;
    exit 1
  fi
}

# 将peer加入通道
## call the script to join create the channel and join the peers of org1 and org2
function createChannel() {

## Bring up the network if it is not arleady up.

  if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then
    echo &quot;Bringing up network&quot;
    networkUp
  fi

  # now run the script that creates a channel. This script uses configtxgen once
  # more to create the channel creation transaction and the anchor peer updates.
  # configtx.yaml is mounted in the cli container, which allows us to use it to
  # create the channel artifacts
 scripts/createChannel.sh $CHANNEL_NAME $CLI_DELAY $MAX_RETRY $VERBOSE
  if [ $? -ne 0 ]; then
    echo &quot;Error !!! Create channel failed&quot;
    exit 1
  fi

}
# 实例化链码
## Call the script to isntall and instantiate a chaincode on the channel
function deployCC() {

  scripts/deployCC.sh $CHANNEL_NAME $CC_SRC_LANGUAGE $VERSION $CLI_DELAY $MAX_RETRY $VERBOSE

  if [ $? -ne 0 ]; then
    echo &quot;ERROR !!! Deploying chaincode failed&quot;
    exit 1
  fi

  exit 0
}

# 关闭网络
# Tear down running network
function networkDown() {
  # stop org3 containers also in addition to org1 and org2, in case we were running sample to add org3
  docker-compose -f $COMPOSE_FILE_BASE -f $COMPOSE_FILE_COUCH -f $COMPOSE_FILE_CA down --volumes --remove-orphans
  docker-compose -f $COMPOSE_FILE_COUCH_ORG3 -f $COMPOSE_FILE_ORG3 down --volumes --remove-orphans
  # Don't remove the generated artifacts -- note, the ledgers are always removed
  if [ &quot;$MODE&quot; != &quot;restart&quot; ]; then
    # Bring down the network, deleting the volumes
    #Cleanup the chaincode containers
    clearContainers
    #Cleanup images
    removeUnwantedImages
    # remove orderer block and other channel configuration transactions and certs
    rm -rf system-genesis-block/*.block organizations/peerOrganizations organizations/ordererOrganizations
    ## remove fabric ca artifacts
    rm -rf organizations/fabric-ca/org1/msp organizations/fabric-ca/org1/tls-cert.pem organizations/fabric-ca/org1/ca-cert.pem organizations/fabric-ca/org1/IssuerPublicKey organizations/fabric-ca/org1/IssuerRevocationPublicKey organizations/fabric-ca/org1/fabric-ca-server.db
    rm -rf organizations/fabric-ca/org2/msp organizations/fabric-ca/org2/tls-cert.pem organizations/fabric-ca/org2/ca-cert.pem organizations/fabric-ca/org2/IssuerPublicKey organizations/fabric-ca/org2/IssuerRevocationPublicKey organizations/fabric-ca/org2/fabric-ca-server.db
    rm -rf organizations/fabric-ca/ordererOrg/msp organizations/fabric-ca/ordererOrg/tls-cert.pem organizations/fabric-ca/ordererOrg/ca-cert.pem organizations/fabric-ca/ordererOrg/IssuerPublicKey organizations/fabric-ca/ordererOrg/IssuerRevocationPublicKey organizations/fabric-ca/ordererOrg/fabric-ca-server.db
    rm -rf addOrg3/fabric-ca/org3/msp addOrg3/fabric-ca/org3/tls-cert.pem addOrg3/fabric-ca/org3/ca-cert.pem addOrg3/fabric-ca/org3/IssuerPublicKey addOrg3/fabric-ca/org3/IssuerRevocationPublicKey addOrg3/fabric-ca/org3/fabric-ca-server.db


    # remove channel and script artifacts
    rm -rf channel-artifacts log.txt fabcar.tar.gz fabcar

  fi
}

# Obtain the OS and Architecture string that will be used to select the correct
# native binaries for your platform, e.g., darwin-amd64 or linux-amd64
OS_ARCH=$(echo &quot;$(uname -s | tr '[:upper:]' '[:lower:]' | sed 's/mingw64_nt.*/windows/')-$(uname -m | sed 's/x86_64/amd64/g')&quot; | awk '{print tolower($0)}')
# Using crpto vs CA. default is cryptogen
CRYPTO=&quot;cryptogen&quot;
# timeout duration - the duration the CLI should wait for a response from
# another container before giving up
MAX_RETRY=5
# default for delay between commands
CLI_DELAY=3
# channel name defaults to &quot;mychannel&quot;
CHANNEL_NAME=&quot;mychannel&quot;
# use this as the default docker-compose yaml definition
COMPOSE_FILE_BASE=docker/docker-compose-test-net.yaml
# docker-compose.yaml file if you are using couchdb
COMPOSE_FILE_COUCH=docker/docker-compose-couch.yaml
# certificate authorities compose file
COMPOSE_FILE_CA=docker/docker-compose-ca.yaml
# use this as the docker compose couch file for org3
COMPOSE_FILE_COUCH_ORG3=addOrg3/docker/docker-compose-couch-org3.yaml
# use this as the default docker-compose yaml definition for org3
COMPOSE_FILE_ORG3=addOrg3/docker/docker-compose-org3.yaml
#
# use golang as the default language for chaincode
CC_SRC_LANGUAGE=golang
# Chaincode version
VERSION=1
# default image tag
IMAGETAG=&quot;latest&quot;
# default database
DATABASE=&quot;leveldb&quot;

# Parse commandline args

## Parse mode
if [[ $# -lt 1 ]] ; then
  printHelp
  exit 0
else
  MODE=$1
  shift
fi

# parse a createChannel subcommand if used
if [[ $# -ge 1 ]] ; then
  key=&quot;$1&quot;
  if [[ &quot;$key&quot; == &quot;createChannel&quot; ]]; then
      export MODE=&quot;createChannel&quot;
      shift
  fi
fi

# parse flags

while [[ $# -ge 1 ]] ; do
  key=&quot;$1&quot;
  case $key in
  -h )
    printHelp
    exit 0
    ;;
  -c )
    CHANNEL_NAME=&quot;$2&quot;
    shift
    ;;
  -ca )
    CRYPTO=&quot;Certificate Authorities&quot;
    ;;
  -r )
    MAX_RETRY=&quot;$2&quot;
    shift
    ;;
  -d )
    CLI_DELAY=&quot;$2&quot;
    shift
    ;;
  -s )
    DATABASE=&quot;$2&quot;
    shift
    ;;
  -l )
    CC_SRC_LANGUAGE=&quot;$2&quot;
    shift
    ;;
  -v )
    VERSION=&quot;$2&quot;
    shift
    ;;
  -i )
    IMAGETAG=&quot;$2&quot;
    shift
    ;;
  -verbose )
    VERBOSE=true
    shift
    ;;
  * )
    echo
    echo &quot;Unknown flag: $key&quot;
    echo
    printHelp
    exit 1
    ;;
  esac
  shift
done

# Are we generating crypto material with this command?
if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then
  CRYPTO_MODE=&quot;with crypto from '${CRYPTO}'&quot;
else
  CRYPTO_MODE=&quot;&quot;
fi

# Determine mode of operation and printing out what we asked for
if [ &quot;$MODE&quot; == &quot;up&quot; ]; then
  echo &quot;Starting nodes with CLI timeout of '${MAX_RETRY}' tries and CLI delay of '${CLI_DELAY}' seconds and using database '${DATABASE}' ${CRYPTO_MODE}&quot;
  echo
elif [ &quot;$MODE&quot; == &quot;createChannel&quot; ]; then
  echo &quot;Creating channel '${CHANNEL_NAME}'.&quot;
  echo
  echo &quot;If network is not up, starting nodes with CLI timeout of '${MAX_RETRY}' tries and CLI delay of '${CLI_DELAY}' seconds and using database '${DATABASE} ${CRYPTO_MODE}&quot;
  echo
elif [ &quot;$MODE&quot; == &quot;down&quot; ]; then
  echo &quot;Stopping network&quot;
  echo
elif [ &quot;$MODE&quot; == &quot;restart&quot; ]; then
  echo &quot;Restarting network&quot;
  echo
elif [ &quot;$MODE&quot; == &quot;deployCC&quot; ]; then
  echo &quot;deploying chaincode on channel '${CHANNEL_NAME}'&quot;
  echo
else
  printHelp
  exit 1
fi

if [ &quot;${MODE}&quot; == &quot;up&quot; ]; then
  networkUp
elif [ &quot;${MODE}&quot; == &quot;createChannel&quot; ]; then
  createChannel
elif [ &quot;${MODE}&quot; == &quot;deployCC&quot; ]; then
  deployCC
elif [ &quot;${MODE}&quot; == &quot;down&quot; ]; then
  networkDown
elif [ &quot;${MODE}&quot; == &quot;restart&quot; ]; then
  networkDown
  networkUp
else
  printHelp
  exit 1
fi

</code></pre>
<h2 id="启动test-network">启动test-network</h2>
<pre><code class="language-shell">root@lizonglin-virtual-machine:/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network# ./network.sh up
# 可以看到，默认使用leveldb
Starting nodes with CLI timeout of '5' tries and CLI delay of '3' seconds and using database 'leveldb' with crypto from 'cryptogen'

LOCAL_VERSION=2.2.1
DOCKER_IMAGE_VERSION=2.2.1
/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network/../bin/cryptogen

# 首先使用cryptogen创建证书
##########################################################
##### Generate certificates using cryptogen tool #########
##########################################################

# 组织1
##########################################################
############ Create Org1 Identities ######################
##########################################################
+ cryptogen generate --config=./organizations/cryptogen/crypto-config-org1.yaml --output=organizations
org1.example.com
+ res=0
+ set +x
# 组织2
##########################################################
############ Create Org2 Identities ######################
##########################################################
+ cryptogen generate --config=./organizations/cryptogen/crypto-config-org2.yaml --output=organizations
org2.example.com
+ res=0
+ set +x
# 排序服务
##########################################################
############ Create Orderer Org Identities ###############
##########################################################
+ cryptogen generate --config=./organizations/cryptogen/crypto-config-orderer.yaml --output=organizations
+ res=0
+ set +x

Generate CCP files for Org1 and Org2
/home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network/../bin/configtxgen
# 排序节点的创世区块
#########  Generating Orderer Genesis block ##############
+ configtxgen -profile TwoOrgsOrdererGenesis -channelID system-channel -outputBlock ./system-genesis-block/genesis.block
2021-01-21 18:53:34.963 CST [common.tools.configtxgen] main -&gt; INFO 001 Loading configuration
2021-01-21 18:53:35.017 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 002 orderer type: etcdraft
2021-01-21 18:53:35.017 CST [common.tools.configtxgen.localconfig] completeInitialization -&gt; INFO 003 Orderer.EtcdRaft.Options unset, setting to tick_interval:&quot;500ms&quot; election_tick:10 heartbeat_tick:1 max_inflight_blocks:5 snapshot_interval_size:16777216 
2021-01-21 18:53:35.017 CST [common.tools.configtxgen.localconfig] Load -&gt; INFO 004 Loaded configuration: /home/lizonglin/GoWork/src/github.com/fabric/scripts/fabric-samples/test-network/configtx/configtx.yaml
2021-01-21 18:53:35.019 CST [common.tools.configtxgen] doOutputBlock -&gt; INFO 005 Generating genesis block
2021-01-21 18:53:35.020 CST [common.tools.configtxgen] doOutputBlock -&gt; INFO 006 Writing genesis block
+ res=0
+ set +x
Creating network &quot;net_test&quot; with the default driver
Creating volume &quot;net_orderer.example.com&quot; with default driver
Creating volume &quot;net_peer0.org1.example.com&quot; with default driver
Creating volume &quot;net_peer0.org2.example.com&quot; with default driver
Creating peer0.org2.example.com ... done
Creating orderer.example.com    ... done
Creating peer0.org1.example.com ... done
# 现在的docker中包含的容器，test-network到这里就是初步启动成功了
CONTAINER ID   IMAGE                               COMMAND             CREATED          STATUS                  PORTS                              NAMES
ae8899485a40   hyperledger/fabric-peer:latest      &quot;peer node start&quot;   18 seconds ago   Up Less than a second   0.0.0.0:7051-&gt;7051/tcp             peer0.org1.example.com
e8e4acee2cdd   hyperledger/fabric-orderer:latest   &quot;orderer&quot;           18 seconds ago   Up Less than a second   0.0.0.0:7050-&gt;7050/tcp             orderer.example.com
c0c720b03c4a   hyperledger/fabric-peer:latest      &quot;peer node start&quot;   18 seconds ago   Up 1 second             7051/tcp, 0.0.0.0:9051-&gt;9051/tcp   peer0.org2.example.com

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[VMware使用宿主机的小飞机]]></title>
        <id>https://lizonglin313.github.io/post/vmware-shi-yong-su-zhu-ji-de-xiao-fei-ji</id>
        <link href="https://lizonglin313.github.io/post/vmware-shi-yong-su-zhu-ji-de-xiao-fei-ji">
        </link>
        <updated>2021-01-17T11:13:49.000Z</updated>
        <content type="html"><![CDATA[<p>首先，在小飞机客户端设置允许本地代理允许来自局域网的连接</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/01/17/lyS2NionqGdw6Hc.png" alt="image.png" loading="lazy"></figure>
<p>然后，设置VMware的网络适配器的网络连接为桥接模式，复制连接物理网络状态，设置Ubuntu的网络，所有代理和主机都设置为宿主机的IP（如果宿主机为无线连接到网络就是WLAN的IPv4），注意端口号</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/01/17/fvbXAFNuGBZSx3i.png" alt="image.png" loading="lazy"></figure>
<p>最后，设置Ubuntu的IP地址、网关、DNS信息，与宿主机在同一局域网</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/01/17/y51ZmLcb3i7hsS2.png" alt="image.png" loading="lazy"></figure>
<p>Apply</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/01/17/6t4dfXCBHNG29RK.png" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>转载自：<a href="https://bbs.huaweicloud.com/blogs/107105">VMware下ubuntu通过主机Shadowsocks上外网VMware下ubuntu通过主机Shadowsocks上外网-云社区-华为云 (huaweicloud.com)</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git使用]]></title>
        <id>https://lizonglin313.github.io/post/git-shi-yong</id>
        <link href="https://lizonglin313.github.io/post/git-shi-yong">
        </link>
        <updated>2021-01-15T15:14:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>有关git使用中的学习记录</p>
</blockquote>
<h2 id="clone速度太慢">clone速度太慢</h2>
<h3 id="方法一">方法一</h3>
<ul>
<li>调整http提交缓存(亲测有效，使用https方式clone)</li>
</ul>
<pre><code class="language-bash">$ git config --global http.postBuffer 524288000
</code></pre>
<p>调整前：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/01/15/giAKeOhscXGqUrN.png" alt="LA0@_`KKOXC5IKFKPJ_~PRX.png" loading="lazy"></figure>
<p>调整后：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/01/15/hlJu5ioR4yxzrvg.png" alt="5DU1LP__L__P_K482P_C83O.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bitcoin白皮书]]></title>
        <id>https://lizonglin313.github.io/post/bitcoin-bai-pi-shu</id>
        <link href="https://lizonglin313.github.io/post/bitcoin-bai-pi-shu">
        </link>
        <updated>2021-01-11T14:24:37.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/01/11/1rlwnCBMFfhPkWc.png" alt="PDF_bitcoin.png" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/01/11/bHuZ8NMJ9ky6LUc.png" alt="PDF_bitcoin _1_.png" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/01/11/HmAtd5nSkf41xLW.png" alt="PDF_bitcoin _2_.png" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/01/11/ev3NgUGXMCVcFu4.png" alt="PDF_bitcoin _3_.png" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/01/11/SJKFUqMmpHgZ39V.png" alt="PDF_bitcoin _4_.png" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/01/11/nmIukExlrbX9A27.png" alt="PDF_bitcoin _5_.png" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/01/11/rjxJMP2Lqfsi5V3.png" alt="PDF_bitcoin _6_.png" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/01/11/3za9oj81VDqJpKG.png" alt="PDF_bitcoin _7_.png" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/01/11/ODUPIMNfsyEkahq.png" alt="PDF_bitcoin _8_.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在二叉树中使用递归解决问题]]></title>
        <id>https://lizonglin313.github.io/post/zai-er-cha-shu-zhong-shi-yong-di-gui-jie-jue-wen-ti</id>
        <link href="https://lizonglin313.github.io/post/zai-er-cha-shu-zhong-shi-yong-di-gui-jie-jue-wen-ti">
        </link>
        <updated>2020-06-08T10:05:43.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>整理自leetcode</p>
<p>树结点定义如下：</p>
<pre><code class="language-c">Definition for a binary tree node.
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};
</code></pre>
</blockquote>
<h2 id="二叉树的最大深度">二叉树的最大深度</h2>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br>
给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回它的最大深度 3 。</p>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">int maxDepth(struct TreeNode *root) {
	
	int ld = 0;
	int rd = 0;
	if (NULL == root) return 0;
	if (root-&gt;left) ld = maxDepth(root-&gt;left);	// 左子树存在进行左递归
	if (root-&gt;right) rd = maxDepth(root-&gt;right);	// 右子树存在进行右递归
	return 1 + ((ld &gt; rd) ? ld : rd);		// 本层递归结束比较左右子树的深度取大者相加
}
</code></pre>
<h2 id="对称二叉树">对称二叉树</h2>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">bool recursion(struct TreeNode* left, struct TreeNode* right) {
	
	// 如果左子树和右子树均为空 返回真
	if (NULL == left &amp;&amp; NULL == right) return true;
	else if (left == NULL || right == NULL) {
		// 其中一个不为空 返回假
		return false;
	}

	// 左结点的值是否等于右结点的值
	bool c1 = (left-&gt;val == right-&gt;val);
	// 左结点的左子树是否等于右结点的右子树
	bool c2 = recursion(left-&gt;left, right-&gt;right);
	// 左结点的右子树是否等于右结点的左子树
	bool c3 = recursion(left-&gt;right, right-&gt;left);
	// 如果同时成立
	if (c1&amp;&amp;c2&amp;&amp;c3) {
		return true;
	}
	else {
		return false;
	}
}

bool isSymmetric(struct TreeNode* root) {
	// 根 为空 返回正确
	if (root == NULL) {
		return true;
	}
	return recursion(root-&gt;left, root-&gt;right);
}
</code></pre>
<h2 id="路径总和">路径总和</h2>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>
给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<pre><code>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</code></pre>
<p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">bool hasPathSum(struct TreeNode* root, int sum) {

	if (NULL == root) return false;

	// 保证该结点为叶子结点的前提下 ，判断此时的sum是否和结点的值相等
	if (root-&gt;val == sum &amp;&amp; NULL == root-&gt;left &amp;&amp; NULL == root-&gt;right)
		return true;

	// 递归向下层遍历，出错直接执行 false
	if (hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val))
		return true;

	return false;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链式存储二叉树的遍历]]></title>
        <id>https://lizonglin313.github.io/post/lian-shi-cun-chu-er-cha-shu-de-bian-li</id>
        <link href="https://lizonglin313.github.io/post/lian-shi-cun-chu-er-cha-shu-de-bian-li">
        </link>
        <updated>2020-05-29T08:27:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>先序遍历，中序遍历，后序遍历以及层次遍历。</p>
<p>使用递归、队列。</p>
<p>整理自Leetcode。</p>
</blockquote>
<h2 id="说明">说明</h2>
<p>使用到的树结点类型为：</p>
<pre><code class="language-c">struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};
</code></pre>
<h2 id="先序遍历">先序遍历</h2>
<p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
</code></pre>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">/*求二叉树数据个数，用于动态申请空间*/
int size(struct TreeNode* root)
{
	if (!root) return 0;
	return size(root-&gt;left) + size(root-&gt;right) + 1;	// 递归求二叉树的个数
}
/*递归进行先序遍历*/
void PreOrder(struct TreeNode *root, int *ret, int *retIndex) {
	if (root == NULL) {
		return;
	}
	ret[(*retIndex)++] = root-&gt;val;			// 根
	PreOrder(root-&gt;left, ret, retIndex);	// 左
	PreOrder(root-&gt;right, ret, retIndex);	// 右
}

int* preorderTraversal(struct TreeNode* root, int* returnSize) {

    int treesize = size(root);		// 树结点数量
	int retIndex = 0;				// 数组索引
	int *ret = (int*)malloc(sizeof(int) * treesize);	// 申请空间
	memset(ret, 0, treesize);		// 置零

	PreOrder(root, ret, &amp;retIndex);		// 先序遍历
	*returnSize = retIndex;

	return ret;

}
</code></pre>
<h2 id="中序遍历">中序遍历</h2>
<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
</code></pre>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">int size(struct TreeNode* root)/*求二叉树数据个数*/
{
   if(!root) return 0;
   return size(root-&gt;left)+size(root-&gt;right)+1;
}

void inorder(struct TreeNode* root, int *ret, int* retIndex)/*中序遍历二叉树*/
{
	if (root == NULL) return;

	inorder(root-&gt;left, ret, retIndex);
	ret[(*retIndex)++] = root-&gt;val;
	inorder(root-&gt;right, ret, retIndex);
}

int* inorderTraversal(struct TreeNode* root, int* returnSize) {
    
	int treesize = size(root);
    int retIndex = 0;
	int *ret = (int*)malloc(treesize * sizeof(int));
	memset(ret, 0, treesize);
	
	inorder(root, ret, &amp;retIndex);
    *returnSize = retIndex;
     
    return ret;
}

</code></pre>
<h2 id="后序遍历">后序遍历</h2>
<p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
</code></pre>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">int size(struct TreeNode* root)/*求二叉树数据个数*/
{
   if(!root) return 0;
   return size(root-&gt;left)+size(root-&gt;right)+1;
}

void postorder(struct TreeNode* root, int *ret, int* retIndex)/*中序遍历二叉树*/
{
	if (root == NULL) return;

	postorder(root-&gt;left, ret, retIndex);
	postorder(root-&gt;right, ret, retIndex);
    ret[(*retIndex)++] = root-&gt;val;

}

int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int treesize = size(root);
    int retIndex = 0;
	int *ret = (int*)malloc(treesize * sizeof(int));
	memset(ret, 0, treesize);
	
	postorder(root, ret, &amp;retIndex);
    *returnSize = retIndex;
    return ret;
}
</code></pre>
<h2 id="先序-中序-后序">先序、中序、后序</h2>
<p>显然，对于三种遍历方式，在递归实现中，唯一的不同是递归函数中<code>ret[(*retIndex)++] = root-&gt;val</code>语句的位置:</p>
<pre><code class="language-c">void order(struct TreeNode* root, int *ret, int* retIndex)
{
	if (root == NULL) return;

    //ret[(*retIndex)++] = root-&gt;val;
	postorder(root-&gt;left, ret, retIndex);
	//ret[(*retIndex)++] = root-&gt;val;
    postorder(root-&gt;right, ret, retIndex);
    //ret[(*retIndex)++] = root-&gt;val;

}
</code></pre>
<p>所以，对于三种遍历方式，我们可以统一写为：</p>
<pre><code class="language-c">/*递归求树结点的个数*/
int size(struct TreeNode *root){
    if(!root) return 0;
    return size(root-&gt;left) + size(root-&gt;right) + 1;
}
/**/
void order(struct TreeNode *root, int *ret, int *retIndex, METHOD){
    if(root==NULL) return 0;
    if(METHOD is preorder){
        
        ret[(*resIndex++)] = root-&gt;val;
        order(root-&gt;left, ret, retIndex, METHOD);
        order(root-&gt;right, ret, retIndex, METHOD);
    
    }else if(METHOD is inorder){
    
        order(root-&gt;left, ret, retIndex, METHOD);
        ret[(*resIndex++)] = root-&gt;val;
        order(root-&gt;right, ret, retIndex, METHOD);
    
    }else if(METHOD is lastorder){
    
        order(root-&gt;left, ret, retIndex, METHOD);
        order(root-&gt;right, ret, retIndex, METHOD);
        ret[(*resIndex++)] = root-&gt;val;
    
    }
}

int *orderTraversal(struct TreeNode *root, int *treeSize, METHOD){
    int treesize = size(root);
    int retIndex = 0;
    int *ret = (int*)malloc(sizeof(int)*treesize);
    memset(ret, 0, treesize);
    order(root, ret, &amp;retIndex, METHOD);
    *returnSize = retIndex;
    return ret;
}
</code></pre>
<h2 id="层次遍历">层次遍历</h2>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>
二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回其层次遍历结果：</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre>
<p><strong>代码</strong>:</p>
<blockquote>
<p>作者：r0vHWU5AdJ<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/chun-cchuang-jian-dui-lie-shi-xian-er-cha-shu-de-c/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code class="language-c">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

//创建队列
//1,构建队列，实现压入和弹出函数 Push_Queue 和 Pop_Queue
//2,利用队列先进先出的特性实现二叉树的层序遍历
//3,将二叉树根 root 压入队列，并将 NULL 作为每层的区分节点也压入队列
//4,从队列中读出节点，保存当前节点的值，并且将左右支分别压入队列
//5,遇到层的区分节点则处理下一层，直到队列为空

#define     MAX_LEVEL       1000

//声明队列节点结构
struct QueueNode {
    struct TreeNode* pTreeNode;     //队列元素：二叉树节点指针
    struct TreeNodeQueue* pNext;    //队列元素：下一个节点指针
};

//声明队列结构
struct TreeNodeQueue {
    int     iNum;                   //队列元素个数
    struct QueueNode*   pHead;      //队列头指针
    struct QueueNode*   pTail;      //队列尾指针
};

//函数一：向队列中增加元素
bool Push_Queue(struct TreeNodeQueue* pQueue, struct TreeNode* pTreeNode){
    struct QueueNode*   pQueueNode = NULL;

    if(NULL == pQueue) return false;

    pQueueNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
    pQueueNode-&gt;pTreeNode = pTreeNode;
    pQueueNode-&gt;pNext = NULL;

    if(0 == pQueue-&gt;iNum)
    {
        pQueue-&gt;pHead = pQueueNode;
        pQueue-&gt;pTail = pQueueNode;
        pQueue-&gt;iNum += 1;
    }
    else
    {
        pQueue-&gt;pTail-&gt;pNext = pQueueNode;
        pQueue-&gt;pTail = pQueueNode;
        pQueue-&gt;iNum += 1;
    }

    return true;
}

//函数二：从队列中取出元素
struct TreeNode* Pop_Queue(struct TreeNodeQueue* pQueue){
    struct TreeNode*    pRet    = NULL;
    struct QueueNode*   pTmp    = NULL;

    if((NULL == pQueue) || (0 == pQueue-&gt;iNum)) return NULL;

    pRet = pQueue-&gt;pHead-&gt;pTreeNode;

    pQueue-&gt;iNum -= 1;
    if(0 == pQueue-&gt;iNum)
    {
        free(pQueue-&gt;pHead);
        pQueue-&gt;pHead = NULL;
        pQueue-&gt;pTail = NULL;
    }
    else
    {
        pTmp = pQueue-&gt;pHead-&gt;pNext;
        free(pQueue-&gt;pHead);
        pQueue-&gt;pHead = pTmp;
    }
    
    return pRet;
}

int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    int         iNum        = 0;
    int         iRetSize    = 0;
    int**       pRet        = NULL;
    int*        pRetCol     = NULL;
    
    struct TreeNodeQueue  	strQueue;
    struct TreeNode* 		pTmpNode = NULL;

    //1.申请空间,并初始化
    pRet = (int**)malloc(sizeof(int*) * MAX_LEVEL);
    memset(pRet, 0x00, sizeof(int*) * MAX_LEVEL);
    pRetCol = (int*)malloc(sizeof(int) * MAX_LEVEL);
    memset(pRetCol, 0x00, sizeof(int) * MAX_LEVEL);
    memset(&amp;strQueue, 0x00, sizeof(struct TreeNodeQueue));

    //2.特殊处理
    if(NULL == root)
    {
        *returnSize = iRetSize;
        *returnColumnSizes = pRetCol;
        return pRet;
    }

    //3.将二叉树根节点加入队列,并且加入空节点作为每层的区分节点
    Push_Queue(&amp;strQueue, root);
    pRet[iRetSize] = (int*)malloc(sizeof(int) * strQueue.iNum);
    Push_Queue(&amp;strQueue, NULL);

    //4.处理队列中的二叉树节点，直到队列为空
    while(strQueue.iNum != 0)
    {
        pTmpNode = Pop_Queue(&amp;strQueue);
        if(NULL == pTmpNode)
        {
            if(0 != strQueue.iNum)
            {
                //6.当前层处理完，进入下一层
                iRetSize += 1;
                pRet[iRetSize] = (int*)malloc(sizeof(int) * strQueue.iNum);

                Push_Queue(&amp;strQueue, NULL);
            }
        }
        else
        {
            //5.处理当前层的节点，分别将左右支压入队列
            pRet[iRetSize][pRetCol[iRetSize]] = pTmpNode-&gt;val;
            pRetCol[iRetSize] += 1;

            if(NULL != pTmpNode-&gt;left)
            {
                Push_Queue(&amp;strQueue, pTmpNode-&gt;left);
            }
            if(NULL != pTmpNode-&gt;right)
            {
                Push_Queue(&amp;strQueue, pTmpNode-&gt;right);
            }
        }
    }

    //7.返回
    *returnSize = iRetSize + 1;
    *returnColumnSizes = pRetCol;
    return pRet;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode链表初等整理]]></title>
        <id>https://lizonglin313.github.io/post/leetcode-lian-biao-chu-deng-zheng-li</id>
        <link href="https://lizonglin313.github.io/post/leetcode-lian-biao-chu-deng-zheng-li">
        </link>
        <updated>2020-05-25T12:39:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>力扣关于链表这部分基础算法还是较为简单和基础的</p>
<p>没有特殊说明的情况下，链表节点类型为：</p>
<pre><code class="language-c">struct ListNode {
    int val;
    struct ListNode *next;
};
</code></pre>
<p>同时，需要注意，默认的头指针<code>head-&gt;val</code>域即第一个元素。</p>
</blockquote>
<h2 id="删除链表中的节点">删除链表中的节点</h2>
<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 -- head = [4,5,1,9]，它可以表示为:</p>
<figure data-type="image" tabindex="1"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png" alt="img" loading="lazy"></figure>
<p><strong>示例 1:</strong></p>
<pre><code>输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
</code></pre>
<p><strong>说明:</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<p><strong>代码</strong>:</p>
<p>这个题目很容易理解偏差。其实就是让你把给你的节点删掉罢了。</p>
<pre><code class="language-c">void deleteNode(struct ListNode* node) {
	node-&gt;val = node-&gt;next-&gt;val;
	node-&gt;next = node-&gt;next-&gt;next;
}
</code></pre>
<h2 id="删除链表的倒数第n个节点">删除链表的倒数第N个节点</h2>
<p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
</code></pre>
<p><strong>说明：</strong></p>
<p>给定的 <em>n</em> 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<p><strong>代码</strong>:</p>
<p>采用快慢指针的思路。设置指针<code>p</code>和<code>q</code>：</p>
<ul>
<li>一开始，<code>p</code>和<code>q</code>都指向头节点；</li>
<li><code>q</code>指针现后移至<code>p</code>指针后的第<code>n</code>个位置，也就是<code>q</code>指针始终比<code>p</code>指针快<code>n</code>个，需要注意如果<code>q</code>还未移动<code>n</code>就已经是<code>NULL</code>了那么删去头节点就结束了；</li>
<li><code>p=p-&gt;next</code>同时<code>q=q-&gt;next</code>直到<code>q-&gt;next==NULL</code>，此时<code>p-&gt;next</code>就是要删除的节点。</li>
</ul>
<pre><code class="language-c">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {

    struct ListNode *p, *q;
	p = head; q = head;

	int i;
	for (i = 0; i &lt; n; i++) {
		if (q-&gt;next == NULL) {
			head = head-&gt;next;
			return head;
		}
		q = q-&gt;next;
	}

	while (q-&gt;next!=NULL) {
		q = q-&gt;next;
		p = p-&gt;next;
	}
    
	p-&gt;next = p-&gt;next-&gt;next;
    
	return head;
}
</code></pre>
<h2 id="反转链表">反转链表</h2>
<p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p><strong>进阶:</strong><br>
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p><strong>代码</strong>:</p>
<p>三指针原地逆转。</p>
<pre><code class="language-c">struct ListNode* reverseList(struct ListNode* head) {
	
	if (head == NULL) return NULL;

	struct ListNode *h,*p,*c;

	h = head;
	p = h-&gt;next;

	// 如果此时只有一个节点
	if (p == NULL) return head;

	c = p-&gt;next;

	// 如果只有两个节点
	if (c == NULL) {
		p-&gt;next = h;
		h-&gt;next = NULL;
		return p;
	}

	// 三节点及以上情况
	while (c != NULL) {
		p-&gt;next = h;
		h = p;
		p = c;
		c = c-&gt;next;
	}
	p-&gt;next = h;
	head-&gt;next = NULL;
	head = p;

	return head;

}
</code></pre>
<h2 id="合并两个有序链表">合并两个有序链表</h2>
<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre>
<p><strong>代码</strong>:</p>
<p>判断大小拆指针重连。</p>
<pre><code class="language-c">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){

    if (l1 == NULL &amp;&amp; l2 == NULL) return NULL;
	if (l1 == NULL &amp;&amp; l2 != NULL) return l2;
	if (l1 != NULL &amp;&amp; l2 == NULL) return l1;
    
   struct ListNode *p1, *p2, *newhead, *q;
	p1 = l1;
	p2 = l2;
	newhead = (l1-&gt;val &lt;= l2-&gt;val) ? l1 : l2;
	q = newhead;

	if (newhead == p1) p1 = p1-&gt;next;
	else p2 = p2-&gt;next;

	while (p1&amp;&amp;p2) {
		if (p1-&gt;val &lt;= p2-&gt;val) {
			q-&gt;next = p1;
			p1 = p1-&gt;next;
			q = q-&gt;next;
		}
		else {
			q-&gt;next = p2;
			p2 = p2-&gt;next;
			q = q-&gt;next;
		}
	}

	if (p1) q-&gt;next = p1;
	if (p2) q-&gt;next = p2;

	return newhead;

}
</code></pre>
<h2 id="回文链表">回文链表</h2>
<p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1-&gt;2
输出: false
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;2-&gt;1
输出: true
</code></pre>
<p><strong>进阶：</strong><br>
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p><strong>代码</strong>:</p>
<p>将链表数值写入数组，然后判断数组是否是回文数组。</p>
<pre><code class="language-c">bool isPalindrome(struct ListNode* head) {

	if (head == NULL || head-&gt;next == NULL) return true;

	// 计算链表长度
	struct ListNode *p = head;
	int len = 0;
	while (p) {
		p = p-&gt;next;
		len++;
	}

	// 将链表复制到数组中
	int *temparr = (int*)malloc(sizeof(int)*len);
	int i = 0;
	for (p = head; i &lt; len; i++) {
		temparr[i] = p-&gt;val;
		p = p-&gt;next;
	}

	// 判断数组
	int q = 0;
	bool ispld = true;
	for (; q &lt; (len - q - 1); q++) {
		if (temparr[q] != temparr[len - q - 1]) {
			ispld = false;
			break;
		}
	}
	return ispld;

}
</code></pre>
<h2 id="环形链表">环形链表</h2>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" loading="lazy"></figure>
<p><strong>示例 2：</strong></p>
<pre><code>输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" loading="lazy"></figure>
<p><strong>示例 3：</strong></p>
<pre><code>输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" loading="lazy"></figure>
<p><strong>进阶：</strong></p>
<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>
<p><strong>代码</strong>:</p>
<p>使用快慢指针。始终有<code>p=p-&gt;next</code>同时<code>q=q-&gt;next-&gt;next</code>，这样可以保证如果链表中有环，指针<code>p</code>和<code>q</code>一定能相遇。</p>
<pre><code class="language-c">bool hasCycle(struct ListNode *head) {

	struct ListNode *p, *q;
	p = head;
	q = head;
	
	if (p == NULL) return false;
	
	while (p!=NULL&amp;&amp;q!=NULL) {
        if(q-&gt;next==NULL)return false;
        if(q-&gt;next-&gt;next==NULL)return false;
		p = p-&gt;next;
		q = q-&gt;next-&gt;next;
		if (p == q) {
			return true;
		}
	}
	return false;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode字符串初等整理]]></title>
        <id>https://lizonglin313.github.io/post/leetcode-zi-fu-chuan-chu-deng-zheng-li</id>
        <link href="https://lizonglin313.github.io/post/leetcode-zi-fu-chuan-chu-deng-zheng-li">
        </link>
        <updated>2020-05-20T13:35:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="反转字符串">反转字符串</h2>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]
</code></pre>
<p><strong>代码</strong>:</p>
<p>思路和翻转整数数组的思路一致，两个指针分别从前后开始扫描，进行交换。</p>
<pre><code class="language-c">void reverseString(char* s, int sSize) {
	// 用反转数组相同的方式
	int i;
	for (i = 0; i &lt; sSize / 2; i++) {
		char temp = s[sSize - 1 - i];
		s[sSize - 1 - i] = s[i];
		s[i] = temp;
	}

}
</code></pre>
<h2 id="整数反转">整数反转</h2>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 123
输出: 321
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: -123
输出: -321
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: 120
输出: 21
</code></pre>
<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">int reverse(int x){
    long count=0;
    while(x!=0){
        // 翻转整数
        count=count*10+x%10;
        x=x/10;
    }
    return count&gt;2147483647||count&lt;-2147483648?0:count;	// 直接给出范围判断是否溢出
}
</code></pre>
<h2 id="字符串中的第一个唯一字符">字符串中的第一个唯一字符</h2>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p><strong>案例:</strong></p>
<pre><code>s = &quot;leetcode&quot;
返回 0.

s = &quot;loveleetcode&quot;,
返回 2.
</code></pre>
<p>**注意事项：**您可以假定该字符串只包含小写字母。</p>
<p><strong>代码</strong>：</p>
<p>本题我用暴力法做的，在时间上不是很理想。</p>
<p>二重循环，外层遍历的元素与内层遍历的除本身外的元素进行比较，<code>find</code>表示是否找到相同的数，<code>find=0</code>就说明第<code>i</code>个元素只有一个，同时置<code>have=1</code>表示存在这样的元素。返回其索引。</p>
<pre><code class="language-c">int firstUniqChar(char * s) {
	// 得到长度
	int len = strlen(s);
	int have = 0;
	int i, j;
	for (i = 0; i &lt; len; i++) {
		int find = 0;
		for (j = 0; j &lt; len; j++) {
			if (i == j) continue;
			if (s[i] == s[j]) {
				find = 1;
				break;
			}
		}
		if (find == 0) {
			have = 1;
			break;
		}
	}
	return have ? i : -1;
}
</code></pre>
<p>另外，其他人用了更好的方法，也就是使用辅助数组，记录每个元素出现的次数，在上一篇数组内容中也出现了这个方法。我想到这个方法时，没有考虑周全，误以为在遍历辅助数组时，只能从<code>i=0 to n</code>遍历，导致不能确定第一个为<code>1</code>就是第一个元素。但是，完全可以按照原数组的元素排列进行遍历，也就是将<code>s[i]-'a'</code>作为遍历指针。</p>
<pre><code class="language-c">int firstUniqChar(char * s){
    int i, len = strlen(s);
    // 构造辅助数组
    int p[26];
    memset(p, 0, sizeof(int) * 26);
   // 首先根据原数组的元素出现情况进行填充
    for(i = 0; i &lt; len; i++){
        p[s[i] - 'a']++;
    }
    // 再由 s[i]-'a' 作为遍历指针遍历辅助数组，寻找第一个只出现一次的元素
    for(i = 0; i &lt; len; i++){
        if(p[s[i] - 'a'] == 1)
            return i;
    }
    return -1;
}
</code></pre>
<h2 id="有效的字母异位词">有效的字母异位词</h2>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: s = &quot;rat&quot;, t = &quot;car&quot;
输出: false
</code></pre>
<p><strong>说明:</strong><br>
你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong><br>
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<p><strong>代码</strong>:</p>
<p>这道题目让我想到了高中化学学的同分异构体，也就是所有对应的字母个数相同，但是排列方式不同。所以本道题采用辅助数组的形式，分别统计字符串<code>s</code>和<code>t</code>中每个字母出现的次数，接着再比较两个辅助数组是否相同即可。</p>
<pre><code class="language-c">bool isAnagram(char * s, char * t) {
	int lens = strlen(s);
	int lent = strlen(t);
	if (lens != lent)return  false;		// 如果长度不相等，之间返回错误

	// 下面用两个辅助数组，分别记录两个字符串中，每个字母出现的次数
	int temps[26], tempt[26];
	memset(temps, 0, sizeof(int) * 26);
	memset(tempt, 0, sizeof(int) * 26);

	// 开始统计数量
	int i;
	for (i = 0; i &lt; lens; i++) {
		temps[s[i] - 'a']++;
		tempt[t[i] - 'a']++;
	}
	// 比较辅助数组
	bool is = true;
	for (i = 0; i &lt; 26; i++) {	// 注意这个数组是26个元素
		if (temps[i] != tempt[i]) {
			is = false;
			break;
		}
	}

	return is;
}
</code></pre>
<h2 id="验证回文字符串">验证回文字符串</h2>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>**说明：**本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;race a car&quot;
输出: false
</code></pre>
<p><strong>代码</strong>:</p>
<ul>
<li>构造函数<code>islod()</code>来判断现读取到的字符是否为字母或者数字；</li>
<li>现对字符串的字母进行大小写统一转换，便于比较，这里全部转为小写字母；</li>
<li>使用双指针分别从头和尾进行遍历，对于既不是数字也不是字母的字符忽略，然后比较两个指针所指元素是否相同。</li>
</ul>
<pre><code class="language-c">bool islod(char c) {
	return	
        ((c &gt;= 'a'&amp;&amp;c &lt;= 'z') || (c &gt;= 'A'&amp;&amp;c &lt;= 'Z') || (c &gt;= '0'&amp;&amp;c &lt;= '9')) ? true : false;
}

bool isPalindrome(char * s) {
    
	int lens = strlen(s);
	bool re = true;

	// 首先进行大小写转化方便判断
	int p;
	for (p = 0; p &lt; lens; p++) 
		if (s[p] &gt;= 'A'&amp;&amp;s[p] &lt;= 'Z') s[p] += 32;

	int f, l;
	for (f = 0, l = lens - 1; f &lt; l; f++, l--) {
		// 首先需要判断是否是有效字符
		while (!islod(s[f]) &amp;&amp; f &lt; l ) f++;	// 循环直到 f 为合法字符
		while (!islod(s[l]) &amp;&amp; f &lt; l ) l--;	// 循环直到 l 为合法字符
        
        // 然后判断一下f l避免越界
		if ( !(f &lt; l) ) break;
        
		// 再进行判断
		if (s[f] != s[l]) {
			re = false;
			break;
		}
	}
	return re;
}

</code></pre>
<h2 id="字符串转换整数atoi">字符串转换整数(atoi)</h2>
<p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>
<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>
<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li>
</ul>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>
<li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;42&quot;
输出: 42
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;   -42&quot;
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: &quot;4193 with words&quot;
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
</code></pre>
<p><strong>示例 4:</strong></p>
<pre><code>输入: &quot;words and 987&quot;
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
</code></pre>
<p><strong>示例 5:</strong></p>
<pre><code>输入: &quot;-91283472332&quot;
输出: -2147483648
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
</code></pre>
<p><strong>代码</strong>:</p>
<p>这个题目写了很久，最后...还是学习学习别人写的吧...这个判断溢出的方法真的很巧妙，在以前都是直接暴力判断溢出的，因为很多题目假设只有32位，所以直接用数判断未免属于不合法的手段。</p>
<pre><code class="language-c">int myAtoi(char * str) {
	// 移除开头的空格
	while (*str == ' ') ++str;  // 此时 str 指向第一个不为空格的字符 

	// 如果带有正负号，记录正负性
	int flag = 1;
	if (*str == '-') {
		flag = -1;
		++str;
	} else if (*str == '+')
		++str;

	int ret = 0;
	// 因为只能使用 32 位 int，因此将 ret 乘 10 后再与 INT_MAX 比较可能会溢出
	// 因此使用 ret 与 INT_MAX/10 比较
	int div = INT_MAX / 10;
	while (*str &lt;= '9' &amp;&amp; *str &gt;= '0') {
		int dig = *str - '0';
		// 若 ret 比 div 小，则 ret * 10 + dig 也一定小于 INT_MAX，不会溢出
		// 若 ret 与 div 相等，只有 dig 比 8 小时不会溢出
		// 此处本来需要正负分开讨论，INT_MAX 个位是 7，INT_MIN 个位是 8
		// -INT_MIN 在 int 中会溢出，当 dig == 8 时直接当作溢出处理
		if (ret &lt; div || (ret == div &amp;&amp; dig &lt; 8)) {
			ret = ret * 10 + dig;
			++str;
		}
		// 溢出，根据正负性返回值
		else
			return (flag == 1 ? INT_MAX : INT_MIN);
	}
	return flag * ret;
}
</code></pre>
<h2 id="实现strstr">实现strStr()</h2>
<p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1
</code></pre>
<p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p>
<p><strong>代码</strong>:</p>
<p>KMP，双100%，永远滴神！我觉得书上讲的都比较含糊，可以找视频来看一下这个算法，主要是求<code>next</code>数组。</p>
<pre><code class="language-c">/* 前缀表  */
void prefix_table(char pattern[], int prefix[], int n) {

	prefix[0] = 0;
	int len = 0;
	int i = 1;

	while (i &lt; n) {
		if (pattern[i] == pattern[len]) {
			len++;
			prefix[i] = len;
			i++;
		}
		else {
			if (len &gt; 0) {
				len = prefix[len - 1];
			}
			else {
				prefix[i] = len;
				i++;
			}
		}
	}
}
/* 左移前缀表 */
void move_prefix_table(int prefix[], int n) {
	int i;
	for (i = n - 1; i &gt; 0; i--) {
		prefix[i] = prefix[i - 1];
	} 
	prefix[0] = -1;
}

/* kmp search */
int kmp_search(char text[], char pattern[]) {
	int n = strlen(pattern);
	int m = strlen(text);
	int *prefix = malloc(sizeof(int)*n);

	prefix_table(pattern, prefix, n);
	move_prefix_table(prefix, n);

	/*
	text[i]		len(text) = m
	pattern[j]	len[pattern] = n
	*/
	int i = 0, j = 0;

	while (i &lt; m) {
		if (j == n - 1 &amp;&amp; text[i] == pattern[j]) {
			/*printf(&quot;%d&quot;, i - j);
			j = prefix[j];*/
			return i - j;
		}
		if (text[i] == pattern[j]) {
			i++;
			j++;
		}
		else {
			j = prefix[j];
			if (j == -1) {
				i++;
				j++;
			}
		}
	}

	return -1;
}

int strStr(char * haystack, char * needle) {

    int lenn = strlen(needle);
	if (lenn == 0) {
		return 0;
	}
    
	return kmp_search(haystack, needle);

}
</code></pre>
<h2 id="外观数列">外观数列</h2>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<pre><code>1.     1
2.     11
3.     21
4.     1211
5.     111221
</code></pre>
<p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br>
<code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br>
<code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  &quot;<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p>
<p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出外观数列的第 <em>n</em> 项。</p>
<p>注意：整数序列中的每一项将表示为一个字符串。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1
输出: &quot;1&quot;
解释：这是一个基本样例。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: 4
输出: &quot;1211&quot;
解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。
</code></pre>
<p><strong>代码</strong>:</p>
<p>这个题目比较有意思。</p>
<p>使用了两个数组，数组<code>res</code>作为结果项和初始项，数组<code>tmp</code>作为对<code>res</code>处理后的进行保存的中间项，然后每一轮结束时，将数组<code>tmp</code>的内容复制到<code>res</code>中，再下一轮以<code>res</code>作为初始串进行处理。</p>
<pre><code class="language-c">char * countAndSay(int n) {
	char *res = (char*)malloc(sizeof(char) * 5000);
	char *tmp = (char*)malloc(sizeof(char) * 5000);
	res[0] = '1'; res[1] = '\0';     // res 初始化为 &quot;1&quot;
	int len = 1;                     // len 为 res 的有效长度
	while (--n) {
		int i = 0, j = 0;
		while (i &lt; len) {             // 对 res 的每位字符 c 进行报数
			int count = 1;
			char c = res[i++];
			while (i &lt; len &amp;&amp; res[i] == c)    // 计算本轮报数结果，即本轮有几个 c
				i++, count++;
			tmp[j++] = count + '0';           // 将报数结果存入 tmp
			tmp[j++] = c;
		}
		tmp[j] = '\0';
		strcpy(res, tmp);                     // 将 tmp 复制到 res，并更新 res 长度
		len = j;
	}
	return res;
}
</code></pre>
<h2 id="最长公共前缀">最长公共前缀</h2>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
</code></pre>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
<p><strong>代码</strong>:</p>
<p>本题使用暴力法，但是由于公共前缀的问题，使用暴力法的时间表现还可以。求最短的元素，以其长度为基准进行搜索。然后双重循环求公共前缀。</p>
<pre><code class="language-c">char * longestCommonPrefix(char ** strs, int strsSize) {

    if(strsSize==0) {
        char *p = &quot;&quot;;
        return p;
    }
    if(strsSize==1) return strs[0];
    
	// 先找出最短的元素
	int minlen = strlen(strs[0]);
	int i;
	for (i = 1; i &lt; strsSize; i++) {
		if (minlen &gt; strlen(strs[i])) {
			minlen = strlen(strs[i]);
		}
	}

	// 循环求解找最长公共前缀
	int front, j;
	bool valid = true;
	for (front = 0; front &lt; minlen; front++) {
		for (j = 0; j &lt; strsSize - 1; j++) {
			if (strs[j][front] != strs[j + 1][front]) {
				valid = false;
				break;
			}
		}
		if (!valid) break;
	}

	// 此时，front为 最长公共前缀的长度,假设最大1000
	char res[1000];
	char *restr = res;
	memset(res, 0, sizeof(res));

	printf(&quot;%d&quot;, strlen(res));
	int k;
	for (k = 0; k &lt; front; k++) {
		res[k] = strs[0][k];
	}

	return restr;
}
</code></pre>
<p>我这样做麻烦了...列垂直扫描不用那么麻烦。唉 <strong>):</strong></p>
<pre><code class="language-c">char * longestCommonPrefix(char ** strs, int strsSize){
    if(strsSize==0) return &quot;&quot;;  //如果字符串数组为空，直接返回&quot;&quot;
    for(int i=0;i&lt;strlen(strs[0]);i++){   //i表示列，strlen(strs[0])表示第一个字符串长度
        for(int j=1;j&lt;strsSize;j++){    //j表示行
            if(strs[0][i]!=strs[j][i]){ //如果比较字符串的第i列不同，该列结束，直接跳出
                strs[0][i]='\0';
                break;
            }
        }
    }
    return strs[0];
}

作者：cmtsa
链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/cchui-zhi-sao-miao-chao-duan-dai-ma-by-cmtsa/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></content>
    </entry>
</feed>