<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lizonglin313.github.io/</id>
    <title>Big Carrot</title>
    <updated>2020-05-29T12:27:02.476Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lizonglin313.github.io/"/>
    <link rel="self" href="https://lizonglin313.github.io/atom.xml"/>
    <subtitle>人们依然相信 什么未来会更精彩</subtitle>
    <logo>https://lizonglin313.github.io/images/avatar.png</logo>
    <icon>https://lizonglin313.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Big Carrot</rights>
    <entry>
        <title type="html"><![CDATA[链式存储二叉树的遍历]]></title>
        <id>https://lizonglin313.github.io/post/lian-shi-cun-chu-er-cha-shu-de-bian-li</id>
        <link href="https://lizonglin313.github.io/post/lian-shi-cun-chu-er-cha-shu-de-bian-li">
        </link>
        <updated>2020-05-29T08:27:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>先序遍历，中序遍历，后序遍历已经层次遍历。</p>
<p>使用递归、队列。</p>
<p>整理自Leetcode。</p>
</blockquote>
<h2 id="说明">说明</h2>
<p>使用到的树结点类型为：</p>
<pre><code class="language-c">struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
};
</code></pre>
<h2 id="先序遍历">先序遍历</h2>
<p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
</code></pre>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">/*求二叉树数据个数，用于动态申请空间*/
int size(struct TreeNode* root)
{
	if (!root) return 0;
	return size(root-&gt;left) + size(root-&gt;right) + 1;	// 递归求二叉树的个数
}
/*递归进行先序遍历*/
void PreOrder(struct TreeNode *root, int *ret, int *retIndex) {
	if (root == NULL) {
		return;
	}
	ret[(*retIndex)++] = root-&gt;val;			// 根
	PreOrder(root-&gt;left, ret, retIndex);	// 左
	PreOrder(root-&gt;right, ret, retIndex);	// 右
}

int* preorderTraversal(struct TreeNode* root, int* returnSize) {

    int treesize = size(root);		// 树结点数量
	int retIndex = 0;				// 数组索引
	int *ret = (int*)malloc(sizeof(int) * treesize);	// 申请空间
	memset(ret, 0, treesize);		// 置零

	PreOrder(root, ret, &amp;retIndex);		// 先序遍历
	*returnSize = retIndex;

	return ret;

}
</code></pre>
<h2 id="中序遍历">中序遍历</h2>
<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
</code></pre>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">int size(struct TreeNode* root)/*求二叉树数据个数*/
{
   if(!root) return 0;
   return size(root-&gt;left)+size(root-&gt;right)+1;
}

void inorder(struct TreeNode* root, int *ret, int* retIndex)/*中序遍历二叉树*/
{
	if (root == NULL) return;

	inorder(root-&gt;left, ret, retIndex);
	ret[(*retIndex)++] = root-&gt;val;
	inorder(root-&gt;right, ret, retIndex);
}

int* inorderTraversal(struct TreeNode* root, int* returnSize) {
    
	int treesize = size(root);
    int retIndex = 0;
	int *ret = (int*)malloc(treesize * sizeof(int));
	memset(ret, 0, treesize);
	
	inorder(root, ret, &amp;retIndex);
    *returnSize = retIndex;
     
    return ret;
}

</code></pre>
<h2 id="后序遍历">后序遍历</h2>
<p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
</code></pre>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">int size(struct TreeNode* root)/*求二叉树数据个数*/
{
   if(!root) return 0;
   return size(root-&gt;left)+size(root-&gt;right)+1;
}

void postorder(struct TreeNode* root, int *ret, int* retIndex)/*中序遍历二叉树*/
{
	if (root == NULL) return;

	postorder(root-&gt;left, ret, retIndex);
	postorder(root-&gt;right, ret, retIndex);
    ret[(*retIndex)++] = root-&gt;val;

}

int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int treesize = size(root);
    int retIndex = 0;
	int *ret = (int*)malloc(treesize * sizeof(int));
	memset(ret, 0, treesize);
	
	postorder(root, ret, &amp;retIndex);
    *returnSize = retIndex;
    return ret;
}
</code></pre>
<h2 id="先序-中序-后序">先序、中序、后序</h2>
<p>显然，对于三种遍历方式，在递归实现中，唯一的不同是递归函数中<code>ret[(*retIndex)++] = root-&gt;val</code>语句的位置:</p>
<pre><code class="language-c">void order(struct TreeNode* root, int *ret, int* retIndex)
{
	if (root == NULL) return;

    //ret[(*retIndex)++] = root-&gt;val;
	postorder(root-&gt;left, ret, retIndex);
	//ret[(*retIndex)++] = root-&gt;val;
    postorder(root-&gt;right, ret, retIndex);
    //ret[(*retIndex)++] = root-&gt;val;

}
</code></pre>
<p>所以，对于三种遍历方式，我们可以统一写为：</p>
<pre><code class="language-c">/*递归求树结点的个数*/
int size(struct TreeNode *root){
    if(!root) return 0;
    return size(root-&gt;left) + size(root-&gt;right) + 1;
}
/**/
void order(struct TreeNode *root, int *ret, int *retIndex, METHOD){
    if(root==NULL) return 0;
    if(METHOD is preorder){
        
        ret[(*resIndex++)] = root-&gt;val;
        order(root-&gt;left, ret, retIndex, METHOD);
        order(root-&gt;right, ret, retIndex, METHOD);
    
    }else if(METHOD is inorder){
    
        order(root-&gt;left, ret, retIndex, METHOD);
        ret[(*resIndex++)] = root-&gt;val;
        order(root-&gt;right, ret, retIndex, METHOD);
    
    }else if(METHOD is lastorder){
    
        order(root-&gt;left, ret, retIndex, METHOD);
        order(root-&gt;right, ret, retIndex, METHOD);
        ret[(*resIndex++)] = root-&gt;val;
    
    }
}

int *orderTraversal(struct TreeNode *root, int *treeSize, METHOD){
    int treesize = size(root);
    int retIndex = 0;
    int *ret = (int*)malloc(sizeof(int)*treesize);
    memset(ret, 0, treesize);
    order(root, ret, &amp;retIndex, METHOD);
    *returnSize = retIndex;
    return ret;
}
</code></pre>
<h2 id="层次遍历">层次遍历</h2>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong><br>
二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回其层次遍历结果：</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre>
<p><strong>代码</strong>:</p>
<blockquote>
<p>作者：r0vHWU5AdJ<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/chun-cchuang-jian-dui-lie-shi-xian-er-cha-shu-de-c/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<pre><code class="language-c">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */

//创建队列
//1,构建队列，实现压入和弹出函数 Push_Queue 和 Pop_Queue
//2,利用队列先进先出的特性实现二叉树的层序遍历
//3,将二叉树根 root 压入队列，并将 NULL 作为每层的区分节点也压入队列
//4,从队列中读出节点，保存当前节点的值，并且将左右支分别压入队列
//5,遇到层的区分节点则处理下一层，直到队列为空

#define     MAX_LEVEL       1000

//声明队列节点结构
struct QueueNode {
    struct TreeNode* pTreeNode;     //队列元素：二叉树节点指针
    struct TreeNodeQueue* pNext;    //队列元素：下一个节点指针
};

//声明队列结构
struct TreeNodeQueue {
    int     iNum;                   //队列元素个数
    struct QueueNode*   pHead;      //队列头指针
    struct QueueNode*   pTail;      //队列尾指针
};

//函数一：向队列中增加元素
bool Push_Queue(struct TreeNodeQueue* pQueue, struct TreeNode* pTreeNode){
    struct QueueNode*   pQueueNode = NULL;

    if(NULL == pQueue) return false;

    pQueueNode = (struct QueueNode*)malloc(sizeof(struct QueueNode));
    pQueueNode-&gt;pTreeNode = pTreeNode;
    pQueueNode-&gt;pNext = NULL;

    if(0 == pQueue-&gt;iNum)
    {
        pQueue-&gt;pHead = pQueueNode;
        pQueue-&gt;pTail = pQueueNode;
        pQueue-&gt;iNum += 1;
    }
    else
    {
        pQueue-&gt;pTail-&gt;pNext = pQueueNode;
        pQueue-&gt;pTail = pQueueNode;
        pQueue-&gt;iNum += 1;
    }

    return true;
}

//函数二：从队列中取出元素
struct TreeNode* Pop_Queue(struct TreeNodeQueue* pQueue){
    struct TreeNode*    pRet    = NULL;
    struct QueueNode*   pTmp    = NULL;

    if((NULL == pQueue) || (0 == pQueue-&gt;iNum)) return NULL;

    pRet = pQueue-&gt;pHead-&gt;pTreeNode;

    pQueue-&gt;iNum -= 1;
    if(0 == pQueue-&gt;iNum)
    {
        free(pQueue-&gt;pHead);
        pQueue-&gt;pHead = NULL;
        pQueue-&gt;pTail = NULL;
    }
    else
    {
        pTmp = pQueue-&gt;pHead-&gt;pNext;
        free(pQueue-&gt;pHead);
        pQueue-&gt;pHead = pTmp;
    }
    
    return pRet;
}

int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    int         iNum        = 0;
    int         iRetSize    = 0;
    int**       pRet        = NULL;
    int*        pRetCol     = NULL;
    
    struct TreeNodeQueue  	strQueue;
    struct TreeNode* 		pTmpNode = NULL;

    //1.申请空间,并初始化
    pRet = (int**)malloc(sizeof(int*) * MAX_LEVEL);
    memset(pRet, 0x00, sizeof(int*) * MAX_LEVEL);
    pRetCol = (int*)malloc(sizeof(int) * MAX_LEVEL);
    memset(pRetCol, 0x00, sizeof(int) * MAX_LEVEL);
    memset(&amp;strQueue, 0x00, sizeof(struct TreeNodeQueue));

    //2.特殊处理
    if(NULL == root)
    {
        *returnSize = iRetSize;
        *returnColumnSizes = pRetCol;
        return pRet;
    }

    //3.将二叉树根节点加入队列,并且加入空节点作为每层的区分节点
    Push_Queue(&amp;strQueue, root);
    pRet[iRetSize] = (int*)malloc(sizeof(int) * strQueue.iNum);
    Push_Queue(&amp;strQueue, NULL);

    //4.处理队列中的二叉树节点，直到队列为空
    while(strQueue.iNum != 0)
    {
        pTmpNode = Pop_Queue(&amp;strQueue);
        if(NULL == pTmpNode)
        {
            if(0 != strQueue.iNum)
            {
                //6.当前层处理完，进入下一层
                iRetSize += 1;
                pRet[iRetSize] = (int*)malloc(sizeof(int) * strQueue.iNum);

                Push_Queue(&amp;strQueue, NULL);
            }
        }
        else
        {
            //5.处理当前层的节点，分别将左右支压入队列
            pRet[iRetSize][pRetCol[iRetSize]] = pTmpNode-&gt;val;
            pRetCol[iRetSize] += 1;

            if(NULL != pTmpNode-&gt;left)
            {
                Push_Queue(&amp;strQueue, pTmpNode-&gt;left);
            }
            if(NULL != pTmpNode-&gt;right)
            {
                Push_Queue(&amp;strQueue, pTmpNode-&gt;right);
            }
        }
    }

    //7.返回
    *returnSize = iRetSize + 1;
    *returnColumnSizes = pRetCol;
    return pRet;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode链表初等整理]]></title>
        <id>https://lizonglin313.github.io/post/leetcode-lian-biao-chu-deng-zheng-li</id>
        <link href="https://lizonglin313.github.io/post/leetcode-lian-biao-chu-deng-zheng-li">
        </link>
        <updated>2020-05-25T12:39:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>力扣关于链表这部分基础算法还是较为简单和基础的</p>
<p>没有特殊说明的情况下，链表节点类型为：</p>
<pre><code class="language-c">struct ListNode {
    int val;
    struct ListNode *next;
};
</code></pre>
<p>同时，需要注意，默认的头指针<code>head-&gt;val</code>域即第一个元素。</p>
</blockquote>
<h2 id="删除链表中的节点">删除链表中的节点</h2>
<p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 -- head = [4,5,1,9]，它可以表示为:</p>
<figure data-type="image" tabindex="1"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png" alt="img" loading="lazy"></figure>
<p><strong>示例 1:</strong></p>
<pre><code>输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
</code></pre>
<p><strong>说明:</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<p><strong>代码</strong>:</p>
<p>这个题目很容易理解偏差。其实就是让你把给你的节点删掉罢了。</p>
<pre><code class="language-c">void deleteNode(struct ListNode* node) {
	node-&gt;val = node-&gt;next-&gt;val;
	node-&gt;next = node-&gt;next-&gt;next;
}
</code></pre>
<h2 id="删除链表的倒数第n个节点">删除链表的倒数第N个节点</h2>
<p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
</code></pre>
<p><strong>说明：</strong></p>
<p>给定的 <em>n</em> 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<p><strong>代码</strong>:</p>
<p>采用快慢指针的思路。设置指针<code>p</code>和<code>q</code>：</p>
<ul>
<li>一开始，<code>p</code>和<code>q</code>都指向头节点；</li>
<li><code>q</code>指针现后移至<code>p</code>指针后的第<code>n</code>个位置，也就是<code>q</code>指针始终比<code>p</code>指针快<code>n</code>个，需要注意如果<code>q</code>还未移动<code>n</code>就已经是<code>NULL</code>了那么删去头节点就结束了；</li>
<li><code>p=p-&gt;next</code>同时<code>q=q-&gt;next</code>直到<code>q-&gt;next==NULL</code>，此时<code>p-&gt;next</code>就是要删除的节点。</li>
</ul>
<pre><code class="language-c">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {

    struct ListNode *p, *q;
	p = head; q = head;

	int i;
	for (i = 0; i &lt; n; i++) {
		if (q-&gt;next == NULL) {
			head = head-&gt;next;
			return head;
		}
		q = q-&gt;next;
	}

	while (q-&gt;next!=NULL) {
		q = q-&gt;next;
		p = p-&gt;next;
	}
    
	p-&gt;next = p-&gt;next-&gt;next;
    
	return head;
}
</code></pre>
<h2 id="反转链表">反转链表</h2>
<p>反转一个单链表。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p><strong>进阶:</strong><br>
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p><strong>代码</strong>:</p>
<p>三指针原地逆转。</p>
<pre><code class="language-c">struct ListNode* reverseList(struct ListNode* head) {
	
	if (head == NULL) return NULL;

	struct ListNode *h,*p,*c;

	h = head;
	p = h-&gt;next;

	// 如果此时只有一个节点
	if (p == NULL) return head;

	c = p-&gt;next;

	// 如果只有两个节点
	if (c == NULL) {
		p-&gt;next = h;
		h-&gt;next = NULL;
		return p;
	}

	// 三节点及以上情况
	while (c != NULL) {
		p-&gt;next = h;
		h = p;
		p = c;
		c = c-&gt;next;
	}
	p-&gt;next = h;
	head-&gt;next = NULL;
	head = p;

	return head;

}
</code></pre>
<h2 id="合并两个有序链表">合并两个有序链表</h2>
<p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre>
<p><strong>代码</strong>:</p>
<p>判断大小拆指针重连。</p>
<pre><code class="language-c">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){

    if (l1 == NULL &amp;&amp; l2 == NULL) return NULL;
	if (l1 == NULL &amp;&amp; l2 != NULL) return l2;
	if (l1 != NULL &amp;&amp; l2 == NULL) return l1;
    
   struct ListNode *p1, *p2, *newhead, *q;
	p1 = l1;
	p2 = l2;
	newhead = (l1-&gt;val &lt;= l2-&gt;val) ? l1 : l2;
	q = newhead;

	if (newhead == p1) p1 = p1-&gt;next;
	else p2 = p2-&gt;next;

	while (p1&amp;&amp;p2) {
		if (p1-&gt;val &lt;= p2-&gt;val) {
			q-&gt;next = p1;
			p1 = p1-&gt;next;
			q = q-&gt;next;
		}
		else {
			q-&gt;next = p2;
			p2 = p2-&gt;next;
			q = q-&gt;next;
		}
	}

	if (p1) q-&gt;next = p1;
	if (p2) q-&gt;next = p2;

	return newhead;

}
</code></pre>
<h2 id="回文链表">回文链表</h2>
<p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1-&gt;2
输出: false
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;2-&gt;1
输出: true
</code></pre>
<p><strong>进阶：</strong><br>
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p><strong>代码</strong>:</p>
<p>将链表数值写入数组，然后判断数组是否是回文数组。</p>
<pre><code class="language-c">bool isPalindrome(struct ListNode* head) {

	if (head == NULL || head-&gt;next == NULL) return true;

	// 计算链表长度
	struct ListNode *p = head;
	int len = 0;
	while (p) {
		p = p-&gt;next;
		len++;
	}

	// 将链表复制到数组中
	int *temparr = (int*)malloc(sizeof(int)*len);
	int i = 0;
	for (p = head; i &lt; len; i++) {
		temparr[i] = p-&gt;val;
		p = p-&gt;next;
	}

	// 判断数组
	int q = 0;
	bool ispld = true;
	for (; q &lt; (len - q - 1); q++) {
		if (temparr[q] != temparr[len - q - 1]) {
			ispld = false;
			break;
		}
	}
	return ispld;

}
</code></pre>
<h2 id="环形链表">环形链表</h2>
<p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img" loading="lazy"></figure>
<p><strong>示例 2：</strong></p>
<pre><code>输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img" loading="lazy"></figure>
<p><strong>示例 3：</strong></p>
<pre><code>输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img" loading="lazy"></figure>
<p><strong>进阶：</strong></p>
<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>
<p><strong>代码</strong>:</p>
<p>使用快慢指针。始终有<code>p=p-&gt;next</code>同时<code>q=q-&gt;next-&gt;next</code>，这样可以保证如果链表中有环，指针<code>p</code>和<code>q</code>一定能相遇。</p>
<pre><code class="language-c">bool hasCycle(struct ListNode *head) {

	struct ListNode *p, *q;
	p = head;
	q = head;
	
	if (p == NULL) return false;
	
	while (p!=NULL&amp;&amp;q!=NULL) {
        if(q-&gt;next==NULL)return false;
        if(q-&gt;next-&gt;next==NULL)return false;
		p = p-&gt;next;
		q = q-&gt;next-&gt;next;
		if (p == q) {
			return true;
		}
	}
	return false;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode字符串初等整理]]></title>
        <id>https://lizonglin313.github.io/post/leetcode-zi-fu-chuan-chu-deng-zheng-li</id>
        <link href="https://lizonglin313.github.io/post/leetcode-zi-fu-chuan-chu-deng-zheng-li">
        </link>
        <updated>2020-05-20T13:35:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="反转字符串">反转字符串</h2>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
</code></pre>
<p><strong>示例 2：</strong></p>
<pre><code>输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]
</code></pre>
<p><strong>代码</strong>:</p>
<p>思路和翻转整数数组的思路一致，两个指针分别从前后开始扫描，进行交换。</p>
<pre><code class="language-c">void reverseString(char* s, int sSize) {
	// 用反转数组相同的方式
	int i;
	for (i = 0; i &lt; sSize / 2; i++) {
		char temp = s[sSize - 1 - i];
		s[sSize - 1 - i] = s[i];
		s[i] = temp;
	}

}
</code></pre>
<h2 id="整数反转">整数反转</h2>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 123
输出: 321
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: -123
输出: -321
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: 120
输出: 21
</code></pre>
<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p><strong>代码</strong>:</p>
<pre><code class="language-c">int reverse(int x){
    long count=0;
    while(x!=0){
        // 翻转整数
        count=count*10+x%10;
        x=x/10;
    }
    return count&gt;2147483647||count&lt;-2147483648?0:count;	// 直接给出范围判断是否溢出
}
</code></pre>
<h2 id="字符串中的第一个唯一字符">字符串中的第一个唯一字符</h2>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p><strong>案例:</strong></p>
<pre><code>s = &quot;leetcode&quot;
返回 0.

s = &quot;loveleetcode&quot;,
返回 2.
</code></pre>
<p>**注意事项：**您可以假定该字符串只包含小写字母。</p>
<p><strong>代码</strong>：</p>
<p>本题我用暴力法做的，在时间上不是很理想。</p>
<p>二重循环，外层遍历的元素与内层遍历的除本身外的元素进行比较，<code>find</code>表示是否找到相同的数，<code>find=0</code>就说明第<code>i</code>个元素只有一个，同时置<code>have=1</code>表示存在这样的元素。返回其索引。</p>
<pre><code class="language-c">int firstUniqChar(char * s) {
	// 得到长度
	int len = strlen(s);
	int have = 0;
	int i, j;
	for (i = 0; i &lt; len; i++) {
		int find = 0;
		for (j = 0; j &lt; len; j++) {
			if (i == j) continue;
			if (s[i] == s[j]) {
				find = 1;
				break;
			}
		}
		if (find == 0) {
			have = 1;
			break;
		}
	}
	return have ? i : -1;
}
</code></pre>
<p>另外，其他人用了更好的方法，也就是使用辅助数组，记录每个元素出现的次数，在上一篇数组内容中也出现了这个方法。我想到这个方法时，没有考虑周全，误以为在遍历辅助数组时，只能从<code>i=0 to n</code>遍历，导致不能确定第一个为<code>1</code>就是第一个元素。但是，完全可以按照原数组的元素排列进行遍历，也就是将<code>s[i]-'a'</code>作为遍历指针。</p>
<pre><code class="language-c">int firstUniqChar(char * s){
    int i, len = strlen(s);
    // 构造辅助数组
    int p[26];
    memset(p, 0, sizeof(int) * 26);
   // 首先根据原数组的元素出现情况进行填充
    for(i = 0; i &lt; len; i++){
        p[s[i] - 'a']++;
    }
    // 再由 s[i]-'a' 作为遍历指针遍历辅助数组，寻找第一个只出现一次的元素
    for(i = 0; i &lt; len; i++){
        if(p[s[i] - 'a'] == 1)
            return i;
    }
    return -1;
}
</code></pre>
<h2 id="有效的字母异位词">有效的字母异位词</h2>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: s = &quot;rat&quot;, t = &quot;car&quot;
输出: false
</code></pre>
<p><strong>说明:</strong><br>
你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong><br>
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<p><strong>代码</strong>:</p>
<p>这道题目让我想到了高中化学学的同分异构体，也就是所有对应的字母个数相同，但是排列方式不同。所以本道题采用辅助数组的形式，分别统计字符串<code>s</code>和<code>t</code>中每个字母出现的次数，接着再比较两个辅助数组是否相同即可。</p>
<pre><code class="language-c">bool isAnagram(char * s, char * t) {
	int lens = strlen(s);
	int lent = strlen(t);
	if (lens != lent)return  false;		// 如果长度不相等，之间返回错误

	// 下面用两个辅助数组，分别记录两个字符串中，每个字母出现的次数
	int temps[26], tempt[26];
	memset(temps, 0, sizeof(int) * 26);
	memset(tempt, 0, sizeof(int) * 26);

	// 开始统计数量
	int i;
	for (i = 0; i &lt; lens; i++) {
		temps[s[i] - 'a']++;
		tempt[t[i] - 'a']++;
	}
	// 比较辅助数组
	bool is = true;
	for (i = 0; i &lt; 26; i++) {	// 注意这个数组是26个元素
		if (temps[i] != tempt[i]) {
			is = false;
			break;
		}
	}

	return is;
}
</code></pre>
<h2 id="验证回文字符串">验证回文字符串</h2>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>**说明：**本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;race a car&quot;
输出: false
</code></pre>
<p><strong>代码</strong>:</p>
<ul>
<li>构造函数<code>islod()</code>来判断现读取到的字符是否为字母或者数字；</li>
<li>现对字符串的字母进行大小写统一转换，便于比较，这里全部转为小写字母；</li>
<li>使用双指针分别从头和尾进行遍历，对于既不是数字也不是字母的字符忽略，然后比较两个指针所指元素是否相同。</li>
</ul>
<pre><code class="language-c">bool islod(char c) {
	return	
        ((c &gt;= 'a'&amp;&amp;c &lt;= 'z') || (c &gt;= 'A'&amp;&amp;c &lt;= 'Z') || (c &gt;= '0'&amp;&amp;c &lt;= '9')) ? true : false;
}

bool isPalindrome(char * s) {
    
	int lens = strlen(s);
	bool re = true;

	// 首先进行大小写转化方便判断
	int p;
	for (p = 0; p &lt; lens; p++) 
		if (s[p] &gt;= 'A'&amp;&amp;s[p] &lt;= 'Z') s[p] += 32;

	int f, l;
	for (f = 0, l = lens - 1; f &lt; l; f++, l--) {
		// 首先需要判断是否是有效字符
		while (!islod(s[f]) &amp;&amp; f &lt; l ) f++;	// 循环直到 f 为合法字符
		while (!islod(s[l]) &amp;&amp; f &lt; l ) l--;	// 循环直到 l 为合法字符
        
        // 然后判断一下f l避免越界
		if ( !(f &lt; l) ) break;
        
		// 再进行判断
		if (s[f] != s[l]) {
			re = false;
			break;
		}
	}
	return re;
}

</code></pre>
<h2 id="字符串转换整数atoi">字符串转换整数(atoi)</h2>
<p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<ul>
<li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li>
<li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li>
<li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li>
</ul>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>
<li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;42&quot;
输出: 42
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;   -42&quot;
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: &quot;4193 with words&quot;
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
</code></pre>
<p><strong>示例 4:</strong></p>
<pre><code>输入: &quot;words and 987&quot;
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
</code></pre>
<p><strong>示例 5:</strong></p>
<pre><code>输入: &quot;-91283472332&quot;
输出: -2147483648
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
</code></pre>
<p><strong>代码</strong>:</p>
<p>这个题目写了很久，最后...还是学习学习别人写的吧...这个判断溢出的方法真的很巧妙，在以前都是直接暴力判断溢出的，因为很多题目假设只有32位，所以直接用数判断未免属于不合法的手段。</p>
<pre><code class="language-c">int myAtoi(char * str) {
	// 移除开头的空格
	while (*str == ' ') ++str;  // 此时 str 指向第一个不为空格的字符 

	// 如果带有正负号，记录正负性
	int flag = 1;
	if (*str == '-') {
		flag = -1;
		++str;
	} else if (*str == '+')
		++str;

	int ret = 0;
	// 因为只能使用 32 位 int，因此将 ret 乘 10 后再与 INT_MAX 比较可能会溢出
	// 因此使用 ret 与 INT_MAX/10 比较
	int div = INT_MAX / 10;
	while (*str &lt;= '9' &amp;&amp; *str &gt;= '0') {
		int dig = *str - '0';
		// 若 ret 比 div 小，则 ret * 10 + dig 也一定小于 INT_MAX，不会溢出
		// 若 ret 与 div 相等，只有 dig 比 8 小时不会溢出
		// 此处本来需要正负分开讨论，INT_MAX 个位是 7，INT_MIN 个位是 8
		// -INT_MIN 在 int 中会溢出，当 dig == 8 时直接当作溢出处理
		if (ret &lt; div || (ret == div &amp;&amp; dig &lt; 8)) {
			ret = ret * 10 + dig;
			++str;
		}
		// 溢出，根据正负性返回值
		else
			return (flag == 1 ? INT_MAX : INT_MIN);
	}
	return flag * ret;
}
</code></pre>
<h2 id="实现strstr">实现strStr()</h2>
<p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1
</code></pre>
<p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p>
<p><strong>代码</strong>:</p>
<p>KMP，双100%，永远滴神！我觉得书上讲的都比较含糊，可以找视频来看一下这个算法，主要是求<code>next</code>数组。</p>
<pre><code class="language-c">/* 前缀表  */
void prefix_table(char pattern[], int prefix[], int n) {

	prefix[0] = 0;
	int len = 0;
	int i = 1;

	while (i &lt; n) {
		if (pattern[i] == pattern[len]) {
			len++;
			prefix[i] = len;
			i++;
		}
		else {
			if (len &gt; 0) {
				len = prefix[len - 1];
			}
			else {
				prefix[i] = len;
				i++;
			}
		}
	}
}
/* 左移前缀表 */
void move_prefix_table(int prefix[], int n) {
	int i;
	for (i = n - 1; i &gt; 0; i--) {
		prefix[i] = prefix[i - 1];
	} 
	prefix[0] = -1;
}

/* kmp search */
int kmp_search(char text[], char pattern[]) {
	int n = strlen(pattern);
	int m = strlen(text);
	int *prefix = malloc(sizeof(int)*n);

	prefix_table(pattern, prefix, n);
	move_prefix_table(prefix, n);

	/*
	text[i]		len(text) = m
	pattern[j]	len[pattern] = n
	*/
	int i = 0, j = 0;

	while (i &lt; m) {
		if (j == n - 1 &amp;&amp; text[i] == pattern[j]) {
			/*printf(&quot;%d&quot;, i - j);
			j = prefix[j];*/
			return i - j;
		}
		if (text[i] == pattern[j]) {
			i++;
			j++;
		}
		else {
			j = prefix[j];
			if (j == -1) {
				i++;
				j++;
			}
		}
	}

	return -1;
}

int strStr(char * haystack, char * needle) {

    int lenn = strlen(needle);
	if (lenn == 0) {
		return 0;
	}
    
	return kmp_search(haystack, needle);

}
</code></pre>
<h2 id="外观数列">外观数列</h2>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<pre><code>1.     1
2.     11
3.     21
4.     1211
5.     111221
</code></pre>
<p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br>
<code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br>
<code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  &quot;<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p>
<p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出外观数列的第 <em>n</em> 项。</p>
<p>注意：整数序列中的每一项将表示为一个字符串。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1
输出: &quot;1&quot;
解释：这是一个基本样例。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: 4
输出: &quot;1211&quot;
解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。
</code></pre>
<p><strong>代码</strong>:</p>
<p>这个题目比较有意思。</p>
<p>使用了两个数组，数组<code>res</code>作为结果项和初始项，数组<code>tmp</code>作为对<code>res</code>处理后的进行保存的中间项，然后每一轮结束时，将数组<code>tmp</code>的内容复制到<code>res</code>中，再下一轮以<code>res</code>作为初始串进行处理。</p>
<pre><code class="language-c">char * countAndSay(int n) {
	char *res = (char*)malloc(sizeof(char) * 5000);
	char *tmp = (char*)malloc(sizeof(char) * 5000);
	res[0] = '1'; res[1] = '\0';     // res 初始化为 &quot;1&quot;
	int len = 1;                     // len 为 res 的有效长度
	while (--n) {
		int i = 0, j = 0;
		while (i &lt; len) {             // 对 res 的每位字符 c 进行报数
			int count = 1;
			char c = res[i++];
			while (i &lt; len &amp;&amp; res[i] == c)    // 计算本轮报数结果，即本轮有几个 c
				i++, count++;
			tmp[j++] = count + '0';           // 将报数结果存入 tmp
			tmp[j++] = c;
		}
		tmp[j] = '\0';
		strcpy(res, tmp);                     // 将 tmp 复制到 res，并更新 res 长度
		len = j;
	}
	return res;
}
</code></pre>
<h2 id="最长公共前缀">最长公共前缀</h2>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
</code></pre>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
<p><strong>代码</strong>:</p>
<p>本题使用暴力法，但是由于公共前缀的问题，使用暴力法的时间表现还可以。求最短的元素，以其长度为基准进行搜索。然后双重循环求公共前缀。</p>
<pre><code class="language-c">char * longestCommonPrefix(char ** strs, int strsSize) {

    if(strsSize==0) {
        char *p = &quot;&quot;;
        return p;
    }
    if(strsSize==1) return strs[0];
    
	// 先找出最短的元素
	int minlen = strlen(strs[0]);
	int i;
	for (i = 1; i &lt; strsSize; i++) {
		if (minlen &gt; strlen(strs[i])) {
			minlen = strlen(strs[i]);
		}
	}

	// 循环求解找最长公共前缀
	int front, j;
	bool valid = true;
	for (front = 0; front &lt; minlen; front++) {
		for (j = 0; j &lt; strsSize - 1; j++) {
			if (strs[j][front] != strs[j + 1][front]) {
				valid = false;
				break;
			}
		}
		if (!valid) break;
	}

	// 此时，front为 最长公共前缀的长度,假设最大1000
	char res[1000];
	char *restr = res;
	memset(res, 0, sizeof(res));

	printf(&quot;%d&quot;, strlen(res));
	int k;
	for (k = 0; k &lt; front; k++) {
		res[k] = strs[0][k];
	}

	return restr;
}
</code></pre>
<p>我这样做麻烦了...列垂直扫描不用那么麻烦。唉 <strong>):</strong></p>
<pre><code class="language-c">char * longestCommonPrefix(char ** strs, int strsSize){
    if(strsSize==0) return &quot;&quot;;  //如果字符串数组为空，直接返回&quot;&quot;
    for(int i=0;i&lt;strlen(strs[0]);i++){   //i表示列，strlen(strs[0])表示第一个字符串长度
        for(int j=1;j&lt;strsSize;j++){    //j表示行
            if(strs[0][i]!=strs[j][i]){ //如果比较字符串的第i列不同，该列结束，直接跳出
                strs[0][i]='\0';
                break;
            }
        }
    }
    return strs[0];
}

作者：cmtsa
链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/cchui-zhi-sao-miao-chao-duan-dai-ma-by-cmtsa/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2001-2005英语一阅读整理]]></title>
        <id>https://lizonglin313.github.io/post/2001-2005-ying-yu-yi-yue-du-zheng-li</id>
        <link href="https://lizonglin313.github.io/post/2001-2005-ying-yu-yi-yue-du-zheng-li">
        </link>
        <updated>2020-05-12T07:53:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="感悟">感悟</h2>
<p>我是通读全文之后，再读题做题目的，答题时会再一次翻过去寻找相关语句，每一篇用时在17、8分钟左右。几乎10篇有7篇错2个，1篇错3个，2篇错1个，不理想。</p>
<p>首要问题是单词，看到单词知道大概的意思，但是不能准确的说明白，联系上下文后也能知道大概的意思。但是会因为一些词语不认识，而判断错作者的主观情感，导致出现失误。</p>
<p>第二，除一些答案实在不能说服我的(只有一两道题)，其他的错误一是由于单词不认识，猜错了意思，二是由于看到不够仔细，漏掉了细节而放大了次要的要素，三是主观臆断，老美的思维有些时候怪怪的，你和他谈吸烟有害健康，他给你来个自由被侵犯...</p>
<h2 id="后续">后续</h2>
<ul>
<li>单词，还得继续</li>
<li>重复读做过的原文，仔细分析每道题目对应的语句</li>
<li>对于做过的文章，掌握里面俗语的用法、熟词辟意</li>
<li>体会作者主观情感</li>
<li>梳理篇章脉络结构</li>
</ul>
<blockquote>
<p>害！写了这么多单词突然想到没啥意义！就这样吧</p>
</blockquote>
<h2 id="单词">单词</h2>
<h3 id="2001">2001</h3>
<h4 id="t1">T1</h4>
<table>
<thead>
<tr>
<th style="text-align:left">specialisation</th>
<th style="text-align:left">refer</th>
<th style="text-align:left">whereas  然而；鉴于</th>
<th>underway  开始；在进行中</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">professionalisation</td>
<td style="text-align:left">delay</td>
<td style="text-align:left">reckon</td>
<td>nevertheless   然而；不过</td>
</tr>
<tr>
<td style="text-align:left">connotation</td>
<td style="text-align:left">integrate</td>
<td style="text-align:left">in terms of</td>
<td>primacy</td>
</tr>
<tr>
<td style="text-align:left">in one's own right</td>
<td style="text-align:left">incorporate</td>
<td style="text-align:left">over result</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="t2">T2</h4>
<table>
<thead>
<tr>
<th>digital divide</th>
<th>division</th>
<th>lecture</th>
<th>looming danger</th>
</tr>
</thead>
<tbody>
<tr>
<td>visible</td>
<td>force</td>
<td>narrow</td>
<td>in the interest of</td>
</tr>
<tr>
<td>universalize</td>
<td>spread</td>
<td>net</td>
<td>in the years ahead</td>
</tr>
<tr>
<td>combat</td>
<td>enormous</td>
<td>with respect to  至于；关于</td>
<td>sovereignty</td>
</tr>
<tr>
<td>capital</td>
<td>former</td>
<td>guess</td>
<td>lying down</td>
</tr>
<tr>
<td>telecom</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="t3">T3</h4>
<table>
<thead>
<tr>
<th>distrust</th>
<th>credibility</th>
<th>head-scratching</th>
<th>in the world  到底；究竟</th>
</tr>
</thead>
<tbody>
<tr>
<td>go way deeper</td>
<td>plug into</td>
<td>conventional  惯用的</td>
<td>reportorial  报道的；记者的</td>
</tr>
<tr>
<td>ready-made</td>
<td>otherwise  否则；另外</td>
<td>replie</td>
<td>upscale</td>
</tr>
<tr>
<td>church</td>
<td>put down root in  扎根于</td>
<td>astonishing</td>
<td>inaccuracy</td>
</tr>
<tr>
<td>explosive situation</td>
<td>vastly</td>
<td>symposium  研讨会</td>
<td>get around to  抽时间做；开始考虑做</td>
</tr>
<tr>
<td>diversity</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="t4">T4</h4>
<table>
<thead>
<tr>
<th>merger</th>
<th>acquisition</th>
<th>sweep</th>
<th>hyperactive</th>
</tr>
</thead>
<tbody>
<tr>
<td>reach</td>
<td>unsurpassed</td>
<td>multinational</td>
<td>affiliate</td>
</tr>
<tr>
<td>ultimate</td>
<td>underlie</td>
<td>detrimental</td>
<td>scanty</td>
</tr>
<tr>
<td>threat</td>
<td>lender</td>
<td>gigantic</td>
<td>infringement</td>
</tr>
<tr>
<td>take upon itself  擅自做主</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="t5">T5</h4>
<table>
<thead>
<tr>
<th>occur</th>
<th>lateral</th>
<th>prompt</th>
<th>abandon</th>
</tr>
</thead>
<tbody>
<tr>
<td>relatively</td>
<td>high profile</td>
<td>disgrace  耻辱n,v；失势的a</td>
<td>downshifting</td>
</tr>
<tr>
<td>tried excuse  老掉牙的接口</td>
<td>passionate</td>
<td>advocate</td>
<td>preach</td>
</tr>
<tr>
<td>resignation</td>
<td>doctrine</td>
<td>juggle</td>
<td>materialistic</td>
</tr>
<tr>
<td>ironically</td>
<td>newsletter</td>
<td>cling-film</td>
<td>drop out</td>
</tr>
<tr>
<td>decline</td>
<td>redundancy</td>
<td>thrift</td>
<td>mythic</td>
</tr>
<tr>
<td>well-established</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="2002">2002</h3>
<h4 id="t1-2">T1</h4>
<table>
<thead>
<tr>
<th>intend</th>
<th>identify</th>
<th>relevant</th>
<th>in sympathy with</th>
</tr>
</thead>
<tbody>
<tr>
<td>address</td>
<td>disorganized</td>
<td>secretary  秘书</td>
<td>alternatively  再者；或者</td>
</tr>
<tr>
<td>convention</td>
<td>be shown around</td>
<td>push aside</td>
<td>stomp</td>
</tr>
<tr>
<td>appropriate</td>
<td>make a passing remark  顺便提及</td>
<td>inedible</td>
<td>notorious</td>
</tr>
<tr>
<td>resent</td>
<td>stick to  调侃</td>
<td>scapegoat</td>
<td>awkward</td>
</tr>
<tr>
<td>apparently</td>
<td>off-the-cuff</td>
<td>unforced  自然的</td>
<td>delivery</td>
</tr>
<tr>
<td>light-hearted  轻松的；无忧无虑的</td>
<td>unexpected  意外</td>
<td>twist</td>
<td>a familiar quote</td>
</tr>
<tr>
<td>quote</td>
<td>exaggeration 夸大其词</td>
<td>understatement  轻描淡写</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="t2-2">T2</h4>
<table>
<thead>
<tr>
<th>dawn</th>
<th>ingenuity  心灵手巧；独创性</th>
<th>devise</th>
<th>cunning  巧妙的；狡猾的</th>
</tr>
</thead>
<tbody>
<tr>
<td>cope with  应对</td>
<td>burdensome  难以承担的a</td>
<td>plain nasty 非常肮脏的</td>
<td>compulsion 强制</td>
</tr>
<tr>
<td>robotic</td>
<td>confer on  授予</td>
<td>gizmo 装置；小玩意</td>
<td>hum</td>
</tr>
<tr>
<td>assembly  装配n；集合n</td>
<td>teller</td>
<td>mechanical</td>
<td>politeness</td>
</tr>
<tr>
<td>tireless 不知疲倦</td>
<td>miniaturization</td>
<td>surgery</td>
<td>submillimeter</td>
</tr>
<tr>
<td>accuracy</td>
<td>precision</td>
<td>physician</td>
<td>laborsaving utility</td>
</tr>
<tr>
<td>supervision</td>
<td>dynamic</td>
<td>perception</td>
<td>glimpse</td>
</tr>
<tr>
<td>disregard</td>
<td>irrelevant</td>
<td>suspicious</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="t3-2">T3</h4>
<table>
<thead>
<tr>
<th>supply-cut 供应减少</th>
<th>scary</th>
<th>double-digital  两位数的</th>
<th>inflation  通货膨胀</th>
</tr>
</thead>
<tbody>
<tr>
<td>gloom and doom 厄运</td>
<td>suspend</td>
<td>strengthen</td>
<td>winter grip 寒冬席卷</td>
</tr>
<tr>
<td>sever</td>
<td>retail</td>
<td>muted effect  暗中影响</td>
<td>pump prices 价格波动</td>
</tr>
<tr>
<td>swing</td>
<td>conservation</td>
<td>consultancy</td>
<td>estimate</td>
</tr>
<tr>
<td>seriously squeeze  严厉打击</td>
<td>excess demand 需求过剩</td>
<td>sizable portion 一定数量的地区</td>
<td>emerge from 从...中出现；摆脱</td>
</tr>
<tr>
<td>index 指数；索引</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="t4-2">T4</h4>
<table>
<thead>
<tr>
<th style="text-align:left">dying patient  临终患者</th>
<th>constitutional right  宪法权利</th>
<th>morphine</th>
<th>dosage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">contend</td>
<td>insist</td>
<td>maintain 坚持说/认为</td>
<td>legitimate</td>
</tr>
<tr>
<td style="text-align:left">homicide</td>
<td>physical agony 生理痛苦</td>
<td>release</td>
<td>undertreatment 治疗不利</td>
</tr>
<tr>
<td style="text-align:left">aggressive</td>
<td>ineffectual</td>
<td>dishonor</td>
<td>hospice</td>
</tr>
<tr>
<td style="text-align:left">assess</td>
<td>initiative</td>
<td>unconcerned 无动于衷的</td>
<td>needlessly 非必须的</td>
</tr>
<tr>
<td style="text-align:left">predictable  可预见的</td>
<td>systematic</td>
<td>presumptively 假设地；据推测</td>
<td>incompetently 不胜任；无能力</td>
</tr>
<tr>
<td style="text-align:left">license suspension 吊销执照</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode数组初等整理]]></title>
        <id>https://lizonglin313.github.io/post/leetcode-shu-zu-chu-deng-zheng-li</id>
        <link href="https://lizonglin313.github.io/post/leetcode-shu-zu-chu-deng-zheng-li">
        </link>
        <updated>2020-05-11T11:48:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>好久没有更新了，最近开始做了些leetcode上的算法，刚把数组基础部分做完，整理一下，全部用的C</p>
</blockquote>
<h2 id="删除排序数组中的重复项">删除排序数组中的重复项</h2>
<p>给定一个排序数组，你需要在 <strong>原地</strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地 修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<pre><code>给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre>
<p><strong>代码</strong>:</p>
<p>快慢双指针的思想，快指针从下标<code>1</code>处开始遍历数组，而慢指针始终指向<code>没有重复元素的前last+1项序列</code>的最后一个元素。</p>
<pre><code class="language-c">int removeDuplicates(int* nums, int numsSize){
	int fast, last;	// 双指针

    if(numsSize==0){
        return 0;
    }
    
	for (last=0,fast = 1; fast &lt; numsSize; fast++){

		if (nums[last] != nums[fast]) {
            /* 如果指的元素不同，就将fast所指的元素给last所指的后一个元素，当然，需要last事先增一 */
			nums[++last] = nums[fast];
		}

	}

	return last + 1;
}

</code></pre>
<h2 id="买卖股票的最佳时机-ii">买卖股票的最佳时机 II</h2>
<p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
</code></pre>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li>
</ul>
<p><strong>代码</strong>:</p>
<p>在做这道题目时，我进入了一个误区，就是老想着找这样一个子序列：<code>子序列最后一个元素 - 子序列第一个元素的值最大</code>。例如：<code>[6 3 4 1 2 3 4 5 6]</code>中<code>sub[1 2 3 4 5 6]</code>这个序列，我们只要确定<code>1</code>和<code>6</code>的位置就能得到结果。显然我想复杂了，这个结果<code>6-1=5</code>实际上与<code>2-1 + 3-2 + 4-3 + 5-4 + 6-5 = 5</code>是一样的。</p>
<p>所以，我们只需每次找相邻的两个数，这两个数符合前一个数比后一个数小即可，符合就计算<code>last-front</code>的值，加到利润里，继续考察下一组数就可以。</p>
<pre><code class="language-c">int maxProfit(int* prices, int pricesSize) {

    /* 不要忘记特殊情况 */
	if (pricesSize &lt; 2) {
		return 0;
	}

	int td_price = prices[0];	// td_price为当天价格，从第 prices[0]开始
	int pro = 0;				// 初始利润设置为 pro=0

	for (int i = 1; i &lt; pricesSize; i++)
	{
        /* 从第二天开始，如果明天的价格高于今天，就买，利润增加 */
		if (prices[i] &gt; td_price) {
			pro += (prices[i] - td_price);
		}
        /* 过一天，明天变今天 */
		td_price = prices[i];

	}
	return pro;
}
</code></pre>
<h2 id="旋转数组">旋转数组</h2>
<p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
</code></pre>
<p><strong>说明:</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li>
</ul>
<p><strong>代码</strong>:</p>
<p>我认为这道题目的一个解法是非常巧妙的，利用三次逆序，我是没有想到....</p>
<p>例如示例1中输入 <code>[1,2,3,4,5,6,7]</code> 和<code>k = 3</code>输出<code>[5,6,7,1,2,3,4]</code>。只需要先对前<code>7-3=4</code>个数进行逆序得到<code>[4,3,2,1,5,6,7]</code>再对后<code>k=3</code>个数进行逆序得到<code>[4,3,2,1,7,6,5]</code>，最后再对整个数组进行逆序<code>[5,6,7,1,2,3,4]</code>就得到结果了。</p>
<pre><code class="language-c">/* 逆序函数，注意下标的操作 */
void reverse(int *arr, int left, int right) {

	for (int i = 0; i &lt; (right - left + 1) / 2; i++)
	{
		int temp = arr[right - i];
		arr[right - i] = arr[left + i];
		arr[left + i] = temp;
	}

}
/* 进行旋转 */
void rotate(int* nums, int numsSize, int k) {

    // 注意特殊情况的处理
	if (numsSize == 0 || !nums) {
		return;
	}

    // 以防循环次数 &gt; numsSize
     k = k % numsSize;
    
	reverse(nums, 0, numsSize - k - 1);
	reverse(nums, numsSize - k, numsSize - 1);
	reverse(nums, 0, numsSize - 1);
}
</code></pre>
<h2 id="存在重复元素">存在重复元素</h2>
<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [1,2,3,1]
输出: true
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: [1,2,3,4]
输出: false
</code></pre>
<p><strong>示例 3:</strong></p>
<pre><code>输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
</code></pre>
<p><strong>代码</strong>:</p>
<p>这道题目一开始构造Map来遍历统计每个值出现的次数，但是(我觉得)没有必要(对于C这种没有Map结构的来说)。就采取了先排序，后验证是否有相邻元素相同的方法来判断。</p>
<p>一开始我是用了快排，结果一直超时，于是改成了归并。</p>
<pre><code class="language-c">#define MAX 1000000
int temp_arr[MAX] = { 0 };

/* merge two arr */
void merge(int begin, int middle, int end, int arr1[], int arr2[]);
/* sort arr with merge sort */
void merge_sort(int arr[], int begin, int end);

bool containsDuplicate(int* nums, int numsSize) {

	if (numsSize &lt;= 1) return false;	// 注意特殊情况
	
	merge_sort(nums, 0, numsSize - 1);	// 先进行排序

	for (int i = 0; i &lt; numsSize - 1; i++) {
		if (nums[i] == nums[i+1]) {
			return true;
		}
	}
	return false;
}

/* merge two arr */
void merge(int begin, int middle, int end, int arr1[], int arr2[]) {

	int i = begin;
	int j = middle + 1;
	int k = begin;

	while (i &lt;= middle &amp;&amp; j &lt;= end) {
		if (arr1[i] &lt;= arr1[j]) {

			arr2[k++] = arr1[i++];

		}
		else
		{
			arr2[k++] = arr1[j++];
		}
	}

	while (i &lt;= middle)	arr2[k++] = arr1[i++];
	while (j &lt;= end)	arr2[k++] = arr1[j++];

}

/* sort arr with merge sort */
void merge_sort(int arr[], int begin, int end) {

	int m;

	if (begin == end) {

		return;	// if begin==end -&gt; arr has one number,over

	}
	else {

		m = (begin + end) / 2;
		merge_sort(arr, begin, m);		// sorted front part of arr
		merge_sort(arr, m + 1, end);	// sorted latter part of arr 
		merge(begin, m, end, arr, temp_arr);	//merge arr
		for (int i = begin; i &lt;= end; i++) {
			arr[i] = temp_arr[i];
		}
	}
}


</code></pre>
<h2 id="只出现一次的数字">只出现一次的数字</h2>
<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [2,2,1]
输出: 1
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: [4,1,2,1,2]
输出: 4
</code></pre>
<p><strong>代码</strong>:</p>
<p>同样的，我也采用了先排序，后判断一个数的<code>前后元素</code>是否等于这个数的方法。由于归并排序上一题中已经给出，便不再叙述详细实现过程。</p>
<pre><code class="language-c">int singleNumber(int* nums, int numsSize) {

    // 特殊情况的处理
	if (numsSize == 1)
	{
		return nums[0];
	}

	// 先排序
	merge_sort(nums, 0, numsSize - 1);

    // 首末元素不好判断，就先进行判断
	if (nums[0] != nums[1] &amp;&amp; nums[1]==nums[2]) {
		return nums[0];
	}
	else if (nums[numsSize-1] != nums[numsSize-2]) {
		return nums[numsSize - 1];
	}

	// 在这之前先判断第一个数和最后一个数
	for (int i = 1; i &lt; numsSize - 1; i++)
	{
        // 判断前后元素是否等于这个数
		if (nums[i] != nums[i - 1] &amp;&amp; nums[i] != nums[i + 1]) {
			return nums[i];
		}

	}
    
    // 如果此处没有返回，会报错，便随便加上一句，理论上不会走到这里
    return -1;
	
}
</code></pre>
<h2 id="两个数组的交集">两个数组的交集</h2>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]
</code></pre>
<p><strong>说明：</strong></p>
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<p><strong>进阶:</strong></p>
<ul>
<li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li>
<li>如果 <em>nums1</em> 的大小比 <em>nums2</em> 小很多，哪种方法更优？</li>
<li>如果 <em>nums2</em> 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li>
</ul>
<p><strong>代码</strong>:</p>
<p>进阶部分尚未考虑。</p>
<p>在这里，我用到了双重循环，所以在效率上不是很理想。</p>
<ul>
<li>首先以<code>nums1</code>的长度为基准，构造新的结果数组<code>numret</code>；</li>
<li>遍历<code>nums1</code>数组，<code>i</code>为遍历指针；
<ul>
<li>判断<code>nums1</code>、<code>nums2</code>、<code>numret</code>中元素<code>nums1[i]的</code>个数，分别存入<code>n1</code>、<code>n2</code>、<code>n3</code>；</li>
<li>如果<code>n3=0</code>代表结果数组中还没有这个元素，于是判断<code>n1</code>、<code>n2</code>，以小的那一个作为存入的次数，存入<code>numret</code>中即可；</li>
<li>当然，如果<code>n3!=0</code>就说明我们在前面已经找过这个元素了，也就是我们只在首次遇到这个元素时就把它后面也出现的情况处理了</li>
</ul>
</li>
</ul>
<pre><code class="language-c">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

/* 判断元素在数组中出现几次 */
int If_In_Array(int number, int numsSize, int *nums) ；

int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {

	/* 以nums1的长度构建数组 */
	int *numret = (int*)malloc(sizeof(int)*nums1Size);

	int i3 = 0;	// i3作为结果数组的下标，刚好可以统计结果数组中元素的个数

	for (int i1 = 0; i1 &lt; nums1Size; i1++)
	{
		int n1 = 0, n2 = 0, n3 = 0;
		n1 = If_In_Array(nums1[i1], nums1Size, nums1);
		n2 = If_In_Array(nums1[i1], nums2Size, nums2);
		n3 = If_In_Array(nums1[i1], i3, numret);

		if (n3 == 0) {
			if (n1 == n2) for (int p = 0; p &lt; n1; p++) numret[i3++] = nums1[i1];
			else if (n1 &gt; n2) for (int p = 0; p &lt; n2; p++) numret[i3++] = nums1[i1];
			else if (n1 &lt; n2)for (int p = 0; p &lt; n1; p++) numret[i3++] = nums1[i1];
		}
	}

	*returnSize = i3;

	return numret;

}
/* 判断元素在数组中出现几次 */
int If_In_Array(int number, int numsSize, int *nums) {

	int count = 0;

	for (int i = 0; i &lt; numsSize; i++)
	{
		if (nums[i] == number) count++;
	}

	return count;

}
</code></pre>
<h2 id="加一">加一</h2>
<p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
</code></pre>
<p><strong>代码</strong>:</p>
<p>我犯了一个大错误：一开始我想将数组内容先转换成整数类型，然后整数加一，再进行拆分重新存入数组。结果发生了溢出，于是我改成<code>long</code>甚至<code>long long</code>，无一例外，它还是溢出了，谁能保证这个数组长度没有10k位呢，计算机怎么存一个10k位的数值类型？</p>
<p>还是直接操作数组吧：</p>
<ul>
<li>注意判断数组元素是否全是<code>9</code>，例如<code>[9,9,9,9]</code>在申请结果数组时需要多申请一个位置，而<code>[8,9,9,9]</code>就不需要(这一步可不用一开始就进行)；</li>
<li>首先，对于首位进位有两种情况，需要先处理一下，一是全是<code>9</code>，二是除了首元素之外全是<code>9</code>；</li>
<li>如果全是<code>9</code>申请长一个单位的数组，首位置<code>1</code>，剩余填<code>0</code>，完成；</li>
<li>如果除首位全是<code>9</code>，申请通长度数组，首位加<code>1</code>，其余位填<code>0</code>，完成；</li>
<li>剩下的情况就是一般情况了，从数组末位开始向前遍历，只要遇到一位不是<code>9</code>就加<code>1</code>退出循环，完成，否则遇到<code>9</code>就置零，进行下一次循环。</li>
</ul>
<pre><code class="language-c">int* plusOne(int* digits, int digitsSize, int* returnSize) {

	//  基本思路 逢 9 进一 不为9 +1 然后结束

	// 1 先判断是否全为9 分两种情况 1）全为9 2） 第一位不是9
	int is9 = 1;
	for (int i = 1; i &lt; digitsSize; i++) 
		if (digits[i] != 9) {
			is9 = 0;
			break;
		}
	if (is9 == 1) {
		if (digits[0] == 9) {
			// 如果第一位也是9
			// 此时全为9
			int *redigits = (int*)malloc(sizeof(int)*(digitsSize + 1));
			redigits[0] = 1;
			for (int i = 1; i &lt; digitsSize + 1; i++)
			{
				redigits[i] = 0;
			}
			*returnSize = digitsSize + 1;
			return redigits;
		}
		else{
			// 此时第一位不是9
			int *redigits = (int*)malloc(sizeof(int)*(digitsSize));
			redigits[0] = digits[0] + 1;
			for (int i = 1; i &lt; digitsSize; i++)
			{
				redigits[i] = 0;
			}
			*returnSize = digitsSize;
			return redigits;
		}
		
	}

	// 如果有一位不是9
	int *redigits = (int*)malloc(sizeof(int)*(digitsSize));
	redigits = digits;
	/*for (int n = 0; n &lt; digitsSize; n++) {
		redigits[n] = digits[n];

	}*/
	for (int p = digitsSize - 1; p &gt; -1; p--) {
		if (redigits[p] == 9) {
			redigits[p] = 0;
            continue;
		}
		if (redigits[p] != 9) {
			redigits[p] = redigits[p] + 1;
            break;
		}
	}
	*returnSize = digitsSize;
	return redigits;
}
</code></pre>
<h2 id="移动零">移动零</h2>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
</code></pre>
<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
<p><strong>代码</strong>:</p>
<p>使用的是数组题目中常用的快慢指针，慢指针始终指向数组中第一个<code>0</code>，快指针作为遍历指针，如果快指针指的元素不为<code>0</code>那么交换两个指针所指的元素，慢指针增一。</p>
<pre><code class="language-c">void moveZeroes(int* nums, int numsSize) {
	int k = 0;
	for (int i = 0; i &lt; numsSize; i++)
	{
		if (nums[i] != 0) {
            int t = nums[k];
			nums[k++] = nums[i];
			nums[i] = t;
		}
	}
}
</code></pre>
<h2 id="两数之和">两数之和</h2>
<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<p><strong>代码</strong>:</p>
<p>emmmm这个做的时候没多想暴力做的，二重循环...</p>
<pre><code class="language-c">/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
	/* 先处理一下特殊情况 */
    if (numsSize == 0) {
		*returnSize = 0;
		return NULL;
	}
	else if (numsSize == 1) {
		int *ret1 = (int*)malloc(sizeof(int) * 1);
		ret1[0] = 0;
		*returnSize = 1;
		return ret1;
	}
    
	int *ret = (int*)malloc(sizeof(int) * 2);
    
	for (int i = 0; i &lt; numsSize; i++)
	{
		for (int j = 0; j &lt; numsSize; j++) {
	
			if (i == j) continue;
			else{
				if (nums[i] + nums[j] == target) {
					ret[0] = i;
					ret[1] = j;
				}
			}
		}
	}
	*returnSize = 2;
	return ret;
}
</code></pre>
<p>这个题有好多佬用hash table做的，时间上很快。</p>
<h2 id="有效的数独">有效的数独</h2>
<blockquote>
<p>到这里多少做的不是很顺了，总是少考虑东西</p>
</blockquote>
<p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img" loading="lazy"></figure>
<p>上图是一个部分填充的有效的数独。</p>
<p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入:
[
  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: true
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>输入:
[
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
</code></pre>
<p><strong>说明:</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>'.'</code> 。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
<p><strong>代码</strong>:</p>
<ul>
<li>对于判断一行/列中是否存在相同元素，构造辅助二维数组，只不过二维数组每一行每一个元素代表原数组中这一行中的元素出现的次数，举个例子吧，原数组第一行<code>[1，2，.，.，4，.，4，.，.]</code>这样，那么辅助数组这样<code>[0，1，1，0，2，...]</code>没错，下标为<code>4</code>的位置为<code>2</code>，也就是<code>4</code>出现了两次，对于列，同理；</li>
<li>如何判断<code>3x3</code>的子块中有重复元素呢？也用一个二维数组，公式<code>(i / 3) * 3 + (j / 3)</code>巧妙的把位于同一个子块的元素的二维值转化为统一的一维值，也就是说，例如左上角<code>(0,0)(0,1)(0,2)(1,0)(1,1)(1,2)(2,0)(2,1)(2,2)</code>都转化成<code>0</code>了，就作为辅助数组的行下标，列下标同样的用原数组的元素值代表。</li>
</ul>
<pre><code class="language-c">bool isValidSudoku(char** board, int boardSize, int* boardColSize) {

	int row[9][10] = { 0 };
	int arr[9][10] = { 0 };
	int box[9][10] = { 0 };

	for (int i = 0; i &lt; 9; i++) {
		for (int j = 0; j &lt; 9; j++) {
			if (board[i][j] != '.') {
				int num = board[i][j] - '0';		// 得到此数字对应的整数值
				row[i][num]++;						// 代表 在第i行 数字 num 出现次数 +1
				arr[j][num]++;						// 代表 在第j列 数字 num 出现次数 +1
				box[(i / 3) * 3 + (j / 3)][num]++;	// 代表 在第(i / 3) * 3 + (j / 3)个小九宫格中 数字 num 出现次数 +1
				if ((row[i][num] &gt; 1) || (arr[j][num] &gt; 1) || (box[(i / 3) * 3 + (j / 3)][num] &gt; 1)) {	
					return false;
				}
			}
		}
	}
	return true;
}
</code></pre>
<h2 id="旋转图像">旋转图像</h2>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>说明：</strong></p>
<p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1:</strong></p>
<pre><code>给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
</code></pre>
<p><strong>示例 2:</strong></p>
<pre><code>给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</code></pre>
<p><strong>代码</strong>:</p>
<p>这里对操作二重指针和二维数组出现了迷糊，C的指针稍稍操作复杂一些还是好难懂...</p>
<p>我认为很巧妙的方法，对矩阵进行行变换，然后再进行转置(先进行转置，再对矩阵进行列变换也可以得到一样的结果)，没有仔细的观察、并且对矩阵不敏感的情况下很难发现这个规律。</p>
<p>进行矩阵转置是要注意下标的处理，在进行行变换时巧妙的运用一级指针(如果进行列变换就没有这么容易了，所以说先进行行变换再进行转置是相对比较方便的)。</p>
<pre><code class="language-c">void rotate(int** matrix, int matrixSize, int* matrixColSize) {

	// 先变换行，因为每一行可以作为一整块，在存储操作上比较方便
	for (int i = 0, j = matrixSize - 1; i &lt; j; ++i, --j)   /* 将矩阵的第i行和第j行互换 */
		swap_row(matrix, matrixSize, i, j);

	// 再对矩阵进行转置
	transposed_matrix(matrix, matrixSize);
	
}

/* 求转置矩阵 */
void transposed_matrix(int **matrix, int matrixSize) {

	for (int i = 0; i &lt; matrixSize; i++) {
		for (int j = i; j &lt; matrixSize; j++) {
			int temp = matrix[i][j];
			matrix[i][j] = matrix[j][i];
			matrix[j][i] = temp;
		}
	}
}

/* 将矩阵第i行和第size-i行互换 */
void swap_row(int **matrix, int matrixSize, int i, int j) {

	// 申请存储单元，方便按行存储，只需交换指针，即可每次操作改变一行
	int *t = (int*)malloc(sizeof(int)*matrixSize);
	t = matrix[i];
	matrix[i] = matrix[j];
	matrix[j] = t;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高数第一章 函数、极限、连续]]></title>
        <id>https://lizonglin313.github.io/post/高数第一章函数极限连续</id>
        <link href="https://lizonglin313.github.io/post/高数第一章函数极限连续">
        </link>
        <updated>2020-03-06T13:49:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一节-函数">第一节 函数</h2>
<h3 id="考试内容概要">考试内容概要</h3>
<h4 id="一-函数的概念及常见函数">一、函数的概念及常见函数</h4>
<ol>
<li>函数概念</li>
<li>复合函数</li>
<li>反函数</li>
<li>初等函数</li>
</ol>
<h4 id="二-函数的性质">二、函数的性质</h4>
<ol>
<li>单调性</li>
<li>奇偶性</li>
<li>周期性</li>
<li>有界性</li>
</ol>
<h3 id="常考题型">常考题型</h3>
<h4 id="一-函数有界性-单调性-周期性及奇偶性的判定">一、函数有界性、单调性、周期性及奇偶性的判定</h4>
<h4 id="二-复合函数">二、复合函数</h4>
<h2 id="第二节-极限">第二节 极限</h2>
<h3 id="考试内容概要-2">考试内容概要</h3>
<h4 id="一-极限的概念">一、极限的概念</h4>
<ol>
<li>数列的极限</li>
<li>函数的极限
<ul>
<li>自变量趋于无穷大时函数的极限</li>
<li>自变量趋于有限值时函数的极限</li>
</ul>
</li>
</ol>
<h4 id="二-极限的性质">二、极限的性质</h4>
<ol>
<li>有界性
<ul>
<li>数列</li>
<li>函数</li>
</ul>
</li>
<li>保号性
<ul>
<li>数列</li>
<li>函数</li>
</ul>
</li>
<li>极限与无穷小之间的关系</li>
</ol>
<h4 id="三-极限的存在准则">三、极限的存在准则</h4>
<ol>
<li>夹逼准则</li>
<li>单调有界准则</li>
</ol>
<h4 id="四-无穷小量">四、无穷小量</h4>
<ol>
<li>无穷小量的概念</li>
<li>无穷小的比较</li>
<li>无穷小的性质</li>
</ol>
<h4 id="五-无穷大量">五、无穷大量</h4>
<ol>
<li>无穷大量的概念</li>
<li>常用的一些无穷大量的比较</li>
<li>无穷大量的性质</li>
<li>无穷大量与无界变量的关系</li>
<li>无穷大量与无穷小量的关系</li>
</ol>
<h3 id="常考题型-2">常考题型</h3>
<h4 id="一-极限的概念-性质及存在准则">一、极限的概念、性质及存在准则</h4>
<h4 id="二-求极限">二、求极限</h4>
<p>常用的8种求极限的方法</p>
<ul>
<li>
<p>方法1 利用基本极限求极限</p>
<ol>
<li>常用的基本极限</li>
<li>$ 1^{无穷} $型极限常用结论</li>
</ol>
</li>
<li>
<p>方法2 利用等价无穷小代换求极限</p>
<ol>
<li>
<p>代换原则</p>
<p>1)乘除可换</p>
<p>2)加减在一定关系下可以换(相减不正、相加不负)</p>
</li>
<li>
<p>常用的等价无穷小</p>
</li>
</ol>
</li>
<li>
<p>方法3 利用有理运算法则求极限</p>
</li>
<li>
<p>方法4 利用洛必达法则求极限</p>
</li>
<li>
<p>方法5 利用泰勒公式求极限</p>
</li>
<li>
<p>方法6 利用夹逼原理求极限</p>
</li>
<li>
<p>方法7 利用单调有界准则求极限</p>
</li>
<li>
<p>方法8 利用定积分定义求极限</p>
</li>
</ul>
<h4 id="三-无穷小量阶的比较">三、无穷小量阶的比较</h4>
<h2 id="第三节-函数的连续性">第三节 函数的连续性</h2>
<h3 id="考试内容概要-3">考试内容概要</h3>
<h4 id="一-连续性的概念">一、连续性的概念</h4>
<h4 id="二-间断点及其分类">二、间断点及其分类</h4>
<ol>
<li>间断点的定义</li>
<li>间断点的分类</li>
</ol>
<h4 id="三-连续性的运算与性质">三、连续性的运算与性质</h4>
<h4 id="四-闭区间上连续函数的性质">四、闭区间上连续函数的性质</h4>
<ul>
<li>最值定理</li>
<li>有界性定理</li>
<li>介值定理</li>
<li>零点定理</li>
</ul>
<h3 id="常考题型-3">常考题型</h3>
<h4 id="一-讨论函数的连续性及间断点类型">一、讨论函数的连续性及间断点类型</h4>
<h4 id="二-有关闭区间上连续函数性质的证明题">二、有关闭区间上连续函数性质的证明题</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode线性问题合辑（数组、链表、栈、队列）]]></title>
        <id>https://lizonglin313.github.io/post/leetcode-lian-biao-he-ji</id>
        <link href="https://lizonglin313.github.io/post/leetcode-lian-biao-he-ji">
        </link>
        <updated>2020-02-22T13:39:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="leetcode001-两数之和">leetcode001-两数之和</h2>
<h3 id="题目重述">题目重述</h3>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<h3 id="题解">题解</h3>
<blockquote>
<p>程序员小吴(C++) Karl Xavier(Go)</p>
</blockquote>
<h5 id="c版本思路及代码">C++版本思路及代码</h5>
<p>设置一个<code>map</code>容器和<code>record</code>用来记录元素的值与索引，然后遍历数组<code>nums</code>。</p>
<ul>
<li>每次遍历中使用临时变量<code>complement</code>用来保存目标值与当前值的差值</li>
<li>在此次遍历中查找<code>record</code>，查看是否有与<code>complement</code>一致的值，如果查找成功则返回查找值的索引与当前<code>nums</code>中变量值的索引<code>i</code></li>
<li>如果未找到，则在<code>record</code>中保存该元素与索引值<code>i</code></li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
using namespace std;

class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;nums, int target) {
        unordered_map&lt;int, int&gt; record;
        for (int i = 0; i &lt; nums.size(); ++i) {
            int complement = target - nums[i];
            if (record.find(complement) != record.end()) {  // 如果在 map 里没有查找到，就返回 end()
                int res[] = {i, record[complement]};
                cout &lt;&lt; res &lt;&lt; endl;
                cout &lt;&lt; res + 2 &lt;&lt; endl;
                return vector&lt;int&gt;(res, res + 2);
            }
            record[nums[i]] = i;    // 查到了， 将原数组值变为其下标
        }
        return vector&lt;int&gt;();
    }
};

// [2,7,11,15]
// 9
int main() {
    vector&lt;int&gt; nums = {2, 7, 11, 15};
    vector&lt;int&gt; res;
    int target = 9;
    Solution s = *new Solution();
    res = s.twoSum(nums, target);
    for (int i = 0; i &lt; res.size(); ++i) {
        cout &lt;&lt; res[i] &lt;&lt; endl;
    }
}


</code></pre>
<h5 id="go版本思路及代码">Go版本思路及代码</h5>
<ul>
<li>创建<code>map</code>映射<code>v</code>，存放目标数组的相关信息</li>
<li>遍历目标数组，并获取目标值<code>target</code>与数组元素<code>nums[i]</code>的差值<code>dif</code></li>
<li>将差值<code>dif</code>作为<code>map</code>中的<code>key</code>，目标数组<code>nums</code>的索引作为<code>map</code>中的<code>value</code></li>
<li>判断<code>map</code>中是否包含差值<code>dif</code>，如果包含则返回对应的<code>value</code></li>
<li>如果<code>map</code>中没有，则把其放到<code>map</code>中</li>
</ul>
<pre><code class="language-go">package main
import &quot;fmt&quot;

func twoSum(nums []int, target int) []int {
	v := make(map[int]int)
	for i := 0; i &lt; len(nums); i++ {
		dif := target - nums[i]
		c, ok := v[dif]
		if ok != false {
			return []int{c, i}
		}
		v[nums[i]] = i
	}
	return []int{-1, -1}
}
// [2,7,11,15]
// 9
func main() {
	target := 9
	nums := []int{2, 7, 11, 15}
	fmt.Print(twoSum(nums, target))
    
}
</code></pre>
<h2 id="leetcode002-两数相加">leetcode002-两数相加</h2>
<h3 id="题目重述-2">题目重述</h3>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807
</code></pre>
<h3 id="题解-2">题解</h3>
<blockquote>
<p>陈乐乐(c++) dp0qb(go)</p>
</blockquote>
<h5 id="c版本思路及代码-2">C++版本思路及代码</h5>
<p>将长度较短的链表在末尾补<code>0</code>使得两个链表长度相等，然后再一个一个元素对其相加，需要注意的是要考虑进位。</p>
<ul>
<li>获取两个链表的长度</li>
<li>较短的链表末尾补零</li>
<li>对齐相加，注意考虑进位</li>
</ul>
<pre><code class="language-c++">struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}    // 定义链表的构造方法
};
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        int len1 = 1;   // 记录L1的长度
        int len2 = 1;   // 记录L2的长度
        ListNode *p = l1;
        ListNode *q = l2;
        while (p-&gt;next != NULL) {
            // 获取 L1 的长度
            len1++;
            p = p-&gt;next;
        }
        while (q-&gt;next != NULL) {
            // 获取 L2 的长度
            len2++;
            q = q-&gt;next;
        }
        if (len1 &gt; len2) {
            // 如果 L1 比 L2 长，在 L2 末尾补零
            for (int i = 0; i &lt;= len1 - len2; ++i) {
                q-&gt;next = new ListNode(0);
                q = q-&gt;next;
            }
        } else {
            // L2 长 就在 L1 后面补 0
            for (int i = 0; i &lt;= len2 - len1; ++i) {
                p-&gt;next = new ListNode(0);
                p = p-&gt;next;
            }
        }
        p = l1;
        q = l2;
        bool count = false;     // 记录进位
        ListNode *l3 = new ListNode(-1);    // 结果链表
        ListNode *w = l3;       // L3 的移动指针
        int i = 0;                // 记录相加结果
        while (p != NULL &amp;&amp; q != NULL) {
            i = count + p-&gt;val + q-&gt;val;
            w-&gt;next = new ListNode(i % 10);
            count = i &gt;= 10 ? true : false;
            w = w-&gt;next;
            p = p-&gt;next;
            q = q-&gt;next;
        }
        if (count) {
            // 如果最后还有进位
            w-&gt;next = new ListNode(1);
            w = w-&gt;next;
        }
        return l3-&gt;next;    // L3 头为 -1
    }
};
</code></pre>
<h5 id="go版本思路及代码-2">Go版本思路及代码</h5>
<ul>
<li>依次正常遍历链表，按照对应位两数相加，如果超过<code>10</code>，则取结果的个位数，下一位加<code>1</code></li>
<li>如果一个链表比另一个链表短，那么长的链表就直接加<code>0</code></li>
<li>如果最后一位相加之和大于<code>10</code>，那么最后不要忘记加上一个<code>1</code>结点</li>
</ul>
<pre><code class="language-go">/**  Definition for singly-linked list.  **/
type ListNode struct {
	Val  int
	Next *ListNode
}
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	var i, s int             // 分别表示 相加是否大于10 ，以及 两数之和
	res := &amp;ListNode{Val: 0} // 头结点
	now := res               // 当前节点
	for true {
		if i &gt; 0 {
			// 前面两数之和大于10，当前的和加 1
			s = l1.Val + l2.Val + 1
		} else {
			s = l1.Val + l2.Val
		}
		if s &gt;= 10 {
			// 两数之和大于10 该位 s-10 否则就是 本身，并设置 i标记
			now.Next = &amp;ListNode{Val: s - 10}
			i = 1
		} else {
			now.Next = &amp;ListNode{Val: s}
			i = 0
		}
		now = now.Next
		// 当 l1 和 l2 移到最后
		if l1.Next == nil &amp;&amp; l2.Next == nil {
			// 如果 l1 l2 最后的和大于10 即i==1 那么后面还需要加一个 1
			if i == 1 {
				now.Next = &amp;ListNode{Val: 1}
			}
			break;
		}
		// l1 到最后 如果是 l2 没结束，把 l1 当前结点设置为0 继续和 l2 相加，否则后移指针
		if l1.Next == nil {
			l1.Val = 0
		} else {
			l1 = l1.Next
		}
		// 同理 对 l2 有
		if l2.Next == nil {
			l2.Val = 0
		} else {
			l2 = l2.Next
		}
	}
	// 返回头结点的下一个结点指针
	return res.Next
}
</code></pre>
<h2 id="leetcode020-有效的括号">leetcode020-有效的括号</h2>
<h3 id="题目重述-3">题目重述</h3>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>
左括号必须以正确的顺序闭合。<br>
注意空字符串可被认为是有效字符串。</p>
<pre><code>示例 1:
输入: &quot;()&quot;
输出: true

示例 2:
输入: &quot;()[]{}&quot;
输出: true

示例 3:
输入: &quot;(]&quot;
输出: false

示例 4:
输入: &quot;([)]&quot;
输出: false

示例 5:
输入: &quot;{[]}&quot;
输出: true
</code></pre>
<h3 id="题解-3">题解</h3>
<blockquote>
<p>c***6(c++) chris(go)</p>
</blockquote>
<h5 id="c版本思路及代码-3">C++版本思路及代码</h5>
<ul>
<li>使用<code>vector</code>来模拟栈</li>
<li>每次取前半括号包括<code>(</code>、<code>[</code>、<code>{</code>都将其入栈</li>
<li>如果取到的是后半括号<code>)</code>、<code>]</code>、<code>}</code>就与取栈顶元素进行匹配，如果匹配就进行出栈操作，不匹配就返回错误</li>
</ul>
<pre><code class="language-c++">class Solution {
public:
    bool isValid(string s) {
        int len = s.length();
        int tmp;
        // 用 vector 模拟栈
        vector&lt;char&gt; hp;
        for (int i = 0; i &lt; len; i++) {
            // 入栈
            if (s[i] == '(' || s[i] == '[' || s[i] == '{')
                hp.push_back(s[i]);	// 进栈
            else {
                // 栈空
                if (hp.size() == 0)return false;
                // 取栈顶元素，注意这不是出栈
                tmp = hp.back();
                // 出栈
                if (tmp == '(' &amp;&amp; s[i] == ')' || tmp == '[' &amp;&amp; s[i] == ']' || tmp == '{' &amp;&amp; s[i] == '}')
                    hp.pop_back();  // 出栈
                else
                    return false;
            }
        }
        return hp.size() == 0;
    }
};
</code></pre>
<h5 id="go版本思路及代码-3">Go版本思路及代码</h5>
<p>利用数组切片模拟栈进行操作。</p>
<ul>
<li>使用<code>map</code>用<code>symbol</code>变量保存匹配规则，只有到右括号的时候才取左括号</li>
<li>申请<code>c</code>保存左括号</li>
<li>依次对字符串<code>s</code>进行遍历
<ul>
<li>用<code>clen</code>保存<code>c</code>的长度，先判断<code>clen</code>长度是否大于零
<ul>
<li>不大于零，将这个字符<code>value</code>加入</li>
<li>大于零，同时如果<code>symbol</code>中存在这个字符的<code>key</code>，就和<code>clen</code>最新加入的值进行匹配，匹配成功对<code>c</code>进行切片，把最新加入的值切掉</li>
</ul>
</li>
</ul>
</li>
<li>最后判断<code>c</code>是否为空，空了说明都匹配了</li>
</ul>
<pre><code class="language-go">func isValid(s string) bool {
	var c []byte
	symbol := map[byte]byte{
		')': '(',
		']': '[',
		'}': '{',
	}
	for _, value := range s {
		clen := len(c)
		if clen &gt; 0 {
			if _, ok := symbol[byte(value)]; ok {
				if c[clen-1] == symbol[byte(value)] {
					c = c[:clen-1]
					continue
				}
			}
		}
		c = append(c, byte(value))
	}
	return len(c) == 0
</code></pre>
<h2 id="leetcode026-删除排序数组中的重复项">leetcode026-删除排序数组中的重复项</h2>
<h3 id="题目重述-4">题目重述</h3>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<pre><code>示例 1:
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
你不需要考虑数组中超出新长度后面的元素。

示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
</code></pre>
<h3 id="题解-4">题解</h3>
<blockquote>
<p>题解：陈乐乐(C++)  BeYanJin(Go)</p>
<p>这个题目两种代码版本的思路基本相同，以Golang代码为例。</p>
</blockquote>
<p>使用快慢指针的思想来操作数组元素。</p>
<ul>
<li>定义慢指针<code>low</code>让它始终指向数组的有序无重复序列的最后一项，即其所指位置的后一项就是有重复元素的项</li>
<li>定义快指针<code>fast</code>让它始终指向数组中没有加入有序无重复序列的第一项</li>
<li>如果<code>nums[fast] != nums[low]</code>，就有<code>nums[low+1] = nums[fast]</code>，然后<code>low++</code>；否则<code>fast++</code>，寻找没有加入无重复序列的那项</li>
</ul>
<h5 id="c版本思路及代码-4">C++版本思路及代码</h5>
<pre><code class="language-c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt; &amp;nums) {
        if (nums.size() == 0) return 0;
        int i = 0;
        for (int j = 1; j &lt; nums.size(); ++j) {
            if (nums[j] != nums[i]) {
                i++;
                nums[i] = nums[j];
            }
        }
        return i + 1;
    }
};
</code></pre>
<h5 id="go版本思路及代码-4">Go版本思路及代码</h5>
<pre><code class="language-go">func removeDuplicates(nums []int) int {
	if len(nums) == 0 {
		return 0
	}
	low := 0
	for fast := 0; fast &lt; len(nums); fast++ {
		if nums[low] != nums[fast] {
			nums[low+1] = nums[fast]
			low++
		}
	}
	return low + 1
}
</code></pre>
<h2 id="leetcode053-最大子序和">leetcode053-最大子序和</h2>
<h3 id="题目重述-5">题目重述</h3>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre>
<h3 id="题解-5">题解</h3>
<blockquote>
<p>题解：pinku-2</p>
</blockquote>
<h5 id="动态规划">动态规划</h5>
<ul>
<li>动态规划的关键点我认为有两个部分：
<ul>
<li>确定dp数组：<code>dp[i]</code>表示以<code>i</code>结尾的字段的和的最大值</li>
<li>建立状态转移方程：<code>dp[i]</code>的值等于<code>max(dp[i-1],0)+nums[i]</code>，这是因为：如果<code>dp[i]</code>最大并且<code>dp[i-1]</code>大于<code>0</code>，那么<code>dp[i-1]</code>也最大；如果<code>dp[i-1]</code>小于<code>0</code>，那么前面的数就不用加上去了，所以干脆直接取<code>nums[i]</code>。</li>
</ul>
</li>
<li>故有递推公式：$ dp[i] = max(dp[i-1], 0) + nums[i] $</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/02/05/nYuqp5Z1sa6DBoO.png" alt="e6ca21377d5533204c3149e0b5cdcc146ada4efe1ed2294b3e0615cdb4754853-file_1576478143560.png" loading="lazy"></figure>
<pre><code class="language-c++">class Solution1 {
public:
    int maxSubArray(vector&lt;int&gt; &amp;nums) {
        int result = INT_MIN;
        int numsSize = int(nums.size());
        vector&lt;int&gt; dp(numsSize);   // dp[i]表示nums中以nums[i]结尾的最大子序和
        dp[0] = nums[0];
        result = dp[0];
        for (int i = 1; i &lt; numsSize; ++i) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            result = max(result, dp[i]);
        }
        return result;
    }
};
</code></pre>
<h5 id="分治法">分治法</h5>
<p>最大子序和是使用分治法解决问题的典型的例子，并且可以用与合并排序相似的算法求解。下面是用分治法解决问题的模板：</p>
<ul>
<li>定义基本情况。</li>
<li>将问题分解为子问题并递归地解决它们。</li>
<li>合并子问题的解以获得原始问题的解。</li>
</ul>
<p>当最大子数组有 <code>n</code> 个数字时：</p>
<ul>
<li>若 <code>n==1</code>，返回此元素。</li>
<li><code>left_sum</code> 为最大子数组前 <code>n/2</code> 个元素，在索引为 <code>(left + right) / 2</code> 的元素属于左子数组。</li>
<li><code>right_sum</code> 为最大子数组的右子数组，为最后 <code>n/2</code> 的元素。</li>
<li><code>mid_sum</code> 是包含左右子数组且含索引 <code>(left + right) / 2</code> 的最大值。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/02/05/1LZbIoUg9JYdVqH.png" alt="11.png" loading="lazy"></figure>
<pre><code class="language-c++">class Solution2 {
public:
    int maxSubArray(vector&lt;int&gt; &amp;nums) {
        int result = INT_MIN;
        int numsSize = int(nums.size());
        result = maxSubArrayHelper(nums, 0, numsSize - 1);
        return result;
    }

    int maxSubArrayHelper(vector&lt;int&gt; &amp;nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }
        int mid = (left + right) / 2;
        int leftSum = maxSubArrayHelper(nums, left, mid);
        int rightSum = maxSubArrayHelper(nums, mid + 1, right);
        int midSum = findMaxCrossingSubarray(nums, left, mid, right);
        int result = max(leftSum, rightSum);
        result = max(result, midSum);
        return result;
    }

    int findMaxCrossingSubarray(vector&lt;int&gt; &amp;nums, int left, int mid, int right) {
        int leftSum = INT_MIN;
        int sum = 0;
        for (int i = mid; i &gt;= left; i--) {
            sum += nums[i];
            leftSum = max(leftSum, sum);
        }

        int rightSum = INT_MIN;
        sum = 0;
        for (int i = mid + 1; i &lt;= right; i++) {
            sum += nums[i];
            rightSum = max(rightSum, sum);
        }
        return (leftSum + rightSum);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用三角函数公式]]></title>
        <id>https://lizonglin313.github.io/post/chang-yong-san-jiao-han-shu-gong-shi</id>
        <link href="https://lizonglin313.github.io/post/chang-yong-san-jiao-han-shu-gong-shi">
        </link>
        <updated>2020-02-11T07:12:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>高中学的好多都忘了...整理一下</p>
</blockquote>
<h2 id="函数关系">函数关系</h2>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/02/11/RWAUhDECZ6G2abp.png" alt="关系.png" loading="lazy"></figure>
<h2 id="基本公式">基本公式</h2>
<h3 id="二角和差公式">二角和差公式</h3>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/02/11/wyML91GqsVTf2rh.png" alt="关系.png" loading="lazy"></figure>
<h3 id="二倍角公式">二倍角公式</h3>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/02/11/nvOeFSYBCuRQhGd.png" alt="关系.png" loading="lazy"></figure>
<h3 id="半角公式">半角公式</h3>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/02/11/1XDxmbOgrtjdwY4.png" alt="TIM截图20200211162330.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录不熟的单词]]></title>
        <id>https://lizonglin313.github.io/post/ji-lu-bu-shou-de-dan-ci</id>
        <link href="https://lizonglin313.github.io/post/ji-lu-bu-shou-de-dan-ci">
        </link>
        <updated>2020-02-07T07:45:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="名词">名词</h2>
<ul>
<li>attorney n. 律师</li>
<li>approval n.批准，赞成</li>
<li>accord n.协议，条约；v.与...相符，配合</li>
<li>barrel n.桶；v.飞驰</li>
<li>beast n.野兽</li>
<li>berry n.浆果</li>
<li>crane n.起重机，鹤；v.探头</li>
<li>compromise n.妥协，让步；v.妥协，让步；adj.妥协的，折中的</li>
<li>celebrity n.名人，明星；名声</li>
<li>credentials n.资历；资历证明</li>
<li>departure n.启程；脱离</li>
<li>demand n.需求；v.需求</li>
<li>doom n.死亡；v.注定失败的</li>
<li>devil n. 恶魔，淘气鬼； v. 困扰，折磨</li>
<li>descent n.下降下落；血统，出身</li>
<li>dose n.一剂，一服；v.给..服药</li>
<li>foam n.气泡，泡沫</li>
<li>enzyme n.酶</li>
<li>jungle n.热带丛林；杂乱无章的地方</li>
<li>haste n.匆忙 v.赶快</li>
<li>horror n.战栗，恐怖</li>
<li>identification n.鉴别，确认；身份证明；密切联系；认同</li>
<li>incentive n.刺激，奖励</li>
<li>instability n.不稳定性</li>
<li>intuition n.直觉</li>
<li>idiot n.蠢货</li>
<li>genius n.天才，天赋</li>
<li>grant n.拨款，补助金；v.给予；承认</li>
<li>grape n.葡萄</li>
<li>genre n.体裁，类型</li>
<li>mosaic n. 马赛克</li>
<li>precedent n.先例</li>
<li>property n.财产，资产；特性，性能</li>
<li>parcel n.包裹；v.打包</li>
<li>quota n.限额</li>
<li>strait n.海峡，水道；困境</li>
<li>siege n.包围，围攻</li>
<li>strife n.冲突</li>
<li>statue n.法令，规则</li>
<li>solidarity n.团结</li>
<li>tournament n. 锦标赛</li>
<li>sack n.麻布袋；</li>
<li>spectacle n.眼镜；壮观的景象</li>
<li>sediment n.沉渣，沉淀物</li>
<li>symptom n.症状</li>
<li>seminar n.研讨会</li>
<li>estate n.私有土地，庄园</li>
<li>dwelling n.住所</li>
<li>debut n.首次登台，问世；v.首次登台，问世</li>
<li>lamb n.羔羊</li>
<li>lavatory n.厕所</li>
<li>legacy n.遗物</li>
<li>refuge n.庇护，避难所</li>
<li>reservoir n.蓄水池；储藏</li>
<li>rib n.肋骨</li>
<li>revolt n.反抗；v.反抗</li>
<li>amber n.琥珀</li>
<li>reptile n.爬行动物</li>
<li>racket n.喧哗；诈骗；v.吵闹</li>
<li>riddle n.谜语</li>
<li>reproach n.责备，指责; vt.责备指责</li>
<li>timber n.树林，原木</li>
<li>vigilance n.警戒</li>
<li>vaccine n.疫苗</li>
<li>vibration n.振动，颤动</li>
<li>verdict n.裁定，定论</li>
</ul>
<h2 id="动词">动词</h2>
<ul>
<li>aggravate v.加重，恶化</li>
<li>accommodate v.容纳，适应</li>
<li>acknowledge v.承认，接受</li>
<li>deteriorate vi.恶化，衰退</li>
<li>disrupt v.使中断，扰乱</li>
<li>denote v.象征，意指</li>
<li>disseminate v.散步，传播</li>
<li>discharge v.准许离开，释放；完成任务，履行职务</li>
<li>derive v.起源，来自于</li>
<li>combat v.与...战斗；n.战斗</li>
<li>commend v.赞成；推荐</li>
<li>counsel n.给予咨询，建议；n.律师，法律顾问</li>
<li>clutch v.抓紧</li>
<li>chill v.使冰冷；使镇定；n.寒冷，害怕；adj.寒冷的，令人沮丧的</li>
<li>hunt v.搜寻，寻找，打猎；n.寻找，打猎</li>
<li>engrave v.雕刻</li>
<li>encompass v.包含；包围</li>
<li>extinguish v.扑灭，使熄灭</li>
<li>lubricate v.润滑；促进</li>
<li>mourn v.哀悼，为失去感到悲哀</li>
<li>maintain v.维持，保养吗；坚称，主张</li>
<li>meditate v.沉思，打坐</li>
<li>regain v.恢复；重新得到；重返</li>
<li>rally v.聚集，扶持；n.群众大会，集会</li>
<li>rob v.夺走；抢劫</li>
<li>revive v.恢复，复活</li>
<li>gesture v.打手势，示意；n.手势，示意动作</li>
<li>graze v.放牧</li>
<li>sparkle v.闪闪发光，光点；聪明活泼</li>
<li>soothe v.使平静，安抚</li>
<li>stun v.使震惊；使昏迷</li>
<li>necessitate v.迫使，使得成为必要</li>
<li>seal v.密封，印章，封锁</li>
<li>snap v.一声绷断，打响指；adj.迅速的，突然的</li>
<li>spicy adj.辛辣的</li>
<li>sneeze v.打喷嚏</li>
<li>swarm v.蜂拥；n.一大群</li>
<li>shrivel v.枯萎，使得束手无策</li>
<li>jeer v.嘲讽</li>
<li>foster v.促进，助长，抚养；adj.代养的</li>
<li>inlet n.水湾；机器上的进口</li>
<li>initiate v.开始；发起；吸纳；n.创始人</li>
<li>preach v.讲道，传教；宣传，鼓吹</li>
<li>pinch v.捏，掐；n.少量</li>
<li>transcend v.超出</li>
<li>torture v.拷问；n.拷问</li>
<li>thumb v.用拇指翻动，翻阅；n.拇指</li>
</ul>
<h2 id="形容词">形容词</h2>
<ul>
<li>analogue adj.模拟的；n.相似物</li>
<li>bland adj.无聊的</li>
<li>bleak adj.寒冷的；暗淡的(形势)</li>
<li>comprehensive adj.全面的，广泛的</li>
<li>simultaneous adj.同时出现的，同步的</li>
<li>selective adj.选择性的，仔细挑选的</li>
<li>subjective adj.主观上的；个人的</li>
<li>sociable adj.友善的，喜欢交际的</li>
<li>solitary adj.单独的，独自的</li>
<li>tragic adj.悲惨的，悲剧的</li>
<li>viable adj.切实可行的</li>
<li>indicative adj.显示的，象征的，指示的；n.陈述语气</li>
<li>exceptional adj.优异的，非凡的</li>
<li>legible adj.清楚的，易读的</li>
<li>lame adj.跛的，瘸的；站不住脚的</li>
<li>dental adj.牙科的</li>
<li>denounce v.谴责，抨击</li>
<li>dense adj.稠密的，浓重的</li>
<li>diligent adj.勤奋的</li>
<li>earnest adj.热心的</li>
<li>hasty adj.仓促的</li>
<li>monetary adj.货币的，金融的</li>
<li>militant adj.好战的；n.激进分子</li>
<li>naive adj.天真的</li>
<li>naughty adj.顽皮的</li>
<li>plural adj.复数的 n.复数</li>
<li>opaque adj.不透明的，浑浊的，晦涩的</li>
<li>occasional adj.偶然的，非正式的</li>
<li>rotten adj.腐烂的</li>
<li>redundant adj.累赘的，冗长的</li>
</ul>
<h2 id="副词">副词</h2>
<ul>
<li>namely adv.即，也就是</li>
<li>furthermore adv.而且，此外</li>
<li>accordingly adv.因此，相应地</li>
<li>alike adv.相同的，相似的；adj.彼此相似的</li>
</ul>
<h2 id="介词">介词</h2>
<ul>
<li>notwithstanding prep.虽然，尽管</li>
<li>in spite of 尽管，不顾，虽然</li>
<li>via prep.经由，通过</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ Vector的简单说明]]></title>
        <id>https://lizonglin313.github.io/post/c-vector-rong-qi-de-jian-dan-shuo-ming</id>
        <link href="https://lizonglin313.github.io/post/c-vector-rong-qi-de-jian-dan-shuo-ming">
        </link>
        <updated>2020-02-03T16:10:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>整理自wiki、菜鸟教程、W3Cschool</p>
</blockquote>
<h3 id="什么是vector">什么是Vector</h3>
<p><strong>Vector</strong> 是<a href="https://zh.wikipedia.org/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E7%A8%8B%E5%BC%8F%E5%BA%AB">C++标准程序库</a>中的一个<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">类</a>，可视为会自动扩展容量的数组，以循序(Sequential)的方式维护变量集合。vector的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。vector是<a href="https://zh.wikipedia.org/wiki/C%2B%2B%E6%A8%99%E6%BA%96%E7%A8%8B%E5%BC%8F%E5%BA%AB">C++标准程序库</a>中的众多<a href="https://zh.wikipedia.org/wiki/%E5%AE%B9%E5%99%A8_(%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B)">容器</a>（<em>container</em>）之一。 vector以<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF_(C%2B%2B)">模板</a>(泛型)方式实现，可以保存任意类型的变量，包括用户自定义的数据类型，例如：它可以是放置整数（int）类型的 vector、也可以是放置字符串（string）类型的 vector、或者放置用户自定类别（user-defined class）的 vector。(from:wiki)</p>
<p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。(from:runoob)</p>
<p>在c++中，vector是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。(from:w3cschool)</p>
<h3 id="特性">特性</h3>
<ul>
<li>顺序序列：顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</li>
<li>动态数组：支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</li>
<li>内存分配器感知：容器使用一个内存分配器对象来动态地处理它的存储需求。</li>
</ul>
<blockquote>
<p>注意⚠</p>
<ol>
<li>
<p>如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p>
</li>
<li>
<p>Vector作为函数的参数或者返回值时，需要注意它的写法：</p>
<p><code>double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b)</code></p>
</li>
</ol>
</blockquote>
<h3 id="使用方法">使用方法</h3>
<h4 id="基本方法">基本方法</h4>
<ul>
<li>引入头文件</li>
</ul>
<pre><code class="language-c++">#include &lt;vector&gt;
</code></pre>
<ul>
<li>创建vector对象</li>
</ul>
<pre><code class="language-c++">vector&lt;int&gt; vec;
</code></pre>
<ul>
<li>在尾部插入一个元素</li>
</ul>
<pre><code class="language-c++">vec.push_back(a);
</code></pre>
<ul>
<li>在尾部删除一个元素</li>
</ul>
<pre><code class="language-c++">vec.pop_back();
</code></pre>
<ul>
<li>使用下标访问</li>
</ul>
<pre><code class="language-c++">cout &lt;&lt; vec[0] &lt;&lt; endl;
</code></pre>
<ul>
<li>使用迭代器访问</li>
</ul>
<pre><code class="language-c++">vector&lt;int&gt;::iterator it;
for (it = vec.begin(); it != vec.end(); it++)
    cout &lt;&lt; *it &lt;&lt; endl;
</code></pre>
<ul>
<li>在第<code>i+1</code>个元素前插入<code>a</code></li>
</ul>
<pre><code class="language-c++">vec.insert(vec.begin()+i,a);
</code></pre>
<ul>
<li>删除第三个元素</li>
</ul>
<pre><code class="language-c++">vec.erase(vec.begin()+2);
</code></pre>
<ul>
<li>删除区间<code>[i,j-1]</code>，区间从<code>0</code>开始</li>
</ul>
<pre><code class="language-c++">vec.erase(vec.begin()+i,vec.end()+j);
</code></pre>
<ul>
<li>获取长度</li>
</ul>
<pre><code class="language-c++">vec.size();
</code></pre>
<ul>
<li>清空</li>
</ul>
<pre><code class="language-c++">vec.clear();
</code></pre>
<ul>
<li>逆序，需要引入头文件<code>#include&lt;algorithm&gt;</code></li>
</ul>
<pre><code class="language-c++">reverse(vec.begin(),vec.end());
</code></pre>
<ul>
<li>使用<code>sort</code>排序，需要引入头文件<code>#include&lt;algorithm&gt;</code></li>
</ul>
<pre><code class="language-c++">sort(vec.begin(),vec.end());	// 默认升序

/* 通过重写排序算法降序排列 */
bool Comp(const int &amp;a,const int &amp;b)
{
    return a&gt;b;
}
sort(vec.begin(),vec.end(),Comp);	// 调用
</code></pre>
<h4 id="二维数组定义">二维数组定义</h4>
<p>方法1：</p>
<pre><code class="language-c++">#include &lt;string.h&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()
{
    int N = 5, M = 6; 
    vector&lt;vector&lt;int&gt;&gt; obj(N); 	//定义二维动态数组大小5行 
    for(int i = 0; i &lt; obj.size(); i++)	//动态二维数组为5行6列，值全为0 
    { 
        obj[i].resize(M);	
        // resize()改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 
    } 
 
    for(int i = 0; i&lt; obj.size(); i++)//输出二维动态数组 
    {
        for(int j = 0; j &lt; obj[i].size(); j++)
        {
            cout &lt;&lt; obj[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre>
<p>方法2：</p>
<pre><code class="language-c++">#include &lt;string.h&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
 
int main()
{
    int N = 5, M = 6; 
    vector&lt;vector&lt;int&gt;&gt; obj(N, vector&lt;int&gt;(M)); //定义二维动态数组5行6列 
 
    for(int i = 0; i &lt; obj.size(); i++)	//输出二维动态数组 
    {
        for(int j = 0; j &lt; obj[i].size(); j++)
        {
            cout &lt;&lt; obj[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; &quot;\n&quot;;
    }
    return 0;
}
</code></pre>
<h4 id="结构体类型元素">结构体类型元素</h4>
<blockquote>
<p>注意⚠：结构体要定义为全局！</p>
</blockquote>
<pre><code class="language-c++">#include&lt;stdio.h&gt;  
#include&lt;algorithm&gt;  
#include&lt;vector&gt;  
#include&lt;iostream&gt;  
using namespace std;  
typedef struct rect  
{  
    int id;  
    int length;  
    int width;  
　　//对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。  
　　bool operator&lt; (const rect &amp;a)  const  
    {  
        if(id!=a.id)  
            return id&lt;a.id;  
        else  
        {  
            if(length!=a.length)  
                return length&lt;a.length;  
            else  
                return width&lt;a.width;  
        }  
    }  
}Rect;  
int main()  
{  
    vector&lt;Rect&gt; vec;  
    Rect rect;  
    rect.id=1;  
    rect.length=2;  
    rect.width=3;  
    vec.push_back(rect);  
    vector&lt;Rect&gt;::iterator it=vec.begin();  
    cout&lt;&lt;(*it).id&lt;&lt;' '&lt;&lt;(*it).length&lt;&lt;' '&lt;&lt;(*it).width&lt;&lt;endl;      
return 0;  
}  
</code></pre>
]]></content>
    </entry>
</feed>