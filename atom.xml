<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lizonglin313.github.io/</id>
    <title>Big Carrot</title>
    <updated>2020-01-22T15:50:47.146Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lizonglin313.github.io/"/>
    <link rel="self" href="https://lizonglin313.github.io/atom.xml"/>
    <subtitle>人们依然相信未来会更精彩</subtitle>
    <logo>https://lizonglin313.github.io/images/avatar.png</logo>
    <icon>https://lizonglin313.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Big Carrot</rights>
    <entry>
        <title type="html"><![CDATA[常见的排序算法总结]]></title>
        <id>https://lizonglin313.github.io/post/常见的排序算法总结</id>
        <link href="https://lizonglin313.github.io/post/常见的排序算法总结">
        </link>
        <updated>2019-11-21T11:36:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>整理常用的排序算法，主要包括：</p>
<ul>
<li>选择排序</li>
<li>冒泡排序</li>
<li>归并排序</li>
<li>快速排序</li>
<li>插入排序</li>
<li>堆排序</li>
</ul>
</blockquote>
<h2 id="策略以及时间开销">策略以及时间开销</h2>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>基于的思想</th>
<th>时间开销</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>蛮力法</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>蛮力法</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>归并排序</td>
<td>分治法</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>快速排序</td>
<td>分治法</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>插入排序</td>
<td>减治法</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>堆排序</td>
<td>减治法</td>
<td>O(nlogn)</td>
</tr>
</tbody>
</table>
<h2 id="部分排序的核心算法">部分排序的核心算法</h2>
<h3 id="归并排序">归并排序</h3>
<h4 id="图解">图解</h4>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/11/21/IwoPu7Eb6VrLYiR.png" alt="" loading="lazy"></figure>
<h4 id="代码">代码</h4>
<pre><code class="language-c++">/*
输入：待排序的数组r[n]，待排序区间[s,t]
输出：升序序列r[s]~r[t]
1. 如果s==t，则待排序区间只有一个元素，返回
2. 计算划分重点：m=(s+t)/2
3. 对于前半个子序列以 r[s]~r[m]进行递归，继续划分
4. 对于后半个子序列以 r[m+1]~r[t]进行递归，继续划分
5. 合并划分后的子序列：
	5.1 令i=s,j=m+1,k=s 在 i&lt;=m&amp;&amp;j&lt;=t时进行循环
		5.1.1 按照升序依次在两个子序列选择元素放入r1[]临时数组，同时改变两个子序列的索引位置
6. 处理某个子序列未放完的元素
7. 将r1复制到r中
8. 待所有递归过程结束，打印r[]
*/

void MergeSort(int r[],int s,int t){
    int m,r1[1000];
    
    if(s==t) return;		// 此时划分至只有一个元素了
	
    else{
        m = (s+t)/2;		// 继续划分
        MergeSort(r,s,m);	// 划分前半个子序列
        MergeSort(r,m+1,t);	// 划分后半个子序列
        Merge(r,r1,s,m,t);	// 合并划分后的结果
        
        for(int i=s;i&lt;=t;i++){
            r[i]=r1[i];
        }   
    }
}

/* 合并函数 */
void Merge(int r[],int r1[],int s,int m,int t){
    
    int i=s;
    int j=m+1;		// 分别标记原数组两个子序列的起始位置
    int k=s;		// 标记r1临时数组
    
    while(i&lt;=m&amp;&amp;j&lt;=t){
        if(r[i]&lt;=r[j])	r1[k++]=r[i++];
        else	r1[k++]=r[j++];
    }
    
    // 进行收尾工作
    while(i&lt;=m) r1[k++]=r[i++];
    while(j&lt;=t) r1[k++]=r[j++];
    
}
</code></pre>
<h3 id="快速排序">快速排序</h3>
<h4 id="图解-2">图解</h4>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/11/21/qRtJ6xVDgNPfHwe.jpg" alt="" loading="lazy"></figure>
<h4 id="代码-2">代码</h4>
<pre><code class="language-c++">/*
伪代码：
（假设以首元素为轴值）
输入：r[n]，first，end
输出：升序排序的r[n]
1. 选定首元素即 r[first] 为轴值
2. 如果first&lt;end
	2.1 划分左右区间，获得轴值位置
		2.1.1 令 i=first j=end, if i&lt;j 做：
		2.1.2 右侧扫描，if r[j]&gt;轴值 j-- ；反之 swap(r[i],r[j])
		2.1.3 左侧扫描，if r[i]&lt;轴值 i++ ；反之 swap(r[i],r[j])
	2.2 返回最后的i即为轴值的最新位置，pivot&lt;-i
	2.3 左孩子序列以：r,first,pivot-1 快排
    2.4 右孩子序列以：r,pivot+1,end 快排
3. 最后输出排完序的r[n]
*/

void QuickSort(int r[],int first,int end){
    int pivot;		// 轴值
    
    if(first&lt;end){
    	pivot=Partition(r,first,end);	// 划分子序列，pivot是轴值所在位置的索引
        QuickSort(r,first,pivot-1);		// 左子序列快排
        QuickSort(r,pivot+1,end);		// 右子序列快排
    }
}

/* 划分子序列，求解轴值位置 */
int Partition(int r[],int first,int end){
    int i=first;
    int j=end;
    
    while(i&lt;j){
        while(i&lt;j&amp;&amp;r[i]&lt;=r[j])	j--;
        
        if(i&lt;j){
        	int temp=r[i];
            r[i]=r[j];
            r[j]=temp;
            i++;
        }
        
        while(i&lt;j&amp;&amp;r[i]&lt;=r[j])	i++;
        
        if(i&lt;j){
            int temp=r[i];
        	r[i]=r[j];
            r[j]=temp;
            j--;
        }
    }
    return i;
}
</code></pre>
<h3 id="插入排序">插入排序</h3>
<h4 id="图解-3">图解</h4>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2019/11/21/IxXUsw3nHOTzJV2.png" alt="" loading="lazy"></figure>
<h4 id="代码-3">代码</h4>
<pre><code class="language-c++">// 设r[0]为哨兵，实际的数据从r[1]开始
for(int i=2;i&lt;=n;i++){
    r[0]=r[i];		// 使得r[0]一直为无序序列的第一个一个元素
    for(int j=i-1;r[0]&lt;r[j];j--){
        r[j+1]=r[j];		// 如果待插入元素比有序序列中某个元素小，这个元素后移
    }
    r[j+1]=r[0];
}
</code></pre>
<h3 id="堆排序">堆排序</h3>
<h4 id="图解-4">图解</h4>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2019/11/21/oLHMUvJ9eVZIXCf.jpg" alt="" loading="lazy"></figure>
<h4 id="代码-4">代码</h4>
<pre><code class="language-c++">/*
伪代码：
输入：r(k+1)~r(n)满足堆的条件，待筛选记录rk
输出：{r(k)',r(k+1)',...r(n)'}为大根堆
1. 设置i和j，分别指向要筛选的结点和其左孩子结点
2. 若ri已是叶子，则筛选完毕
	否则，比较要筛选结点的左右孩子结点，并将j指向较大的结点
3. 将ri和rj进行比较，有以下两种情况：
	3.1 如果ri&gt;rj，则完全二叉树已是堆，筛选完毕
	3.2 否则将ri和rj进行交换；令i=j，转步骤2继续执行
*/

void HeapSort(int r[],int n){
    int i,temp;
    
    for(i=(n-1)/2;i&gt;=0;i--){		// 初始建堆，最后一个分支下标为(n-1)/2
        SiftHeap(r,i,n);
    }
    
    for(i=1;i&lt;=n-1;i++){
        temp=r[0];
        r[0]=r[n-i];
        r[n-i]=temp;
        SiftHeap(r,0,n-i);			// 只需要调整根节点
    }
}

void SiftHeap(int r[],int k,int n){
    int i,j,temp;					// 置i为要筛的结点，j为i的左孩子
    i=k;
    j=i*2+1;
    while(j&lt;n){
        if(j&lt;n-1&amp;&amp;r[j]&lt;r[j+1]) j++;		// 比较i的左右孩子，j为较大者
        if(r[i]&gt;r[j]) 	break;
        else{
            // 将被筛结点与结点j交换
            temp=r[i];
            r[i]=r[j];
            r[j]=temp;
            // 被筛节点位于原来结点j的位置
            i=j;
            j=2*i+1;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用不同算法解决0/1背包问题]]></title>
        <id>https://lizonglin313.github.io/post/用不同算法解决01背包问题</id>
        <link href="https://lizonglin313.github.io/post/用不同算法解决01背包问题">
        </link>
        <updated>2019-11-21T06:34:04.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>0/1背包问题是算法中很经典的问题，具体内容题目内容不再赘述，需要请自行搜索..</p>
</blockquote>
<h2 id="蛮力法">蛮力法</h2>
<ul>
<li>
<p>思想</p>
<p>蛮力法的基本思想就是<strong>遍历</strong></p>
</li>
<li>
<p>时间复杂度</p>
<p>Ω(2^n)</p>
</li>
<li>
<p>代码</p>
<pre><code class="language-c++">// 伪代码如下
输入：重量{w1,w2,w3,...,wn} 价值{v1,v2,v3,...,vn} 容量C
输出：装入背包物品的编号和最大价值

1. maxValue=0；结果子集S={}

2. 对集合{1,2,3,...,n}每一个子集T，都有：

	2.1 初始化背包价值value=0，背包重量weight=0
    
    2.2 对每个子集里的每个元素j
    	2.2.1 if weight+wj &lt;= C then weight+=wj value+=vj
    	2.2.2 else 子集元素还没选完就超重，转2进行下一个子集
    
    2.3 进行到此处某个子集中的元素全部放入背包
    	2.3.1 if value &gt; maxValue then maxValue&lt;-value S&lt;-T

3. 输出S中的元素和maxValue，结束
</code></pre>
</li>
</ul>
<h2 id="回溯法">回溯法</h2>
<ul>
<li>
<p>思想</p>
<p><strong>解空间树</strong> + 使用<strong>限定条件</strong>进行<strong>剪枝</strong></p>
<p>在状态空间树的任意一个部分解结点处应该有以下两个判定函数：</p>
<p>1）当前部分解的总重量小于背包容量</p>
<p>2）当前问题状态下继续向前搜索搜索可以找到比目前已知解的总价值更大的解</p>
</li>
<li>
<p>时间复杂度</p>
<p>本质是蛮力法，时间通常也为<strong>指数阶</strong></p>
</li>
<li>
<p>代码</p>
<pre><code class="language-c++">// 伪代码如下
输入：重量W={w0,w1,w2,...,wn} 价值V={v0,v1,v2,...,vn} 容量C
输出：装入背包物品的编号和最大价值

1. maxValue=0；结果子集S={}

2. 将背包的物品按照单位价值降序排序，相应的改变集合W和V

3. 解空间树的层数layer=0，当前重量cw=0，当前价值cv=0，当前所选物品集合cs={}，进行如下的递归
    3.1 if layer==n 到达叶子结点
    	3.1.1 if cv &gt; maxValue then maxValue=cv S=cs
    3.2 没有到达叶子结点，for j=1 to 0
    	3.2.1 判断在此节点处是否满足这两个条件：
    		1）装入第layer个物品后不超重 
    		2）此节点处期望最大值大于maxValue
    		如果两个不同时满足，剪枝	
    		如果同时满足：根据j=1或j=0更新cv,cw,cs
    	3.2.2 进行下一层 layer+1，cv，cw，cs递归
    	3.2.3 回滚cv,cw,cs到递归前的值

4. 输出S中的元素和maxValue，结束


// 核心代码

// 计算剩余物品都装下时的最大价值
int Bound_sv(int layer, int cv) {

    int i = layer;
    int sv = cv;

    for (i; i &lt; set_number; i++) {
        sv += goods[i].value;		// 剩余物品都装下时的最大价值
    }

    return sv;

}

// 计算期望最大价值
double Bound(int layer,int cv,int cw){
    int i = layer;

    double sv = double(cv);
    int cr = capacity - cw;

    while (i&lt;set_number &amp;&amp; goods[i].weight &lt;= cr)
    {
        cr -= goods[i].weight;
        sv = sv + goods[i].value;
        i++;
    }

    if (i &lt; set_number)
        sv = sv + goods[i].ave_value * cr;

    return sv;
}


// Using back track method to get max value
void BackTrack(int layer, int current_value, int current_weight) {
    // layer代表回溯层数，其余参数分别代表当前价值以及当前重量
    //double expect_sumValue = 0;		// 记录期望价值总和

    if (layer == set_number) {		// if layer bigger than number, over
        // 注意这个地方，不用大于 ！！！

        if (current_value &gt; maxValue) {

            maxValue = current_value;

            for (int i = 0; i &lt; set_number; i++) {
                max_set[i] = current_set[i];

            }
        }
    }
    else
    {
        for (int j = 0; j &lt;= 1; j++) {

            current_set[layer] = j;

            /************************剪枝**************************/


            if (
                current_weight + current_set[layer] * goods[layer].weight &lt;= capacity
                &amp;&amp; Bound_sv(layer,current_value) &gt;= maxValue &amp;&amp; Bound(layer,current_value,current_weight) &gt; maxValue
            )
            {
                // 更新当前背包物品的总重量，目前背包物品的总价值
                current_weight += (goods[layer].weight * current_set[layer]);
                current_value += (goods[layer].value * current_set[layer]);

                // 继续进行子树的递归
                BackTrack(layer + 1, current_value, current_weight);

                // 递归出来后回滚数据
                current_weight -= (goods[layer].weight * current_set[layer]);
                current_value -= (goods[layer].value * current_set[layer]);

            }
        }
    }

}


</code></pre>
</li>
</ul>
<h2 id="分支限界法">分支限界法</h2>
<ul>
<li>
<p>思想</p>
<p><strong>广度优先策略</strong>搜索解空间树，对待处理的根节点根据<strong>限界函数</strong>估算目标函数的可能取值，选择目标函数<strong>极大或者极小</strong>的结点<strong>优先进行广度搜索</strong>，不断<strong>调整搜索方向</strong>，尽可能早的找到最优解。</p>
</li>
<li>
<p>时间复杂度</p>
<p>本质还是<strong>蛮力法</strong>，最坏情况下时间复杂度还是指数阶</p>
</li>
<li>
<p>代码</p>
</li>
</ul>
<pre><code class="language-c++">// 伪代码如下
输入：n个物品的重量w[n]，价值v[n]，背包容量W
输出：背包获得的最大价值和装入背包的物品
1. 根据界限函数计算目标函数的上界up，使用贪心法计算目标函数的下界down
2. 计算根节点的目标函数值并且加入PT表
3. 循环直到某个叶子节点的目标函数值在表PT中去取极大值
	3.1 i=PT表中具有最大值的结点
	3.2 对结点i的每个孩子结点x执行下述操作：
		3.2.1 如果孩子x结点不满足约束条件，则丢弃该节点
		3.2.2 否则，估算结点x的目标函数的取值lb，将其加入表PT中
4. 将叶子节点对应的最优解输出，回溯得到最优解的各个分量

int tree_node_id = 1;		// 解空间树结点id 1开始

int lower_bound = 0;		// 目标函数的下界

// 贪心法求背包容量的下界
int greed() {

    int temp[MAX] = { 0 };		// 定义临时数组，用来表示货物向量，并初始化为0
    int cap = capacity;			// 暂存背包容量
    int w = 0;					// 当前背包容量
    int updown = 0;				// 下界

    // 对背包物品按照单位价值进行排序
    sort_set();

    // 求解
    for (int i = 0; i &lt; set_number; i++) {

        // 如果超重，跳出
        if ((w+goods[i].weight) &gt; cap) {
            continue;
        }

        temp[i] = 1;
        w += goods[i].weight;
        updown += (temp[i] * goods[i].value);
    }

    cout &lt;&lt; &quot;解的下界是：&quot; &lt;&lt; updown &lt;&lt; endl;

    return updown;

}


// 限界函数求上界
void limit(ND &amp;n)				        //计算分枝结点的上界
{
    // 下一个要选的物品就是第layer层物品
    int w = n.current_weight;
    double v = n.current_value;
    int i = n.layer;

    while (i &lt; set_number &amp;&amp; w + goods[i].weight &lt;= capacity) {
        w += goods[i].weight;
        v += goods[i].value;
        i++;
    }

    if (i &lt; set_number) {  // 装部分物品
        n.ub = v + (capacity - w)*goods[i].ave_value;
    }
    else
    {
        n.ub = v;
    }
}

// 优先队列进队操作
void EnQueue(ND n, priority_queue&lt;ND&gt; &amp;q) {
    if (n.layer == set_number) {		// 已经到达叶子结点

        if (n.current_value &gt; maxValue) {		// 更新maxValue
            maxValue = n.current_value;
            for (int i = 0; i &lt; set_number; i++) {
                max_set[i] = n.cset[i];
            }
        }
    }
    else {
        q.push(n);			// 非叶子结点进队
    }
}

// 分支限界法
void branchAndbound() {

    // 首先使用贪心法求解此goods集合的目标值下界
    lower_bound = greed();

    priority_queue&lt;ND&gt; q;		// 优先队列
    ND n0, n1, n2;				// 先定义根结点，左孩子结点，右孩子结点

    /*初始化根节点*/
    n0.id = tree_node_id++;		
    n0.layer = 0;
    n0.current_value = 0;
    n0.current_weight = 0;
    for (int i = 0; i &lt; set_number; i++) {
        n0.cset[i] = 0;
    }
    limit(n0);					// 求根结点上界
    q.push(n0);					// 根结点进队

    while (!q.empty())			// 队不空循环
    {
        n0 = q.top();				// 取队头
        q.pop();				// 出队
        if (n0.current_weight + goods[n0.layer].weight &lt;= capacity &amp;&amp; n0.ub &gt;= lower_bound) {	// 超重剪枝 小于最小期望重量剪枝

            // 设置左孩子结点
            n1.id = tree_node_id++;
            n1.layer = n0.layer + 1;
            n1.current_weight = n0.current_weight + goods[n0.layer].weight;
            n1.current_value = n0.current_value + goods[n0.layer].value;
            /*复制解向量*/
            for (int i = 0; i &lt; set_number; i++) {
                n1.cset[i] = n0.cset[i];
            }
            n1.cset[n1.layer-1] = 1;			// 更新解向量
            limit(n1);						// 求限界函数上界
            EnQueue(n1, q);					// 左孩子进队
        }

        // 设置右孩子结点
        n2.id = tree_node_id++;
        n2.layer = n0.layer + 1;
        n2.current_value = n0.current_value;
        n2.current_weight = n0.current_weight;

        // 复制解向量
        for (int i = 0; i &lt; set_number; i++) {
            n2.cset[i] = n0.cset[i];
        }


        n2.cset[n2.layer-1] = 0;		 // 更新解向量
        limit(n2);					// 求界限函数上界

        if (n2.ub &gt; maxValue &amp;&amp; n2.ub &gt;= lower_bound) {		// 剪枝，期望最大值小于已有最大值就剪枝  小于最小期望重量剪枝
            EnQueue(n2, q);
        }

    }
}

</code></pre>
<h2 id="动态规划">动态规划</h2>
<ul>
<li>
<p>思想</p>
<p>处理<strong>多阶段决策最优化问题</strong>，多阶段决策过程满足<strong>最优性原理</strong></p>
<p>1）划分子问题</p>
<p>2）确定动态规划函数</p>
<p>3）填表</p>
</li>
</ul>
<h2 id="贪心法">贪心法</h2>
<p><strong>对于0/1背包来说，贪心法在一些时候是无法求得最优解的，所以不要万不得已还是不要选择贪心法了</strong></p>
<pre><code class="language-c++">/*
分别用、蛮力法、回溯法和分支限界法 实现0/1背包问题的求解
*/
// 蛮力法求解0/1背包

#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;sys/timeb.h&gt;
#include &lt;math.h&gt;
using namespace std;

#define MAX 100000

// Good is the struct of good which has three elememt
typedef struct Good
{
	int value = 0;
	int weight = 0;
	double ave_value = 0;
}GD;


// 定义按照单位重量降序排序的规则
struct sort_rule {
	bool operator()(const GD &amp;good1, const GD &amp;good2) {
		return good1.ave_value &gt; good2.ave_value;
	}
};

// 定义用于分支限界法的树结点结构体
/*
typedef struct Node {

	int current_weight = 0;				// 到达此结点时背包所有物品的总重量
	int current_value = 0;				// 到达此结点时背包所有物品的总价值
	
	double result_of_Obj_func = 0;		// 此结点的目标函数的值

	// bool biggest = true;				// 是否是此时的最大结点

}ND;
*/
typedef struct Node { // 分支限界法树结点
	int id;								// 结点编号
	int layer;							// 当前结点所在树的层数
	int current_weight = 0;				// 当前结点的总重量
	int current_value = 0;				// 当前结点的总价值
	double ub = 0;						// 当前结点的限界函数值

	int cset[MAX] = { 0 };				// 当前背包的解向量

	bool operator&lt;(const Node&amp; nd) const {		// 定义优先队列出队规则，限界函数值越大越先出队
		return ub &lt; nd.ub;
	}
}ND;

// 公用 -&gt; 获取时间函数
long long getSystemTime() {
	timeb t;
	ftime(&amp;t);
	return t.time * 1000 + t.millitm;
}


class Bag {		// 基类，用作蛮力法

	protected:
		int set_number;					// 集合元素个数
		int capacity;					// 背包容量
		int maxValue = -1;					// 最大重量

		// 定义时间变量
		long long t1;
		long long t2;
		long long sum_time = 0;

		GD goods[MAX];
		int max_set[MAX] = { 0 };		// max_set为标志数组
		int current_set[MAX] = { 0 };	// define current_set to save current set


		// 初始化重量集合
		void set_weights(int N) {
			
			int sum_w = 0;
			for (int i = 0; i &lt; N; i++) {
				goods[i].weight = (rand() % 10) + 1;
				sum_w += goods[i].weight;
			}
			capacity = sum_w / 2;
		
		}

		// 初始化价值集合
		void set_values(int N) {
			
			for (int i = 0; i &lt; N; i++) {
				//values[i] = (rand() % 5 + 1) * 10 + ((rand() % 10) + 1);		// 产生10-60之间的数值
				goods[i].value = (rand() % 5 + 1) * 10 + ((rand() % 11));
			}
			
		}

		// 初始化集合
		void initialize_set(int N) {
			set_weights(N);
			set_values(N);
		}

		// 打印重量和价值
		void print_wv(int N) {
			cout &lt;&lt; &quot;物品重量集合为：{ &quot;;
			for (int i = 0; i &lt; N; i++) {
				//cout &lt;&lt; weights[i] &lt;&lt; &quot; &quot;;
				cout &lt;&lt; goods[i].weight &lt;&lt; &quot; &quot;;
			}
			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl &lt;&lt; &quot;物品价值集合为：{ &quot;;
			for (int i = 0; i &lt; N; i++) {
				//cout &lt;&lt; values[i] &lt;&lt; &quot; &quot;;
				cout &lt;&lt; goods[i].value &lt;&lt; &quot; &quot;;
			}
			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
			cout &lt;&lt; &quot;背包容量为：&quot; &lt;&lt; capacity &lt;&lt; endl;
		}


		void print_set() {		// 打印集合
	// 输出最大重量以及对应的元素序号
	// 如果输出 0 / 1 表示的子集情况例如 {0 1 0 1 1 0 0} 就修改本函数
			cout &lt;&lt; &quot;背包能装的最大价值为：&quot; &lt;&lt; maxValue &lt;&lt; endl;
			cout &lt;&lt; &quot;包含的物品有：{ &quot;;
			for (int i = 0; i &lt; set_number; i++) {
				// 输出序号 or 向量
				if (max_set[i])
				{
					cout &lt;&lt; i + 1 &lt;&lt; &quot; &quot;;
				}
			}
			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
		}

		void brute_force(int layer, int current_value, int current_weight) {
			// layer代表回溯层数，其余参数分别代表当前价值以及当前重量

			if (layer == set_number) {		// if layer bigger than number, over
				// 注意这个地方，不用大于 ！！！

				if (current_value &gt; maxValue &amp;&amp; current_weight &lt;= capacity) {

					maxValue = current_value;

					for (int i = 0; i &lt; set_number; i++) {
						max_set[i] = current_set[i];

					}
				}
			}
			else
			{
				for (int j = 1; j &gt;= 0; j--) {

					current_set[layer] = j;

					current_weight += (goods[layer].weight * current_set[layer]);
					current_value += (goods[layer].value * current_set[layer]);

					// 继续进行子树的递归
					brute_force(layer + 1, current_value, current_weight);

					// 递归出来后回滚数据
					current_weight -= (goods[layer].weight * current_set[layer]);
					current_value -= (goods[layer].value * current_set[layer]);

				}
			}

		}



	public:

		Bag(int N) {
			maxValue = 0;			// 最大价值初始化为0
			set_number = N;			// 初始化元素个数
			initialize_set(N);		// 初始化集合
			print_wv(N);			// 打印信息
		}

		

		// 求解最大价值
		void get_maxValue(int layer, int cv, int cw) {

			// 蛮力法求解
			t1 = getSystemTime();		// 开始计时
			brute_force(layer, cv, cw);
			t2 = getSystemTime();		// 结束计时

			//打印时间
			sum_time = t2 - t1;
			cout &lt;&lt; &quot;蛮力法求解规模为 &quot; &lt;&lt; set_number &lt;&lt; &quot; 的0/1背包所需要的时间为：&quot; &lt;&lt; sum_time &lt;&lt; &quot;ms.&quot; &lt;&lt; endl;

			// 打印结果
			print_set();

		}

		// 根据货物单位价值进行排序
		void sort_set() {		// 计算权值

			for (int i = 0; i &lt; set_number; i++) {
				goods[i].ave_value = double(goods[i].value) / double(goods[i].weight);
			}

			// 根据权值排序
			sort(goods, goods + sizeof(goods) / sizeof(GD), sort_rule());

			// 打印根据权值排序后的内容
			cout &lt;&lt; &quot;根据单位价值排序后的物品重量以及对应的价值为：&quot; &lt;&lt; endl &lt;&lt; &quot;weight -&gt; { &quot;;

			for (int i = 0; i &lt; set_number; i++) {
				cout &lt;&lt; goods[i].weight &lt;&lt; &quot; &quot;;
			}

			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl &lt;&lt; &quot;value -&gt; { &quot;;

			for (int i = 0; i &lt; set_number; i++)
			{
				cout &lt;&lt; goods[i].value &lt;&lt; &quot; &quot;;
			}

			cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
		}
};				// 蛮力法，作为基类

class Bag_with_backtrack : public Bag {		// 继承 Bag 的保护以及公用成员
	
	protected:
		int current_set[MAX] = { 0 };		// define current_set to save current set


		int Bound_sv(int layer, int cv) {

			int i = layer;
			int sv = cv;

			for (i; i &lt; set_number; i++) {
				sv += goods[i].value;		// 剩余物品都装下时的最大价值
			}

			return sv;

		}
		
		double Bound(int layer,int cv,int cw){
			int i = layer;
			
			double sv = double(cv);
			int cr = capacity - cw;

			while (i&lt;set_number &amp;&amp; goods[i].weight &lt;= cr)
			{
				cr -= goods[i].weight;
				sv = sv + goods[i].value;
				i++;
			}

			if (i &lt; set_number)
				sv = sv + goods[i].ave_value * cr;

			return sv;
		}
		

		// Using back track method to get max value
		void BackTrack(int layer, int current_value, int current_weight) {
			// layer代表回溯层数，其余参数分别代表当前价值以及当前重量
			//double expect_sumValue = 0;		// 记录期望价值总和

			if (layer == set_number) {		// if layer bigger than number, over
				// 注意这个地方，不用大于 ！！！

				if (current_value &gt; maxValue) {

					maxValue = current_value;

					for (int i = 0; i &lt; set_number; i++) {
						max_set[i] = current_set[i];

					}
				}
			}
			else
			{
				for (int j = 0; j &lt;= 1; j++) {

					current_set[layer] = j;

					/************************剪枝**************************/
					

					if (
						current_weight + current_set[layer] * goods[layer].weight &lt;= capacity
						&amp;&amp; Bound_sv(layer,current_value) &gt;= maxValue &amp;&amp; Bound(layer,current_value,current_weight) &gt; maxValue
						)
					{
						// 更新当前背包物品的总重量，目前背包物品的总价值
						current_weight += (goods[layer].weight * current_set[layer]);
						current_value += (goods[layer].value * current_set[layer]);

						// 继续进行子树的递归
						BackTrack(layer + 1, current_value, current_weight);

						// 递归出来后回滚数据
						current_weight -= (goods[layer].weight * current_set[layer]);
						current_value -= (goods[layer].value * current_set[layer]);

					}
				}
			}

		}


	public:

		Bag_with_backtrack(int N) :Bag(N) {
			cout &lt;&lt; &quot;回溯法对象实例化...&quot; &lt;&lt; endl;
		}


		void get_maxValue_by_backTrack(int layer, int current_value, int current_weight) {

			// 按照单位价值进行排序
			t1 = getSystemTime(); // 开始计时
			sort_set();

			// 使用回溯法进行求解
			BackTrack(layer, current_value, current_weight);
			t2 = getSystemTime();	// 结束计时
			
			// 打印时间
			sum_time = t2 - t1;
			cout &lt;&lt; &quot;回溯法求解规模为 &quot; &lt;&lt; set_number &lt;&lt; &quot; 的0/1背包问题所需要的时间为：&quot; &lt;&lt; sum_time &lt;&lt; &quot;ms.&quot; &lt;&lt; endl;

			// 打印集合
			print_set();
		}

		
};		// 回溯法，继承基类Bag


class Bag_with_branchAndbound :public Bag {		// 从 Bag 类中派生

	protected:
		
		int tree_node_id = 1;		// 解空间树结点id 1开始
		
		int lower_bound = 0;		// 目标函数的下界

		// 贪心法求背包容量的下界
		int greed() {

			int temp[MAX] = { 0 };		// 定义临时数组，用来表示货物向量，并初始化为0
			int cap = capacity;			// 暂存背包容量
			int w = 0;					// 当前背包容量
			int updown = 0;				// 下界
			
			// 对背包物品按照单位价值进行排序
			sort_set();

			// 求解
			for (int i = 0; i &lt; set_number; i++) {

				// 如果超重，跳出
				if ((w+goods[i].weight) &gt; cap) {
					continue;
				}

				temp[i] = 1;
				w += goods[i].weight;
				updown += (temp[i] * goods[i].value);
			}

			cout &lt;&lt; &quot;解的下界是：&quot; &lt;&lt; updown &lt;&lt; endl;

			return updown;

		}


		// 限界函数求上界
		void limit(ND &amp;n)				        //计算分枝结点的上界
		{
			// 下一个要选的物品就是第layer层物品
			int w = n.current_weight;
			double v = n.current_value;
			int i = n.layer;

			while (i &lt; set_number &amp;&amp; w + goods[i].weight &lt;= capacity) {
				w += goods[i].weight;
				v += goods[i].value;
				i++;
			}

			if (i &lt; set_number) {  // 装部分物品
				n.ub = v + (capacity - w)*goods[i].ave_value;
			}
			else
			{
				n.ub = v;
			}
		}

		// 优先队列进队操作
		void EnQueue(ND n, priority_queue&lt;ND&gt; &amp;q) {
			if (n.layer == set_number) {		// 已经到达叶子结点

				if (n.current_value &gt; maxValue) {		// 更新maxValue
					maxValue = n.current_value;
					for (int i = 0; i &lt; set_number; i++) {
						max_set[i] = n.cset[i];
					}
				}
			}
			else {
				q.push(n);			// 非叶子结点进队
			}
		}

		// 分支限界法
		void branchAndbound() {

			// 首先使用贪心法求解此goods集合的目标值下界
			lower_bound = greed();

			priority_queue&lt;ND&gt; q;		// 优先队列
			ND n0, n1, n2;				// 先定义根结点，左孩子结点，右孩子结点

			/*初始化根节点*/
			n0.id = tree_node_id++;		
			n0.layer = 0;
			n0.current_value = 0;
			n0.current_weight = 0;
			for (int i = 0; i &lt; set_number; i++) {
				n0.cset[i] = 0;
			}
			limit(n0);					// 求根结点上界
			q.push(n0);					// 根结点进队

			while (!q.empty())			// 队不空循环
			{
				n0 = q.top();				// 取队头
				q.pop();				// 出队
				if (n0.current_weight + goods[n0.layer].weight &lt;= capacity &amp;&amp; n0.ub &gt;= lower_bound) {	// 超重剪枝 小于最小期望重量剪枝

					// 设置左孩子结点
					n1.id = tree_node_id++;
					n1.layer = n0.layer + 1;
					n1.current_weight = n0.current_weight + goods[n0.layer].weight;
					n1.current_value = n0.current_value + goods[n0.layer].value;
					/*复制解向量*/
					for (int i = 0; i &lt; set_number; i++) {
						n1.cset[i] = n0.cset[i];
					}
					n1.cset[n1.layer-1] = 1;			// 更新解向量
					limit(n1);						// 求限界函数上界
					EnQueue(n1, q);					// 左孩子进队
				}

				// 设置右孩子结点
				n2.id = tree_node_id++;
				n2.layer = n0.layer + 1;
				n2.current_value = n0.current_value;
				n2.current_weight = n0.current_weight;

				// 复制解向量
				for (int i = 0; i &lt; set_number; i++) {
					n2.cset[i] = n0.cset[i];
				}

				
				n2.cset[n2.layer-1] = 0;		 // 更新解向量
				limit(n2);					// 求界限函数上界
				
				if (n2.ub &gt; maxValue &amp;&amp; n2.ub &gt;= lower_bound) {		// 剪枝，期望最大值小于已有最大值就剪枝  小于最小期望重量剪枝
					EnQueue(n2, q);
				}

			}
		}


	public:

		Bag_with_branchAndbound(int N) :Bag(N) {

			cout &lt;&lt; &quot;分支限界法对象实例化...&quot; &lt;&lt; endl;
		
		}

		void get_maxValue_by_branchAndbound() {
			
			// 分支限界法
			t1 = getSystemTime();		// 开始计时
			branchAndbound();
			t2 = getSystemTime();		// 结束计时

			// 计算并打印时间
			sum_time = t2 - t1;
			cout &lt;&lt; &quot;使用分支限界法求解问题规模为&quot; &lt;&lt; set_number &lt;&lt; &quot; 的0/1背包问题所需要的时间为：&quot; &lt;&lt; sum_time &lt;&lt; &quot;ms.&quot; &lt;&lt; endl;
			
			// 打印集合
			print_set();
		}
		

};		// 


int main() {

	srand((unsigned)time(NULL));
	
	/*************蛮力法************/
	//for (int i = 0; i &lt; 40; i++) {
	//	Bag bag = Bag(i);
	//	bag.get_maxValue(0, 0, 0);
	//}
	
	
	/************回溯法*************/
	//int n = 1;
	//for (int i = 512; i &lt; 2000; i+=100) {
	//	n *= 2;
	//Bag_with_backtrack bag = Bag_with_backtrack(4);
	//bag.get_maxValue_by_backTrack(0, 0, 0);
	//}
	
	

	/************分支限界法*************/
	//Bag_with_branchAndbound bag = Bag_with_branchAndbound(5);
	//bag.get_maxValue_by_branchAndbound();

	//for (int n = 1; n &lt;= 5000; n*=2) {
		Bag_with_branchAndbound bag = Bag_with_branchAndbound(4);
		bag.get_maxValue_by_branchAndbound();
	//}
	

	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《热风》节选]]></title>
        <id>https://lizonglin313.github.io/post/《热风》节选</id>
        <link href="https://lizonglin313.github.io/post/《热风》节选">
        </link>
        <updated>2019-10-11T14:40:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>所以我时常害怕，愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能<br>
做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点<br>
光，不必等候炬火。<br>
　　此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的<br>
消失，不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在<br>
内。<br>
　　我又愿中国青年都只是向上走，不必理会这冷笑和暗箭。<br>
　　尼采说：<br>
　　<br>
　　“真的，人是一个浊流。应该是海了，能容这浊流使他干净。<br>
　　“咄，我教你们超人：这便是海，在他这里，能容下你们的大侮蔑。”（《札拉图<br>
如是说》的《序言》第三节）</p>
<p>纵令不过一洼浅水，也可以学学大海；横竖都是水，可以相通。几粒石子，任他们暗地<br>
里掷来；几滴秽水，任他们从背后泼来就是了。<br>
　　这还算不到“大侮蔑”——因为大侮蔑也须有胆力。<br>
　　																		                                                   ----    鲁迅《热风》</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Google Bigtable论文要点整理]]></title>
        <id>https://lizonglin313.github.io/post/Google-Bigtable论文要点整理</id>
        <link href="https://lizonglin313.github.io/post/Google-Bigtable论文要点整理">
        </link>
        <updated>2019-10-07T06:53:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="google-bigtable">Google Bigtable</h1>
<blockquote>
<p>Google Bigtable论文要点整理</p>
</blockquote>
<h2 id="摘要">摘要</h2>
<h3 id="本质及用途">本质及用途</h3>
<ul>
<li>分布式的结构化数据存储系统</li>
<li>被设计用来处理海量数据（通常是分布在数千台普通服务器上的 PB 级的数据）</li>
</ul>
<h3 id="应用">应用</h3>
<ul>
<li>Web索引</li>
<li>Google Earth</li>
<li>Google Finanace</li>
</ul>
<h3 id="本文所做的">本文所做的</h3>
<p>本论文描述了 Bigtable 提供的简单的数据模型。利用这个模型，用户可以动态的控制数据的分布和格式。<br>
我们还将描述 Bigtable 的设计和实现。</p>
<h2 id="介绍">介绍</h2>
<h3 id="bigtable的目标">Bigtable的目标</h3>
<ul>
<li>适用性广泛</li>
<li>可扩展</li>
<li>高性能</li>
<li>高可用性</li>
</ul>
<h3 id="与传统数据库的异同">与传统数据库的异同</h3>
<p>相同点：</p>
<ul>
<li>使用很多数据库的实现策略</li>
</ul>
<p>不同点：</p>
<ul>
<li>Bigtable 不支持完整的关系数据模型</li>
<li>Bigtable 为客户提供了简单的数据模型，利用这个模型，客户可以动态控制数据的分布和格式，用户也可以自己推测底层存储数据的位置相关性</li>
</ul>
<h3 id="数据">数据</h3>
<ul>
<li>数据的下标是行和列的名字</li>
<li>名字可以是任意字符串</li>
<li>存储的数据均视为字符串</li>
<li>Bigtable本身不会去解析</li>
<li>客户存入结构化或半结构化数据，通过选择数据模式，用户可以控制数据位置的相关性</li>
<li>通过参数调节存放位置：内存 | 硬盘</li>
</ul>
<h2 id="数据模型">数据模型</h2>
<p>Bigtable 是一个稀疏的、分布式的、持久化存储的多维度排序 Map。Map 的索引是行关键字、列关键字<br>
以及时间戳；Map 中的每个 value 都是一个未经解析的 byte 数组。</p>
<pre><code class="language-cpp"> (row:string, column:string,time:int64)-&gt;string
</code></pre>
<p>Webtable</p>
<ul>
<li>行关键字：URL</li>
<li>列名：网页的某些属性</li>
<li>contents列：存储网页的某些属性</li>
<li>标识：网页的时间戳</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/10/07/R1ZUGxPod82NriE.png" alt="" loading="lazy"></figure>
<center/>图1 一个存储Web网页的例子的表的片段
<ul>
<li>行名：反向URL</li>
<li>contents列族：网页的内容</li>
<li>anchor列族：引用该网页的锚链接文本</li>
</ul>
<h3 id="行">行</h3>
<p>行关键字：</p>
<ul>
<li>任意字符串（最大支持64KB）</li>
<li>同一行关键字读写操作都为原子操作</li>
</ul>
<p>Tablet</p>
<ul>
<li>Bigtable通过行关键字字典顺序组织数据</li>
<li>表中每行可以动态分区，每个分区叫Tablet，是数据分布和负载均衡调整的最小单位</li>
</ul>
<h3 id="列族">列族</h3>
<ul>
<li>列关键字组成的集合叫做“列族“，是访问控制的基本单位</li>
<li>同一列族下的所有数据通常都属于同一个类型</li>
<li>列族在使用之前必须先创建，然后才能在列族中任何的列关键字下存放数据</li>
<li>创建后，其中的任何一个列关键字下都可以存放数据</li>
<li>一张表中列族不能太多（最多几百个）</li>
<li>但是一张表中可以有无限多个列</li>
</ul>
<h4 id="列关键字命名">列关键字命名</h4>
<p>语法：</p>
<pre><code>列族：限定词
</code></pre>
<p>列组名字：可打印字符串</p>
<p>限定词：任意的字符串</p>
<blockquote>
<p>比如，Webtable 有个列族 language，language 列族用来存放撰写网页的语言。我们在 language列族中只使用一个列关键字，用来存放每个网页的语言标识 ID。Webtable 中另一个有用的列族是 anchor；这个列族的每一个列关键字代表一个锚链接，如图一所示。Anchor 列族的限定词是引用该网页的站点名；Anchor列族每列的数据项存放的是链接文本。</p>
</blockquote>
<h4 id="控制权限">控制权限</h4>
<ul>
<li>访问控制、磁盘和内存的使用统计都是在列族层面进行</li>
</ul>
<p>在我们的 Webtable 的例子中，上述的控制权限能帮助我们管理不同类型的应用：</p>
<ul>
<li>允许一些应用可以添加新的基本数据</li>
<li>一些应用可以读取基本数据并创建继承的列族</li>
<li>一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）</li>
</ul>
<h3 id="时间戳">时间戳</h3>
<p>在 Bigtable 中，表的每一个数据项都可以包含同一份数据的不同版本；不同版本的数据通过<strong>时间戳</strong>来索引。</p>
<p>时间戳：</p>
<ul>
<li>64位整型</li>
<li>Bigtable可以给时间戳赋值，精确到ms</li>
<li>用户可以给时间戳赋值</li>
<li>不同版本数据按照时间戳倒序排序，最新的数据在最前面</li>
</ul>
<p>垃圾回收：</p>
<p>为了减轻多个版本数据的管理负担，我们对每一个列族配有两个设置参数，Bigtable 通过这两个参数可以对废弃版本的数据自动进行垃圾收集。用户可以指定只保存最后 n 个版本的数据，或者只保存“足够新”的版本的数据（比如，只保存最近 7 天的内容写入的数据）。 、</p>
<h2 id="api">API</h2>
<h3 id="bigtable提供的api">Bigtable提供的API</h3>
<ul>
<li>建立和删除表以及列族的API函数</li>
<li>修改集群、表和列族的元数据的API</li>
</ul>
<p>例如修改访问权限：</p>
<pre><code class="language-c++"> // Open the table 
Table *T = OpenOrDie(“/bigtable/web/webtable”); 
// Write a new anchor and delete an old anchor 
RowMutation r1(T, “com.cnn.www”); 
r1.Set(“anchor:www.c-span.org”, “CNN”); 
r1.Delete(“anchor:www.abc.com”); 
Operation op; 
Apply(&amp;op, &amp;r1);

/*
 *客户程序可以对 Bigtable 进行如下的操作：写入或者删除 Bigtable 中的值、从每个行中查找值、或者遍历表中 
 *的一个数据子集。图 2 中的Ｃ++代码使用 RowMutation 抽象对象进行了一系列的更新操作。（为了保持示例代码的 
 *简洁，我们忽略了一些细节相关代码）。调用 Apply 函数对Ｗebtable 进行了一个原子修改操作：它为
 *www.cnn.com 增加了一个锚点，同时删除了另外一个锚点。
 */
</code></pre>
<pre><code class="language-cpp">Scanner scanner(T); 
ScanStream *stream; 
stream = scanner.FetchColumnFamily(“anchor”); 
stream-&gt;SetReturnAllVersions(); 
scanner.Lookup(“com.cnn.www”); 
for (; !stream-&gt;Done(); stream-&gt;Next()) { 
    printf(“%s %s %lld %s\n”, 
    scanner.RowName(), 
    stream-&gt;ColumnName(), 
    stream-&gt;MicroTimestamp(), 
    stream-&gt;Value()); 
} 

/*
 *C++代码使用 Scanner 抽象对象遍历一个行内的所有锚点。客户程序可以遍历多个列族，有几种方法可以对扫描输出 
 *的行、列和时间戳进行限制。例如，我们可以限制上面的扫描，让它只输出那些匹配正则表达式*.cnn.com 的锚点，
 *或者那些时间戳在当前时间前 10 天的锚点
*/
</code></pre>
<h3 id="支持的其他特性">支持的其他特性</h3>
<ol>
<li>Bigtable 支持单行上的事务处理：利用这个功能，用户可以对存储在一个行关键字下的数据进行原子性的读-更新-写操作</li>
<li>Bigtable 允许把数据项用做整数计数器</li>
<li>Bigtable 允许用户在服务器的地址空间内执行脚本程序</li>
</ol>
<p>Bigtable 可以和 MapReduce 一起使用，MapReduce 是 Google 开发的大规模并行计算框架。我们已经开发了一些 Wrapper 类，通过使用这些 Wrapper 类，Bigtable 可以作为 MapReduce 框架的输入和输出。</p>
<h2 id="bigtable构建">BigTable构建</h2>
<h3 id="gfs">GFS</h3>
<ul>
<li>BigTable 使用 Google 的分布式文件系统(GFS)存储日志文件和数据文件</li>
</ul>
<h3 id="集群">集群</h3>
<ul>
<li>BigTable 集群通常运行在一个共享的机器池中，池中的机器还会运行其它的各种各样的分布式应用程序，BigTable 的进程经常要和其它应用的进程共享机器</li>
<li>BigTable 依赖集群管理系统来调度任务、管理共享的机器上的资源、处理机器的故障、以及监视机器的状态</li>
</ul>
<h3 id="google-sstable">Google SSTable</h3>
<ul>
<li>BigTable 内部存储数据的文件是 Google SSTable 格式的</li>
</ul>
<blockquote>
<p>SSTable 是一个持久化的、排序的、不可更改的Map 结构，而 Map 是一个 key-value 映射的数据结构，key 和 value 的值都是任意的 Byte 串。可以对 SSTable进行如下的操作：查询与一个 key 值相关的 value，或者遍历某个 key 值范围内的所有的 key-value 对。从内部看，SSTable 是一系列的数据块（通常每个块的大小是 64KB，这个大小是可以配置的）。SSTable 使用块索引（通常存储在 SSTable 的最后）来定位数据块；在打开 SSTable 的时候，索引被加载到内存。每次查找都可以通过一次磁盘搜索完成：首先使用二分查找法在内存中的索引里找到数据块的位置，然后再从硬盘读取相应的数据块。也可以选择把整个 SSTable 都放在内存中，这样就不必访问硬盘了。</p>
</blockquote>
<h3 id="chubby">Chubby</h3>
<ul>
<li>BigTable 还依赖一个高可用的、序列化的分布式锁服务组件，叫做 Chubby</li>
</ul>
<blockquote>
<p>一个 Chubby 服务包括了 5 个活动的副本，其中的一个副本被选为 Master，并且处理请求。只有在大多数副本都是正常运行的，并且彼此之间能够互相通信的情况下，Chubby 服务才是可用的。当有副本失效的时候，Chubby 使用 Paxos 算法来保证副本的一致性。Chubby 提供了一个名字空间，里面包括了目录和小文件。每个目录或者文件可以当成一个锁，读写文件的操作都是原子的。Chubby 客户程序库提供对 Chubby 文件的一致性缓存。每个<br>
Chubby 客户程序都维护一个与 Chubby 服务的会话。如果客户程序不能在租约到期的时间内重新签订会话的租约，这个会话就过期失效了9。当一个会话失效时，它拥有的锁和打开的文件句柄都失效了。Chubby 客户程序可以在文件和目录上注册回调函数，当文件或目录改变、或者会话过期时，回调函数会通知客户程序。</p>
</blockquote>
<p>Bigtable 使用 Chubby 完成以下的几个任务：</p>
<ol>
<li>确保在任何给定的时间内最多只有一个活动的 Master 副本；</li>
<li>存储 BigTable 数据的自引导指令的位置（参考 5.1 节）；</li>
<li>查找 Tablet 服务器，以及在 Tablet 服务器失效时进行善后（5.2 节）；</li>
<li>存储 BigTable 的模式信息（每张表的列族信息）；</li>
<li>以及存储访问控制列表。</li>
</ol>
<p>如果Chubby长时间无法访问，BigTable就会失效。</p>
<h2 id="介绍-2">介绍</h2>
<p>Bigtable包括了主要的三个组件：</p>
<ol>
<li>链接到客户程序中的库</li>
<li>一个Master服务器</li>
<li>多个Tablet服务器</li>
</ol>
<p>根据系统工作负载的变化，BigTable动态的向集群中添加（或删除）Tablet服务器。</p>
<h4 id="master服务器">Master服务器</h4>
<p>Master服务器主要负责以下工作：</p>
<ol>
<li>为 Tablet 服务器分配 Tablets</li>
<li>检测新加入的或者过期失效的 Table 服务器</li>
<li>对 Tablet 服务器进行负载均衡</li>
<li>对保存在 GFS 上的文件进行垃圾收集</li>
<li>处理对模式的相关修改操作，例如建立表和列族</li>
</ol>
<h4 id="tablet服务器">Tablet服务器</h4>
<p>每个 Tablet 服务器都管理一个 <strong>Tablet 的集合</strong>（通常每个服务器有大约数十个至上千个 Tablet）。每个 Tablet服务器负责处理它所加载的 Tablet 的读写操作，以及在 Tablets 过大时，对其进行分割。</p>
<blockquote>
<p>和很多 Single-Master 类型的分布式存储系统【17.21】类似，客户端读取的数据都不经过 Master 服务器：客户程序直接和 Tablet 服务器通信进行读写操作。由于 BigTable 的客户程序不必通过 Master 服务器来获取<br>
Tablet 的位置信息，因此，大多数客户程序甚至完全不需要和 Master 服务器通信。在实际应用中，Master服务器的负载是很轻的。<br>
一个 BigTable 集群存储了很多表，每个表包含了一个 Tablet 的集合，而每个 Tablet 包含了某个范围内的行的所有相关数据。初始状态下，一个表只有一个 Tablet。随着表中数据的增长，它被自动分割成多个Tablet，缺省情况下，每个 Tablet 的尺寸大约是 100MB 到 200MB。</p>
</blockquote>
<h3 id="tablet的位置">Tablet的位置</h3>
<p>我们使用一个三层的、类似Ｂ+树[10]的结构存储 Tablet 的位置信息。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/10/07/3CMUyWopYFdP8D1.png" alt="" loading="lazy"></figure>
<center/>图2 Tablet location hierarchy
<ol>
<li>第一层是一个存储在 Chubby 中的文件，包含 Root Tablet 的位置信息。</li>
<li>Root Tablet 包含一个特殊的 METADATA 表里所有的 Tablet 的位置信息。</li>
<li>METADATA 表的每个 Tablet 包含了一个用户 Tablet 的集合。</li>
<li>Root Tablet 是 METADATA 表的第一个 Tablet，对它的处理比较特殊 ，Root Tablet 永远不会被分割 ，这就保证了 Tablet 的位置信息存储结构不会超过三层。</li>
<li>METADATA 表中每个 Tablet 的位置信息都存放在一个行关键字下面，而这个行关键字是由 Tablet所在的表的标识符和 Tablet 的最后一行编码而成的。</li>
<li>METADATA 的每一行都存储了大约 1KB 的内存数据。</li>
<li>在一个大小适中的、容量限制为 128MB 的 METADATA Tablet 中，采用这种三层结构的存储模式，可以标识<br>
2^34 个 Tablet 的地址（如果每个 Tablet 存储 128MB 数据，那么一共可以存储 2^61 字节数据）。</li>
</ol>
<blockquote>
<p>客户程序使用的库会缓存 Tablet 的位置信息。如果客户程序没有缓存某个 Tablet 的地址信息，或者发现它缓存的地址信息不正确，客户程序就在树状的存储结构中递归的查询 Tablet 位置信息；如果客户端缓存是的，那么寻址算法需要通过三次网络来回通信寻址，这其中包括了一次 Chubby 读操作；如果客户端缓存的地址信息过期了，那么寻址算法可能需要最多６次网络来回通信才能更新数据，因为只有在缓存中没有查到数据的时候才能发现数据过期。</p>
<p>尽管 Tablet 的地址信息是存放在内存里的，对它的操作不必访问 GFS 文件系统，但是，通常我们会通过预取 Tablet 地址来进一步的减少访问的开销：每次需要从 METADATA 表中读取一个 Tablet 的元数据的时候，它都会多读取几个 Tablet 的元数据。</p>
<p>在 METADATA 表中还存储了次级信息，包括每个 Tablet 的事件日志（例如，什么时候一个服务器开始为该 Tablet 提供服务）。这些信息有助于排查错误和性能分析。</p>
</blockquote>
<h3 id="tablet分配">Tablet分配</h3>
<ul>
<li><strong>在任何一个时刻，一个Tablet只能分配给一个Tablet服务器。</strong></li>
</ul>
<p>Master服务器记录了：</p>
<ol>
<li>当前有哪些活跃的Tablet服务器</li>
<li>哪些 Tablet 分配给了哪些 Tablet 服务器</li>
<li>哪些 Tablet 还没有被分配</li>
</ol>
<p>当一个 Tablet 还没有被分配、并且刚好有一个 Tablet 服务器有足够的空闲空间装载该 Tablet 时，Master 服务器会给这个 Tablet 服务器发送一个装载请求，把 Tablet 分配给这个服务器。</p>
<ul>
<li><strong>BigTable 使用 Chubby 跟踪记录 Tablet 服务器的状态。</strong></li>
</ul>
<ol>
<li>当一个 Tablet 服务器启动，它在 Chubby 的一个指定目录下建立一个有唯一性名字的文件，获取该文件的独占锁</li>
<li>Master 服务器实时监控着这个目录（服务器目录），因此 Master 服务器能够知道有新的 Tablet 服务器加入了</li>
<li>如果 Tablet 服务器丢失了 Chubby 上的独占锁，比如由于网络断开导致 Tablet 服务器和 Chubby 的会话丢失，它就停止对 Tablet 提供服务</li>
<li>只要文件还存在，Tablet 服务器就会试图重新获得对该文件的独占锁；如果文件不存在了，那么Tablet 服务器就不能再提供服务了，它会自行退出</li>
<li>当 Tablet 服务器终止时（比如，集群的管理系统将运行该 Tablet 服务器的主机从集群中移除），它会尝试释放它持有的文件锁，这样一来，Master 服务器就能尽快把Tablet 分配到其它的 Tablet 服务器</li>
</ol>
<ul>
<li><strong>Master 服务器负责检查一个 Tablet 服务器是否已经不再为它的 Tablet 提供服务了，并且要尽快重新分配<br>
它加载的 Tablet。</strong></li>
</ul>
<ol>
<li>Master 服务器通过轮询 Tablet 服务器文件锁的状态来检测何时 Tablet 服务器不再为 Tablet提供服务。</li>
<li>如果一个 Tablet 服务器报告它丢失了文件锁，或者 Master 服务器最近几次尝试和它通信都没有得到响应，Master 服务器就会尝试获取该 Tablet 服务器文件的独占锁；如果 Master 服务器成功获取了独占锁，那么就说明 Chubby 是正常运行的，而 Tablet 服务器要么是宕机了、要么是不能和 Chubby 通信了，因此，Master<br>
服务器就删除该 Tablet 服务器在 Chubby 上的服务器文件以确保它不再给 Tablet 提供服务。一旦 Tablet 服务器在 Chubby 上的服务器文件被删除了，Master 服务器就把之前分配给它的所有的 Tablet 放入未分配的 Tablet集合中。</li>
<li>为了确保 Bigtable 集群在 Master 服务器和 Chubby 之间网络出现故障的时候仍然可以使用，Master服务器在它的 Chubby 会话过期后主动退出。但是不管怎样，如同我们前面所描述的，Master 服务器的故障不会改变现有 Tablet 在 Tablet 服务器上的分配状态。</li>
</ol>
<p>当集群管理系统启动了一个 Master 服务器之后，Master 服务器首先要了解当前 Tablet 的分配状态，之后才能够修改分配状态。Master 服务器在启动的时候执行以下步骤：</p>
<ol>
<li>Master 服务器从 Chubby 获取一个唯一的 Master 锁，用来阻止创建其它的 Master 服务器实例；</li>
<li>Master 服务器扫描 Chubby 的服务器文件锁存储目录，获取当前正在运行的服务器列表；</li>
<li>Master 服务器和所有的正在运行的 Tablet 表服务器通信，获取每个 Tablet 服务器上 Tablet 的分配信息；</li>
<li>Master 服务器扫描 METADATA 表获取所有的 Tablet 的集合。</li>
</ol>
<p>在扫描的过程中，当 Master 服务器发现了一个还没有分配的 Tablet，Master 服务器就将这个 Tablet 加入未分配的 Tablet 集合等待合适的时机分配。</p>
<h3 id="tablet服务">Tablet服务</h3>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2019/10/07/QKMJ6qhC42G8E7x.png" alt="" loading="lazy"></figure>
<center/>图5 Tablet Representation
<ul>
<li>Tablet 的持久化状态信息保存在 GFS 上</li>
<li>更新操作提交到 REDO 日志中</li>
</ul>
<h4 id="memtable-和-sstable">MEMTABLE 和 SSTABLE</h4>
<p>Tablet 的持久化状态信息保存在 GFS 上。更新操作提交到 REDO 日志中。</p>
<p>在这些更新操作中，最近提交的那些存放在一个排序的缓存中，我们称这个缓存为 memtable；较早的更新存放在一系列SSTable 中。</p>
<p>为了恢复一个 Tablet，Tablet 服务器首先从 METADATA 表中读取它的元数据。</p>
<p>Tablet 的元数据包含了组成这个 Tablet 的SSTable 的列表，以及一系列的 Redo Point，这些 Redo Point 指向可能含有该 Tablet数据的已提交的日志记录。Tablet 服务器把 SSTable 的索引读进内存，之后通过重复 Redo Point 之后提交的更新来重建 memtable。</p>
<p>当对 Tablet 服务器进行写操作时，Tablet 服务器首先要检查这个操作格式是否正确、操作发起者是否有执行这个操作的权限。一个有效的读操作在一个由一系列 SSTable 和 memtable 合并的视图里执行。由于 SSTable 和 memtable 是按字典排序的数据结构，因此可以高效生成合并视图。</p>
<p>另外，当进行 Tablet 的合并和分割时，正在进行的读写操作能够继续进行。</p>
<h3 id="空间收缩">空间收缩</h3>
<ul>
<li>随着写操作的执行，memtable 的大小不断增加。当 memtable 的尺寸到达一个门限值的时候，这个 memtable就会被冻结，然后创建一个新的 memtable</li>
<li>被冻结住 memtable 会被转换成 SSTable，然后写入 GFS</li>
</ul>
<h4 id="目的">目的</h4>
<p>shrink Tablet 服务器使用的内存，以及在服务器灾难恢复过程中，减少必须从提交日志里读取的数据量。</p>
<h4 id="流程">流程</h4>
<ol>
<li>每一次 Minor Compaction 都会创建一个新的 SSTable。</li>
<li>如果 Minor Compaction 过程不停滞的持续进行下去，读操作可能需要合并来自多个 SSTable 的更新；否则，我们通过定期在后台执行 Merging Compaction 过程合并文件，限制这类文件的数量。</li>
<li>Merging Compaction 过程读取一些 SSTable 和 memtable 的内容，合并成一个新的 SSTable。只要Merging Compaction 过程完成了，输入的这些 SSTable 和 memtable 就可以删除了。</li>
<li>合并所有的 SSTable 并生成一个新的 SSTable 的 Merging Compaction 过程叫作 Major Compaction。由非<br>
Major Compaction 产生的 SSTable 可能含有特殊的删除条目，这些删除条目能够隐藏在旧的、但是依然有效的SSTable中已经删除的数据。</li>
<li>Major Compaction过程生成的SSTable不包含已经删除的信息或数据。</li>
<li>Bigtable循环扫描它所有的 Tablet，并且定期对它们执行 Major Compaction。Major Compaction 机制允许 Bigtable 回收已经删除的数据占有的资源，并且确保 BigTable 能及时清除已经删除的数据。</li>
</ol>
<h2 id="优化">优化</h2>
<h3 id="局部性群组">局部性群组</h3>
<h4 id="特性">特性</h4>
<ul>
<li>
<p>多个列族组合成一个局部性群组</p>
</li>
<li>
<p>Tablet中每个局部性群组都会生成一个单独的SSTable</p>
</li>
<li>
<p>通常将不会一起访问的列族分割成不同的局部性群组可以提高读取效率</p>
<blockquote>
<p>例如，在 Webtable表中，网页的元数据（比如语言和 Checksum）可以在一个局部性群组中，网页的内容可以在另外一个群组：当一个应用程序要读取网页的元数据的时候，它没有必要去读取所有的页面内容。</p>
</blockquote>
</li>
<li>
<p>可以以局部性群组为单位设定一些有用的调试参数</p>
<blockquote>
<p>比如，可以把一个局部性群组设定为全部存储在内存中。Tablet 服务器依照惰性加载的策略将设定为放入内存的局部性群组的 SSTable 装载进内存。加载完成之后，访问属于该局部性群组的列族的时候就不必读取硬盘了。这个特性对于需要频繁访问的小块数据特别有用：在 Bigtable 内部，我们利用这个特性提高 METADATA 表中具有位置相关性的列族的访问速度。</p>
</blockquote>
</li>
</ul>
<h3 id="压缩">压缩</h3>
<h4 id="两遍压缩">两遍压缩</h4>
<p>第一遍采用 Bentley and McIlroy’s 方式，这种方式在一个很大的扫描窗口里对常见的长字符串进行压缩。</p>
<p>第二遍是采用快速压缩算法，即在一个 16KB 的小扫描窗口中寻找重复数据。</p>
<h3 id="通过缓存提高读操作性能">通过缓存提高读操作性能</h3>
<p><strong>二级缓存</strong></p>
<ul>
<li>目的：为例提高读操作的性能</li>
<li>流程：
<ol>
<li>扫描缓存是第一级缓存，主要缓存 Tablet服务器通过 SSTable 接口获取的 Key-Value 对（对于经常要重复读取相同数据的应用程序来说，扫描缓存非常有效）</li>
<li>Block 缓存是二级缓存，缓存的是从 GFS 读取的 SSTable 的 Block（对于经常要读取刚刚读过的数据附近的数据的应用程序来说，Block 缓存更有用）</li>
</ol>
</li>
</ul>
<h4 id="bloom过滤器">Bloom过滤器</h4>
<p>一个读操作必须读取构成 Tablet 状态的所有 SSTable 的数据。如果这些 SSTable 不在内存中，那么就需要多次访问硬盘。我们通过允许客户程序对特定局部性群组的 SSTable 指定 Bloom 过滤器来__减少硬盘访问的次数__。</p>
<h4 id="commit日志的实现">Commit日志的实现</h4>
<p>如果我们把对每个 Tablet 的操作的 Commit 日志都存在一个单独的文件的话，那么就会产生大量的文件，并且这些文件会并行的写入 GFS。根据 GFS 服务器底层文件系统实现的方案，要把这些文件写入不同的磁盘日志文件时，会有大量的磁盘 Seek 操作。另外，由于批量提交25中操作的数目一般比较少，因此，对每个Tablet 设置单独的日志文件也会给批量提交本应具有的优化效果带来很大的负面影响。</p>
<p>为了避免这些问题，我们__设置每个 Tablet 服务器一个 Commit 日志文件，把修改操作的日志以追加方式写入同一个日志文件__，因此__一个实际的日志文件中混合了对多个 Tablet 修改的日志记录__。</p>
<p>使用单个日志显著提高了普通操作的性能，但是将恢复的工作复杂化了。</p>
<p>为了避免多次读取日志文件：</p>
<ol>
<li>把日志按照关键字（table，row name，log sequence number）排序；</li>
<li>排序之后，对同一个 Tablet 的修改操作的日志记录就连续存放在了一起。</li>
</ol>
<p>因此，我们只要一次磁盘 Seek 操作， 之后顺序读取就可以。</p>
<h3 id="tablet恢复提速">Tablet恢复提速</h3>
<ol>
<li>Master 服务器将一个 Tablet 从一个 Tablet 服务器移到另外一个 Tablet 服务器时，源 Tablet 服务器会对这个 Tablet 做一次 Minor Compaction；</li>
<li>这个 Compaction 操作减少了 Tablet 服务器的日志文件中没有归并的记录，从而减少了恢复的时间。</li>
<li>Compaction 完成之后，该服务器就停止为该 Tablet 提供服务；</li>
<li>在卸载 Tablet 之前，源 Tablet 服务器还会再做一次（通常会很快）Minor Compaction，以消除前面在一次压缩过程中又产生的未归并的记录；</li>
<li>第二次 Minor Compaction 完成以后，Tablet 就可以被装载到新的 Tablet 服务器上了，并且不需要从日志中进行恢复。</li>
</ol>
<h3 id="利用不变性">利用不变性</h3>
<ul>
<li>在使用 Bigtable 时，除了 SSTable 缓存之外的其它部分产生的 SSTable 都是不变的，我们可以利用这一点对系统进行简化：例如，当从 SSTable 读取数据的时候，我们不必对文件系统访问操作进行同步，这样一来，就可以非常高效的实现对行的并行操作；</li>
<li>memtable 是唯一一个能被读和写操作同时访问的可变数据结构；</li>
<li>对内存表采用 COW(Copy-on-write)机制，这样就允许读写操作并行执行；</li>
<li>可以把永久删除被标记为“删除”的数据的问题，转换成对废弃的SSTable 进行垃圾收集的问题；</li>
<li>每个 Tablet 的 SSTable 都在 METADATA 表中注册了Master 服务器采用“标记-删除”的垃圾回收方式删除 SSTable 集合中废弃的 SSTable；</li>
<li>METADATA 表保存了 Root SSTable的集合；</li>
<li>SSTable 的不变性使得分割 Tablet 的操作非常快捷。我们不必为每个分割出来的 Tablet 建立新的SSTable 集合，而是共享原来的 Tablet 的 SSTable 集合。</li>
</ul>
<h2 id="译者">译者</h2>
<p>作者/编著者：</p>
<p>阎伟</p>
<p>邮件: andy.yanwei@163.com</p>
<p>博客: http://andyblog.sinaapp.com</p>
<p>微博：http://weibo.com/2152410864</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决pip安装PyQt5之后Spyder无法正常打开的问题]]></title>
        <id>https://lizonglin313.github.io/post/解决pip安装PyQt5之后Spyder无法正常打开的问题</id>
        <link href="https://lizonglin313.github.io/post/解决pip安装PyQt5之后Spyder无法正常打开的问题">
        </link>
        <updated>2019-09-24T13:37:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="开发环境">开发环境</h2>
<ul>
<li>Anaconda3 + Pycharm</li>
<li>Python3.7</li>
</ul>
<h2 id="报错描述">报错描述</h2>
<p>我是用的Pycharm+conda的环境进行开发的，有的时候会用到Spyder。</p>
<p>在我安装PyQt5后，使用Pycharm进行GUI的开发后发现，Anaconda中的Spyder打不开了：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/09/24/EJqYLocpkRuAFD3.png" alt="" loading="lazy"></figure>
<p>并有了以下报错：</p>
<pre><code class="language-shell">Traceback (most recent call last):
File &quot;D:\Anaconda\installanaconda\Scripts\spyder-script.py&quot;, line 10, in 
sys.exit(main())
File &quot;D:\Anaconda\installanaconda\lib\site-packages\spyder\app\start.py&quot;, line 186, in main
from spyder.app import mainwindow
File &quot;D:\Anaconda\installanaconda\lib\site-packages\spyder\app\mainwindow.py&quot;, line 90, in 
from qtpy import QtWebEngineWidgets # analysis:ignore
File &quot;D:\Anaconda\installanaconda\lib\site-packages\qtpy\QtWebEngineWidgets.py&quot;, line 22, in 
from PyQt5.QtWebEngineWidgets import QWebEnginePage
ValueError: PyCapsule_GetPointer called with incorrect name
</code></pre>
<p>这个问题原来遇到过，由于没有使用Spyder的需求就一直没有想去解决。这是用于安装的PyQt5与spyder中带有的pyqt版本发生了冲突。于是我最终在stackoverflow上找到了<a href="https://stackoverflow.com/questions/55794101/valueerrorpycapsule-getpointer-called-with-incorrect-name-with-from-pyqt5-qtwe">解决方案</a></p>
<h2 id="解决方案">解决方案</h2>
<p>原文是这样说的：</p>
<p>The solution is to downgrade <code>PyQt5</code>.</p>
<pre><code class="language-py">pip install PyQt5==5.10.1
Collecting PyQt5==5.10.1
  Downloading https://files.pythonhosted.org/packages/a7/22/67cc2bac6ae2cd3a7eabb2a2e91638b94bdc6e0503747e49670ce44bb5b0/PyQt5-5.10.1-5.10.1-cp35.cp36.cp37.cp38-none-win_amd64.whl (81.0MB)
    100% |████████████████████████████████| 81.0MB 187kB/s
Requirement already satisfied: sip&lt;4.20,&gt;=4.19.4 in c:\anaconda3\lib\site-packages (from PyQt5==5.10.1) (4.19.8)
spyder 3.3.4 requires pyqtwebengine&lt;5.13, which is not installed.
Installing collected packages: PyQt5
  Found existing installation: PyQt5 5.12.1
    Uninstalling PyQt5-5.12.1:
      Successfully uninstalled PyQt5-5.12.1
Successfully installed PyQt5-5.10.1
</code></pre>
<p>This problem occurs because the <code>PyQt5</code> I installed is beyond version as the version of <code>spyder</code>.</p>
<p>所以，我将原先的PyQt5进行卸载后，安装了5.10.1版本的PyQt5。</p>
<p>之后对结果进行测试。</p>
<h2 id="结果">结果</h2>
<p>先是看一下Spyder是否正常打开以及运行：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/09/24/EqGTIaXZt7zcoiA.png" alt="" loading="lazy"></figure>
<p>Spyder可以正常打开并且使用了。</p>
<p>然后检查PyQt模块是否能正常使用：</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2019/09/24/fLHzla6yTh8ZqjW.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2019/09/24/At3sGvlrMm82F5I.png" alt="" loading="lazy"></figure>
<p>完事！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Golang构建区块链Part7：网络]]></title>
        <id>https://lizonglin313.github.io/post/使用Golang构建区块链Part7：网络</id>
        <link href="https://lizonglin313.github.io/post/使用Golang构建区块链Part7：网络">
        </link>
        <updated>2019-09-22T00:38:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>终于到最后一篇了~</p>
</blockquote>
<h2 id="引言">引言</h2>
<p>不久之前，我们已经构建了拥有所有关键特性的区块链：匿名的、安全的并且随机产生的地址；区块链数据存储；工作量证明系统；可靠的交易存储。虽然这些特性是至关重要的，但是这还不够。真正让这些特性闪闪发光的，让加密货币成为可能的，是网络。如果一个区块链只在一台机器上运行有什么用呢？当只有一个用户时，加密货币的特性又有什么用处呢？是网络让这些所有的机制工作起来并且变的有用。</p>
<p>你可以把区块链的这些特性想成规则，类似于当人们想生存并繁荣那样所建立的规则制度。一种社会准则。区块链网络是一个遵循这种规则的程序社区，它遵循的这些规则使得网络得以存活。同样的，当人们分享相同的点子，他们会变得更强大，并且能够一起建设更好的生活。如果有人遵循了不同的规则，他们将生活在分离的社会（或者说处境、团体等）。相同的，如果有区块链节点遵守了不同的规则，他将会组成一个分离的网络。</p>
<p>最重要的：没有网络、没有主节点分享相同的规则，这些制度就变得无效。</p>
<blockquote>
<p>免责声明：不幸的是，我没有足够的时间去实现一个真正的P2P网络。在文章中我会展示一个大体上相同的情景，涉及到不同类型的节点。改进这种方案实现一个P2P网络会是一个很好的挑战和锻炼对你来说。同时我也不能保证除此之外的情景在本篇文章中可以实现，将来可能会做，抱歉！</p>
<p>这部分涉及到重大的代码改动，没有必要对其进行全部解释在这里。<a href="https://github.com/Jeiwan/blockchain_go/compare/part_6...part_7#files_bucket">请到这个页面</a>去查看和上一个版本相比的代码改动。</p>
</blockquote>
<h2 id="区块链网络">区块链网络</h2>
<p>区块链网络是去中心化的，这就意味着没有服务器去做获得或者加工数据那样的全职和客户端的那种工作。在区块链网络中它们是节点，区块链网络中每一个节点都是全量的。一个节点就是一切：它既是客户端也是服务器。记住这个是非常重要的，因为这和常见的Web应用是非常不一样的。</p>
<p>区块链网络是P2P（Peer-to-Peer）网络，这意味着节点彼此之间直接相连。它是拓扑学平面，因为这些节点中没有所谓的等级。这是它的原理图表示：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/09/22/RAvCb9GTwKZ84Et.png" alt="" loading="lazy"></figure>
<p>(<a href="http://www.freepik.com/dooder">Business vector created by Dooder - Freepik.com</a>)</p>
<p>这种网络中的节点是很难实现的，因为它们必须执行很多操作。每个节点必须和其他很多节点互相交流，它必须请求其他节点的状态，与自己的状态相比，同时更新自己的状态。</p>
<h2 id="节点角色">节点角色</h2>
<p>尽管每个节点都是全量的，区块链节点可以扮演很多不同的角色在区块链网络中。它们是：</p>
<ol>
<li>
<p>矿工（Miner）</p>
<p>一些节点运行在强大的专业的计算机硬件上（例如ASIC矿机），同时它们唯一的目标是尽可能的用最快的速度挖出新块。矿工是区块链中唯一可能使用工作量证明的，因为挖矿实际上意味着解决PoW难题。在PoS（Proof-of-Stake）区块链中，它们不需要挖矿。</p>
</li>
<li>
<p>全节点（Full node）</p>
<p>这些节点验证那些被矿工挖出来的区块也验证交易。为了做这些，它们必须有区块链的全部副本。同时，这些节点也做着类似于路由的操作，比如帮其他节点去发现别的节点。</p>
<p>区块链中有多个全节点是至关重要的，因为这些节点是决策者：它们决定一个区块或者交易是否合法。</p>
</li>
<li>
<p>SPV（Simplified Payment Verification简单支付验证，我们可以叫它轻节点）</p>
<p>SPV是简单支付验证。这些节点不会存储一个区块链的全部副本，但是它们仍然会验证交易（不是所有的，只是一个子集，例如那些发送给特殊地址的交易）。一个SPV节点依赖一个全节点去获得信息，而且很多SPV可以连接一个全节点。SPV使得钱包应用得以实现：一个不需要下载全部的区块链，但仍然可以验证它们的交易。</p>
</li>
</ol>
<h2 id="网络简化">网络简化</h2>
<p>为了实现在我们的区块链中实现网络，我们需要简化一些事情。问题在于我们没有很多计算机来模仿一个有很多节点的网络。我们不会使用虚拟机或者Docker去解决这个问题，因为这肯造成一些困难：你会需要解决一些虚拟机或者Docker问题，虽然我们的目标仅仅是集中精力于区块链的实现。所有，我们想运行多个区块链节点在一台机器上并且同一时间有多个地址。为了实现这个我们将会使用端口作为节点的标识，取代IP地址。例如，我们有以下地址的节点：<code>127.0.0.1:3000</code>、<code>127.0.0.1:3001</code>、<code>127.0.0.1:3002</code>等等。我们把这些端口叫做节点ID同时使用<code>NODE_ID</code>环境变量来设置它们。因此，你可以在多个命令行窗口中打开它们，设置不同的节点并让不同的节点运行起来。</p>
<p>这个途径也需要不同的区块链和钱包文件。它们现在取决于节点ID同时被命名类似<code>blockchain_3000.db</code>、<code>blockchain_30001.db</code>和<code>wallet_3000.db</code>、<code>wallet_30001.db</code>等等这种类型。</p>
<h2 id="实现">实现</h2>
<p>那么，当你下载时发生什么，就是，下载比特币内核并且首次运行它们的时候发生了什么？它必须连接一些节点去下载区块链最新的状态。考虑到你的计算机不知道所有的这些，或者一些比特币节点，这些节点是什么？</p>
<p>在比特币中写死一个节点是会出错的：这个节点会被攻击或者杀死，这可能导致新的节点不能加入区块链中。取而代之，比特币中，这里的DNS种子（<a href="https://bitcoin.org/en/glossary/dns-seed">DNS seeds</a>）是被写死的。虽然没有节点，但是DNS服务知道一些节点的地址。当你开始启动一个干净的比特币内核时，它将会连接一个种子节点同时获取一个全节点列表，也就是下载区块链的地方。</p>
<p>在我们的实现中，这里将会有一个中心化的困难。我们将有三个节点：</p>
<ol>
<li>中心节点。所有的其他的节点都会连接到这个节点，并且这个节点会在其他节点之间传送数据。</li>
<li>一个矿工节点。这个节点将在内存池中存储新的交易同时当交易达到一定数量时，它将开始新的区块。</li>
<li>一个钱包节点。这个节点将用来在钱包之间发送币。不同于SPV，它将存储一个区块链的全部副本。</li>
</ol>
<h2 id="情景">情景</h2>
<p>本篇文章的目标是实现以下几个场景：</p>
<ol>
<li>中心节点创建区块链。</li>
<li>其他（钱包）节点连接全节点并且下载区块链。</li>
<li>多个（矿工）节点连接中心节点并且下载区块链。</li>
<li>钱包节点创建一个交易。</li>
<li>矿工节点接收一个交易并且在内存池中维护它们。</li>
<li>当内存池中有足够多的交易时，矿工开始挖新的区块。</li>
<li>当新区块被挖出来时，它会被发送到中心节点。</li>
<li>钱包节点跟中心节点相同步。</li>
<li>使用钱包节点检查交易是否成功。</li>
</ol>
<p>这是它类似于比特币的地方。尽管我们不回去构建一个真正的P2P网络，我们要实现一个真正的也是重要的用于比特币的网络。</p>
<h2 id="版本">版本</h2>
<p>节点通过相互通讯的方式进行交流。当新的节点开始运行时，它从一个DNS种子节点中获得几个节点，同时发送它们的版本消息，我们的实现就像下面”</p>
<pre><code class="language-go">type version struct {
    Version    int
    BestHeight int
    AddrFrom   string
}
</code></pre>
<p>我们只有一个区块链版本，所以<code>Version</code>字段不会持有任何重要的信息。<code>BestHeight</code>存储了节点的区块链长度。<code>AddFrom</code>存储发送者的地址。</p>
<p>接受一个<code>version</code>消息有什么用呢？它会用它自己的<code>version</code>消息响应。这类似于握手：在对方预先打招呼之前，没有任何交互的可能。这并非只是礼貌：<code>version</code>被用来找到区块链中更长的部分。当一个节点接收到一条 <code>version</code>消息，它会确认这个节点区块链是否比<code>BastHeight</code>的值更长。如果不是，节点会请求并下载遗失的区块。</p>
<p>为了接受消息，我们需要一个服务：</p>
<pre><code class="language-go">var nodeAddress string
var knownNodes = []string{&quot;localhost:3000&quot;}

func StartServer(nodeID, minerAddress string) {
    nodeAddress = fmt.Sprintf(&quot;localhost:%s&quot;, nodeID)
    miningAddress = minerAddress
    ln, err := net.Listen(protocol, nodeAddress)
    defer ln.Close()

    bc := NewBlockchain(nodeID)

    if nodeAddress != knownNodes[0] {
        sendVersion(knownNodes[0], bc)
    }

    for {
        conn, err := ln.Accept()
        go handleConnection(conn, bc)
    }
}
</code></pre>
<p>首先，我们写死中心节点的地址：每个节点必须知道去哪里连接它进行初始化。<code>minerAddress</code>参数指定了接受挖矿奖励的地址。这个部分：</p>
<pre><code class="language-go">if nodeAddress != knownNodes[0] {
    sendVersion(knownNodes[0], bc)
}
</code></pre>
<p>表明如果当前的节点不是中心节点，它必须发送<code>version</code>消息给中心节点去查看是否它的区块链过时了。</p>
<pre><code class="language-go">func sendVersion(addr string, bc *Blockchain) {
    bestHeight := bc.GetBestHeight()
    payload := gobEncode(version{nodeVersion, bestHeight, nodeAddress})

    request := append(commandToBytes(&quot;version&quot;), payload...)

    sendData(addr, request)
}
</code></pre>
<p>我们的通讯，在低层次来说是字节序列。首先12字节指明命令的名字（这个例子中是<code>version</code>），同时后面的字节将包含<code>gob-encoded</code>消息结构。<code>commandToBytes</code>看起来是这样：</p>
<pre><code class="language-go">func commandToBytes(command string) []byte {
    var bytes [commandLength]byte

    for i, c := range command {
        bytes[i] = byte(c)
    }

    return bytes[:]
}
</code></pre>
<p>它创建了12字节的缓冲区并且用命令名字填满，剩下的字节空闲。这是一个对立的函数：</p>
<pre><code class="language-go">func bytesToCommand(bytes []byte) string {
    var command []byte

    for _, b := range bytes {
        if b != 0x0 {
            command = append(command, b)
        }
    }

    return fmt.Sprintf(&quot;%s&quot;, command)
}
</code></pre>
<p>当一个节点接收命令，它运行<code>bytesToCommand</code>去摘取命令名字同时使用正确的方法处理命令体：</p>
<pre><code class="language-go">func handleConnection(conn net.Conn, bc *Blockchain) {
    request, err := ioutil.ReadAll(conn)
    command := bytesToCommand(request[:commandLength])
    fmt.Printf(&quot;Received %s command\n&quot;, command)

    switch command {
    ...
    case &quot;version&quot;:
        handleVersion(request, bc)
    default:
        fmt.Println(&quot;Unknown command!&quot;)
    }

    conn.Close()
}
</code></pre>
<p>好的，这是<code>version</code>命令处理看起来的样子：</p>
<pre><code class="language-go">func handleVersion(request []byte, bc *Blockchain) {
    var buff bytes.Buffer
    var payload verzion

    buff.Write(request[commandLength:])
    dec := gob.NewDecoder(&amp;buff)
    err := dec.Decode(&amp;payload)

    myBestHeight := bc.GetBestHeight()
    foreignerBestHeight := payload.BestHeight

    if myBestHeight &lt; foreignerBestHeight {
        sendGetBlocks(payload.AddrFrom)
    } else if myBestHeight &gt; foreignerBestHeight {
        sendVersion(payload.AddrFrom, bc)
    }

    if !nodeIsKnown(payload.AddrFrom) {
        knownNodes = append(knownNodes, payload.AddrFrom)
    }
}
</code></pre>
<p>首先，我们需要进行解码并且摘取有效部分。这像其他的所有处理方法（或许我们可以叫处理器）一样，所有我将会在未来省略这些代码片段。</p>
<p>然后一个节点根据通讯消息中的那个比较<code>BestHeight</code>。如果节点的区块链更长，它会回复<code>version</code>消息；否则，它会发送<code>getblocks</code>消息。</p>
<h2 id="getblocks">getblocks</h2>
<pre><code class="language-go">type getblocks struct {
    AddrFrom string
}
</code></pre>
<p><code>getblocks</code>意味着“给我看看你有的区块”（在比特币中，这非常复杂）。主要，它不会说“把你的所有区块给我”，而是请求一个区块哈希列表。这会降低网络负载，因为区块可以被从其他节点下载，同时我们也不想从单一节点下载几十Gb的数据。</p>
<p>处理命令很简单，像下面：</p>
<pre><code class="language-go">func handleGetBlocks(request []byte, bc *Blockchain) {
    ...
    blocks := bc.GetBlockHashes()
    sendInv(payload.AddrFrom, &quot;block&quot;, blocks)
}
</code></pre>
<p>在我们的简单实现中，它会返回所有的区块哈希。</p>
<h2 id="inv">inv</h2>
<pre><code class="language-go">type inv struct {
    AddrFrom string
    Type     string
    Items    [][]byte
}
</code></pre>
<p>比特币使用<code>inv</code>来像其他节点展示当前节点有哪些区块和交易。重申，它不会包含全部的区块和交易，仅仅是它们的哈希。这个<code>Type</code>字段代表这是个区块还是个交易。</p>
<p>处理<code>inv</code>是比较困难的：</p>
<pre><code class="language-go">func handleInv(request []byte, bc *Blockchain) {
    ...
    fmt.Printf(&quot;Recevied inventory with %d %s\n&quot;, len(payload.Items), payload.Type)

    if payload.Type == &quot;block&quot; {
        blocksInTransit = payload.Items

        blockHash := payload.Items[0]
        sendGetData(payload.AddrFrom, &quot;block&quot;, blockHash)

        newInTransit := [][]byte{}
        for _, b := range blocksInTransit {
            if bytes.Compare(b, blockHash) != 0 {
                newInTransit = append(newInTransit, b)
            }
        }
        blocksInTransit = newInTransit
    }

    if payload.Type == &quot;tx&quot; {
        txID := payload.Items[0]

        if mempool[hex.EncodeToString(txID)].ID == nil {
            sendGetData(payload.AddrFrom, &quot;tx&quot;, txID)
        }
    }
}
</code></pre>
<p>如果区块哈希被转移了，我们要在<code>blocksInTransit</code>变量中存储它们来溯源下载区块。这允许我们在不同的节点中下载区块。刚好在把区块放进迁移状态中，我们发送<code>getdata</code>命令去发送<code>inv</code>命令同时更新<code>blocksInTransit</code>。在真正的P2P网络中，我们将会在不同的节点传送区块。</p>
<p>在我们的实现中，我们将不会发送带有很多哈希的<code>inv</code>。这就是为什么<code>payload.Type == &quot;tx&quot;</code>只获取了第一个哈希。接下来我们检查在我们的内存池中是否有哈希，如果没有<code>getdata</code>消息就会被发送。</p>
<h2 id="getdata">getdata</h2>
<pre><code class="language-go">type getdata struct {
    AddrFrom string
    Type     string
    ID       []byte
}
</code></pre>
<p><code>getdata</code>是一个对特定区块或者交易请求，同时它可以只包含一个区块/交易ID。</p>
<pre><code class="language-go">func handleGetData(request []byte, bc *Blockchain) {
    ...
    if payload.Type == &quot;block&quot; {
        block, err := bc.GetBlock([]byte(payload.ID))

        sendBlock(payload.AddrFrom, &amp;block)
    }

    if payload.Type == &quot;tx&quot; {
        txID := hex.EncodeToString(payload.ID)
        tx := mempool[txID]

        sendTx(payload.AddrFrom, &amp;tx)
    }
}
</code></pre>
<p>这个处理器很直接：如果它们请求一个区块，返回这个区块；如果它们请求一个交易，返回这个交易。注意，我们不会检查我们是否拥有这个区块或者交易。这是一个瑕疵：）</p>
<h2 id="block-和-tx">block 和 tx</h2>
<pre><code class="language-go">type block struct {
    AddrFrom string
    Block    []byte
}

type tx struct {
    AddFrom     string
    Transaction []byte
}
</code></pre>
<p>这些消息是真正的传输数据的。</p>
<p>处理<code>block</code>消息是简单：</p>
<pre><code class="language-go">func handleBlock(request []byte, bc *Blockchain) {
    ...

    blockData := payload.Block
    block := DeserializeBlock(blockData)

    fmt.Println(&quot;Recevied a new block!&quot;)
    bc.AddBlock(block)

    fmt.Printf(&quot;Added block %x\n&quot;, block.Hash)

    if len(blocksInTransit) &gt; 0 {
        blockHash := blocksInTransit[0]
        sendGetData(payload.AddrFrom, &quot;block&quot;, blockHash)

        blocksInTransit = blocksInTransit[1:]
    } else {
        UTXOSet := UTXOSet{bc}
        UTXOSet.Reindex()
    }
}
</code></pre>
<p>当我们接受一个区块，我们把它放进我们的区块。如果这里有更多的区块被下载，我们在相同的节点请求下载先前的区块。我们最终下载全部的区块，这个UTXO集合被重新索引。</p>
<blockquote>
<p>TODO: 替换掉无条件的信任，我们应该在把它们添加到区块链中之前验证每个区块。</p>
<p>TODO: 替换掉执行<code>UTXOSet.Reindex()</code>的部分, 应该用<code>UTXOSet.Update(block)</code>，因为区块链太大了。重新索引整个 UTXO 集合会占用大量的时间。</p>
</blockquote>
<p>处理<code>tx</code>消息是非常困难的部分：</p>
<pre><code class="language-go">func handleTx(request []byte, bc *Blockchain) {
    ...
    txData := payload.Transaction
    tx := DeserializeTransaction(txData)
    mempool[hex.EncodeToString(tx.ID)] = tx

    if nodeAddress == knownNodes[0] {
        for _, node := range knownNodes {
            if node != nodeAddress &amp;&amp; node != payload.AddFrom {
                sendInv(node, &quot;tx&quot;, [][]byte{tx.ID})
            }
        }
    } else {
        if len(mempool) &gt;= 2 &amp;&amp; len(miningAddress) &gt; 0 {
        MineTransactions:
            var txs []*Transaction

            for id := range mempool {
                tx := mempool[id]
                if bc.VerifyTransaction(&amp;tx) {
                    txs = append(txs, &amp;tx)
                }
            }

            if len(txs) == 0 {
                fmt.Println(&quot;All transactions are invalid! Waiting for new ones...&quot;)
                return
            }

            cbTx := NewCoinbaseTX(miningAddress, &quot;&quot;)
            txs = append(txs, cbTx)

            newBlock := bc.MineBlock(txs)
            UTXOSet := UTXOSet{bc}
            UTXOSet.Reindex()

            fmt.Println(&quot;New block is mined!&quot;)

            for _, tx := range txs {
                txID := hex.EncodeToString(tx.ID)
                delete(mempool, txID)
            }

            for _, node := range knownNodes {
                if node != nodeAddress {
                    sendInv(node, &quot;block&quot;, [][]byte{newBlock.Hash})
                }
            }

            if len(mempool) &gt; 0 {
                goto MineTransactions
            }
        }
    }
}
</code></pre>
<p>第一件事是把新的交易放到内存池中（重申，交易必须在放入交易池之前经过验证）。下一个部分：</p>
<pre><code class="language-go">if nodeAddress == knownNodes[0] {
    for _, node := range knownNodes {
        if node != nodeAddress &amp;&amp; node != payload.AddFrom {
            sendInv(node, &quot;tx&quot;, [][]byte{tx.ID})
        }
    }
}
</code></pre>
<p>检查当前的节点是不是中心节点。在我们的实现中中心节点不会挖矿。取而代之的，它会发送新的交易给网络中的其他节点。</p>
<p>下一个较大的部分仅仅是挖矿节点。让我们分成小部分来看：</p>
<pre><code class="language-go">if len(mempool) &gt;= 2 &amp;&amp; len(miningAddress) &gt; 0 {
</code></pre>
<p><code>miningAddress</code>只设置挖矿节点。当目前的矿工节点内存池中存在两条或者更多的交易时，挖矿开始。</p>
<pre><code class="language-go">for id := range mempool {
    tx := mempool[id]
    if bc.VerifyTransaction(&amp;tx) {
        txs = append(txs, &amp;tx)
    }
}

if len(txs) == 0 {
    fmt.Println(&quot;All transactions are invalid! Waiting for new ones...&quot;)
    return
}
</code></pre>
<p>首先，内存池中的所有交易被验证。不合法的交易会被忽略，同时如果这里没有合法的交易，挖矿会被中断。</p>
<pre><code class="language-go">cbTx := NewCoinbaseTX(miningAddress, &quot;&quot;)
txs = append(txs, cbTx)

newBlock := bc.MineBlock(txs)
UTXOSet := UTXOSet{bc}
UTXOSet.Reindex()

fmt.Println(&quot;New block is mined!&quot;)
</code></pre>
<p>验证过的交易被放入区块中，就像铸币交易那样获得奖励。在挖出新块之后，UTXO集合被重新索引。</p>
<blockquote>
<p>TODO：重申，<code>UTXOSet.Update</code>应该替换<code>UTXOSet.Reindex</code>。</p>
</blockquote>
<pre><code class="language-go">for _, tx := range txs {
    txID := hex.EncodeToString(tx.ID)
    delete(mempool, txID)
}

for _, node := range knownNodes {
    if node != nodeAddress {
        sendInv(node, &quot;block&quot;, [][]byte{newBlock.Hash})
    }
}

if len(mempool) &gt; 0 {
    goto MineTransactions
}
</code></pre>
<p>在交易被挖出后，它被从内存池中移除。当前节点知道的其他节点，收到带有新区块哈希的<code>inv</code>消息。在处理了这条消息后，它们可以请求这个区块。</p>
<h2 id="结果">结果</h2>
<p>让我们演示一下此前定义的场景。</p>
<p>首先，在第一个终端窗口设置<code>NODE_ID</code>为3000（<code>export NODE_ID=3000</code>）。我将会使用类似于<code>NODE 3000</code>或者<code>NODE 3001</code>在接下来的部分，你得知道哪个节点做什么。</p>
<h3 id="noed-3000">NOED 3000</h3>
<p>创建一个钱包和一个新链：</p>
<pre><code class="language-shell">$ blockchain_go createblockchain -address CENTREAL_NODE
</code></pre>
<p>(我将使用假地址因为表述方便清晰)</p>
<p>之后，区块链包含了一个创世纪块。我们需要存储这个区块并且在其他节点中使用。创世纪块作为区块链的标识（在比特币内核中，创世纪块是被写死的）。</p>
<pre><code class="language-shell">$ cp blockchain_3000.db blockchain_genesis.db 
</code></pre>
<h3 id="node-3001">NODE 3001</h3>
<p>接下来，打开一个新的终端窗口设置节点ID为3001。这会是一个钱包节点。使用<code>blockchain_go createwallet</code>产生一些地址，我们叫这些地址<code>WALLET_1</code>，<code>WALLET_2</code>，<code>WALLET_3</code>。</p>
<h3 id="node-3000">NODE 3000</h3>
<p>发送一些币给这些钱包地址：</p>
<pre><code class="language-shell">$ blockchain_go send -from CENTREAL_NODE -to WALLET_1 -amount 10 -mine
$ blockchain_go send -from CENTREAL_NODE -to WALLET_2 -amount 10 -mine
</code></pre>
<p><code>-mine</code>标识意味区块被当前节点及时挖矿。我们需要这个参数因为最初网络中没有挖矿节点。</p>
<p>运行节点：</p>
<pre><code class="language-shell">$ blockchain_go startnode
</code></pre>
<p>这个节点必须一直运行直到使用场景结束。</p>
<h3 id="node-3001-2">NODE 3001</h3>
<p>使用上面保存的创世纪块初始区块链：</p>
<pre><code class="language-shell">$ cp blockchain_genesis.db blockchain_3001.db
</code></pre>
<p>运行节点：</p>
<pre><code class="language-shell">$ blockchain_go startnode
</code></pre>
<p>它将会从中心节点中下载所有区块。去检查每件事情是否ok，停下节点检查一下余额：</p>
<pre><code class="language-shell">$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 10

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 10
</code></pre>
<p>同时，我们可以在<code>CENTRAL_NODE</code>地址中检查余额，因为3001节点中有它的区块链了：</p>
<pre><code class="language-shell">$ blockchain_go getbalance -address CENTRAL_NODE
Balance of 'CENTRAL_NODE': 10
</code></pre>
<h3 id="node-3002">NODE 3002</h3>
<p>打开一个新的终端窗口设置节点ID为3002，产生一个钱包。这将会是一个挖矿节点。初始化这个区块链：</p>
<pre><code class="language-shell">$ cp blockchain_genesis.db blockchain_3002.db
</code></pre>
<p>运行节点：</p>
<pre><code class="language-shell">$ blockchain_go startnode -miner MINER_WALLET
</code></pre>
<h3 id="node-3001-3">NODE 3001</h3>
<p>发送一个币：</p>
<pre><code class="language-shell">$ blockchain_go send -from WALLET_1 -to WALLET_3 -amount 1
$ blockchain_go send -from WALLET_2 -to WALLET_4 -amount 1
</code></pre>
<h3 id="node-3002-2">NODE 3002</h3>
<p>速速！转到矿工节点能看到它正在挖一个区块！同时，检查中心节点的输出。</p>
<h3 id="noed-3001">NOED 3001</h3>
<p>切换的钱包节点并运行它：</p>
<pre><code class="language-shell">$ blockchain_go startnode
</code></pre>
<p>它将会下载新的区块！</p>
<p>停下来检查余额：</p>
<pre><code class="language-shell">$ blockchain_go getbalance -address WALLET_1
Balance of 'WALLET_1': 9

$ blockchain_go getbalance -address WALLET_2
Balance of 'WALLET_2': 9

$ blockchain_go getbalance -address WALLET_3
Balance of 'WALLET_3': 1

$ blockchain_go getbalance -address WALLET_4
Balance of 'WALLET_4': 1

$ blockchain_go getbalance -address MINER_WALLET
Balance of 'MINER_WALLET': 10
</code></pre>
<p>这就是了！</p>
<h2 id="总结">总结</h2>
<p>这是本系列的最后一部分了。我可以出更多的文章来实现一个真正的P2P网络原型，但是我没有时间去做这些了。我希望这些文章回答了你一些关于比特币的技术问题并产生了新的问题，你可以自己去寻找答案。在比特币技术中还有更多有趣的事情隐藏在其中！祝你好运！</p>
<p>P.S. 你可以通过实现<code>addr</code>消息来开始改进这个网络，就像是比特币网络协议中所描述的那样(链接在下面)。这是非常重要的消息，因为这使得节点可以发现彼此。我已经开始着手实现它了，但是还没完成！</p>
<p>Links:</p>
<ol>
<li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_7">Source codes</a></li>
<li><a href="https://en.bitcoin.it/wiki/Protocol_documentation">Bitcoin protocol documentation</a></li>
<li><a href="https://en.bitcoin.it/wiki/Network">Bitcoin network</a></li>
</ol>
<h2 id="最后">最后</h2>
<p>用了18天的时间，断断续续实现了这个简化的加密货币系统，翻完了这系列的微博。其中存在的一些错误和不足希望大家与我交流，谢谢包容！</p>
<p>最重要的，感谢本系列博客原作和我发现的首位将其翻译成中文的博主，下面是他们的连接：</p>
<ul>
<li><a href="https://jeiwan.cc/">Ivan Kuznetsov</a></li>
<li><a href="https://annatarhe.github.io/">AnnatarHe</a></li>
</ul>
<p>以及Github上的中文翻译版本：</p>
<ul>
<li><a href="https://github.com/liuchengxu/blockchain-tutorial">liuchengxu/blockchain-tutorial</a></li>
</ul>
<p>感谢以上，让我初步真正的探索到区块链及比特币技术的底层世界。在未来，我会对我从接触区块链到现在写出并理解一个简单底层系统原型的路程做一个小总结，为有需要朋友提供入门指南。</p>
<p>路还很长，不过已经上路了！加油！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Golang构建区块链Part6：交易-2]]></title>
        <id>https://lizonglin313.github.io/post/使用Golang构建区块链Part6：交易-2</id>
        <link href="https://lizonglin313.github.io/post/使用Golang构建区块链Part6：交易-2">
        </link>
        <updated>2019-09-17T04:35:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>最近事情比较多，这一篇现在才更。又开始忙起来了~在本篇文章所涉及到的代码实现中，大部分改动相比之前的在条理和逻辑上更加清晰。</p>
</blockquote>
<h2 id="引言">引言</h2>
<p>在本系列文章中的最开始，我说过区块链是一个分布式数据库。那时，我们决定先跳过“分布式”的部分而把精力放到“数据库”相关的内容。不久之前，我们几乎已经实现了所有的关于数据库部分的内容。在这篇文章中，会覆盖到先前我们跳过的一些机制，同时在下一篇文章中，我们会开始着手于区块链的分布式特性。</p>
<p>先前的章节：</p>
<ol>
<li><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-1/">Basic Prototype</a></li>
<li><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-2/">Proof-of-Work</a></li>
<li><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-3/">Persistence and CLI</a></li>
<li><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-4/">Transactions 1</a></li>
<li><a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-5/">Addresses</a></li>
</ol>
<p>（原文地址可能无法访问）</p>
<blockquote>
<p>本部分只介绍有重大变化的代码，所以在这里将它们全部进行解释是没有必要的。请根据<a href="https://github.com/Jeiwan/blockchain_go/compare/part_5...part_6#files_bucket">这个页面</a>去看代码的变动（与上一篇文章比较）。</p>
</blockquote>
<h2 id="奖励">奖励</h2>
<p>在先前的文章中，我们跳过了一个很细微的细节就是挖矿奖励。现在我们具有了实现它的一切。</p>
<p>这个奖励是仅仅是一个<code>coinbase</code>交易。当一个挖矿节点开始挖一个新的区块时，它收集队列中的交易同时为它们准备一个<code>coinbase</code>交易。这个<code>coinbase</code>交易仅仅包含一个矿工公钥哈希的输出。</p>
<p>实现奖励和更新<code>send</code>命令一样简单：</p>
<pre><code class="language-go">func (cli *CLI) send(from, to string, amount int) {
    ...
    bc := NewBlockchain()
    UTXOSet := UTXOSet{bc}
    defer bc.db.Close()

    tx := NewUTXOTransaction(from, to, amount, &amp;UTXOSet)
    cbTx := NewCoinbaseTX(from, &quot;&quot;)
    txs := []*Transaction{cbTx, tx}

    newBlock := bc.MineBlock(txs)
    fmt.Println(&quot;Success!&quot;)
}
</code></pre>
<p>在我们的实现中，创建交易挖出新块的那一个（矿工）会获得奖励。</p>
<h2 id="utxo-集合">UTXO 集合</h2>
<p>在第三部分<a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-3/">持久化和命令行接口</a>中，我们学习了比特币内核将区块存储到数据库的方式。它讲到区块都是存储在<code>blocks</code>数据库的，交易出账是存储在<code>chainstate</code>数据库的。让我提醒你一下<code>chainstate</code>的结构是什么样的：</p>
<ol>
<li>'c' + 32位交易哈希 -&gt; 交易的未花费交易输出记录</li>
<li>'B' + 32位区块哈希 -&gt; 数据库中代表未花费交易输出的区块哈希</li>
</ol>
<p>至这一篇文章，我们已经实现了交易，但是我们并没有去使用<code>chainstate</code>去存储它们的输出。所以，这就是我们现在要去做的。</p>
<p><code>chainstate</code>不会去存储交易。取而代之的，它存储一个叫UTXO的集合，或者说是未花费交易输出的集合。除此之外，它存储了“数据库表示的未花费交易输出的区块哈希”，这儿我们先暂时省略，因为我们还没有使用区块高度（但是我们会在下一篇文章中进行实现）。</p>
<p>所以，为什么我要去实现UTXO集合呢？</p>
<p>考虑到我们先前实现的<code>Blockchain.FindUnspentTransactions</code>方法：</p>
<pre><code class="language-go">func (bc *Blockchain) FindUnspentTransactions(pubKeyHash []byte) []Transaction {
    ...
    bci := bc.Iterator()

    for {
        block := bci.Next()

        for _, tx := range block.Transactions {
            ...
        }

        if len(block.PrevBlockHash) == 0 {
            break
        }
    }
    ...
}
</code></pre>
<p>这个函数寻找还有未花费输出的交易。因为交易是存储在区块中的，它迭代区块链中的每一个区块同时检查里面的每一个交易。在2017年9月18日是，比特币中就已经有485,860个区块了，整个数据库使用了140+Gb的磁盘空间。这意味着一个人需要运行整个节点去验证交易。此外，验证交易需要迭代很多区块。</p>
<p>这个问题的解决方案就是，只为存储的未花费出账建立一个索引，这就是UTXO集合所做的事情：这就是一个从所有区块链交易中所建立的一个高速缓存（通过迭代所有区块，是的，但是只需要做一次），在后面也用这个来计算余额以及验证新的交易。2017年9月的时候，UTXO集合需要大概2.7Gb。</p>
<p>好的，让我们想想我们实现UTXO集合的话需要做哪些改变。目前，下面的函数是用来寻找交易的：</p>
<ol>
<li><code>Blockchain.FindUnspentTransactions</code> - 主要功能是寻找含有未花费交易输出的交易。这是遍历所有区块的地方。</li>
<li><code>Blockchain.FindSpendableOutputs</code> - 这个函数在一个新的交易被创建时被使用。如果找到的数额足够出账的需求。使用<code>Blockchain.FindUnspentTransactions</code>。</li>
<li><code>Blockchain.FindUTXO</code> - 为一个公钥哈希寻找未花费交易输出，用来获取余额。使用了<code>Blockchain.FindUnspentTransactions</code>。</li>
<li><code>Blockchain.FindTransaction</code> - 通过一个交易的ID在区块链中寻找这个交易。它迭代所有区块去直至找到它。</li>
</ol>
<p>正如你所看到的，所有的方法都迭代了数据库中的所有区块。但是我们现在不能改进它们，因为UTXO集合没有存储所有的交易，仅仅存储了那些包含未花费交易输出的。因此，它不能被用于<code>Blockchain.FindTransaction</code>。</p>
<p>所以，我们需要下面的这些方法：</p>
<ol>
<li><code>Blockchain.FindUTXO</code> - 通过迭代区块寻找所有的未花费出账。</li>
<li><code>UTXOSet.Reindex</code> - 使用<code>FindUTXO</code>去寻找未花费出账，并且将它们存储到数据库中。这儿就是产生缓存的地方。</li>
<li><code>UTXOSet.FindSpendableOutputs</code> - 这个方法模仿了<code>Blockchain.FindSpendableOutputs</code>方法，只不过使用了UTXO集合。</li>
<li><code>UTXOSet.FindUTXO</code> - 这个方法模仿了<code>Blockchain.FindUTXO</code>方法，同样的只不过使用的是UTXO集合。</li>
<li><code>Blockchain.FindTransaction</code>和之前的一样。</li>
</ol>
<p>因此，最常使用的两个函数将从现在起使用到高速缓存！</p>
<p>让我们开始coding！</p>
<pre><code class="language-go">type UTXOSet struct {
    Blockchain *Blockchain
}
</code></pre>
<p>我们将会使用一个单独的数据库，但是我们将会把UTXO集合存储到一个不同的<code>bucket</code>里。因此，<code>UTXO</code>是和<code>Blockchain</code>成对的。</p>
<pre><code class="language-go">func (u UTXOSet) Reindex() {
    db := u.Blockchain.db
    bucketName := []byte(utxoBucket)

    err := db.Update(func(tx *bolt.Tx) error {
        err := tx.DeleteBucket(bucketName)
        _, err = tx.CreateBucket(bucketName)
    })

    UTXO := u.Blockchain.FindUTXO()

    err = db.Update(func(tx *bolt.Tx) error {
        b := tx.Bucket(bucketName)

        for txID, outs := range UTXO {
            key, err := hex.DecodeString(txID)
            err = b.Put(key, outs.Serialize())
        }
    })
}
</code></pre>
<p>这个方法创建了一个原始的UTXO集合。首先，如果它存在一个<code>bucket</code>的话讲首先将它移除，然后从区块链上寻找所有的未花费交易输出，最后将这些出账存储到<code>bucket</code>里。</p>
<p><code>Blockchain.FindUTXO</code>方法几乎和<code>Blockchain.FindUnspentTransactions</code>是相同的，但是现在它返回一个<code>TransactionID</code>到<code>TransactionOutputs</code>的<code>Map</code>（映射）结构。</p>
<p>现在，UTXO集合可以被用来发送币：</p>
<pre><code class="language-go">func (u UTXOSet) FindSpendableOutputs(pubkeyHash []byte, amount int) (int, map[string][]int) {
    unspentOutputs := make(map[string][]int)
    accumulated := 0
    db := u.Blockchain.db

    err := db.View(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))
        c := b.Cursor()

        for k, v := c.First(); k != nil; k, v = c.Next() {
            txID := hex.EncodeToString(k)
            outs := DeserializeOutputs(v)

            for outIdx, out := range outs.Outputs {
                if out.IsLockedWithKey(pubkeyHash) &amp;&amp; accumulated &lt; amount {
                    accumulated += out.Value
                    unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)
                }
            }
        }
    })

    return accumulated, unspentOutputs
}
</code></pre>
<p>或者用来查询余额：</p>
<pre><code class="language-go">func (u UTXOSet) FindUTXO(pubKeyHash []byte) []TXOutput {
    var UTXOs []TXOutput
    db := u.Blockchain.db

    err := db.View(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))
        c := b.Cursor()

        for k, v := c.First(); k != nil; k, v = c.Next() {
            outs := DeserializeOutputs(v)

            for _, out := range outs.Outputs {
                if out.IsLockedWithKey(pubKeyHash) {
                    UTXOs = append(UTXOs, out)
                }
            }
        }

        return nil
    })

    return UTXOs
}
</code></pre>
<p>这些是对于相应的<code>Blockchain</code>方法相应的微改的版本。这些<code>Blockchain</code>方法不再需要了。</p>
<p>拥有UTXO集合意味着我们数据（交易）是分开去存储的：实际上交易是存储在区块链中的，同时未花费交易输出是存储在UTXO集合中。这样的分开（存储）需要很强的同步机制，因为我们想要UTXO集合总是被更新同时存储最近的交易出账。但是我们不想在每次新块被挖出的时候重建索引，因为我们要避免的正是这种频繁的区块链扫描。因此，我们需要一个更新UTXO集合的机制：</p>
<pre><code class="language-go">func (u UTXOSet) Update(block *Block) {
    db := u.Blockchain.db

    err := db.Update(func(tx *bolt.Tx) error {
        b := tx.Bucket([]byte(utxoBucket))

        for _, tx := range block.Transactions {
            if tx.IsCoinbase() == false {
                for _, vin := range tx.Vin {
                    updatedOuts := TXOutputs{}
                    outsBytes := b.Get(vin.Txid)
                    outs := DeserializeOutputs(outsBytes)

                    for outIdx, out := range outs.Outputs {
                        if outIdx != vin.Vout {
                            updatedOuts.Outputs = append(updatedOuts.Outputs, out)
                        }
                    }

                    if len(updatedOuts.Outputs) == 0 {
                        err := b.Delete(vin.Txid)
                    } else {
                        err := b.Put(vin.Txid, updatedOuts.Serialize())
                    }

                }
            }

            newOutputs := TXOutputs{}
            for _, out := range tx.Vout {
                newOutputs.Outputs = append(newOutputs.Outputs, out)
            }

            err := b.Put(tx.ID, newOutputs.Serialize())
        }
    })
}
</code></pre>
<p>这个函数看起来比较庞大，但是它所做的是非常直接的。当一个新的区块被挖出来时，这个UTXO集合应该被更新。更新意味着移除已花费出账，同时添加从新挖出的交易中所得到的未花费输出。如果一个出账被移除的交易中，不再包含其他的出账，它就被完全移除了。非常简单！</p>
<p>现在让我们在必要的地方使用UTXO集合吧：</p>
<pre><code class="language-go">func (cli *CLI) createBlockchain(address string) {
    ...
    bc := CreateBlockchain(address)
    defer bc.db.Close()

    UTXOSet := UTXOSet{bc}
    UTXOSet.Reindex()
    ...
}
</code></pre>
<p>一个索引的重建发生在一个新的区块链被创建时。例如现在，这里只有一个地方用到<code>Reindex</code>，虽然看起来有些多余在这里，因为在区块链的开始只有一个区块带有一个交易，同时可以用<code>Update</code>去替换它。但是我们可能需要这个重建索引机制在以后。（英语的语言组织规则怎么有点像山东话啊我觉得...看看可以翻译成中式倒装这个句子...）</p>
<pre><code class="language-go">func (cli *CLI) send(from, to string, amount int) {
    ...
    newBlock := bc.MineBlock(txs)
    UTXOSet.Update(newBlock)
}
</code></pre>
<p>然后UTXO集合在新的区块被挖出后更新：</p>
<p>让我们检查一下它的工作：</p>
<pre><code class="language-go">$ blockchain_go createblockchain -address 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1
00000086a725e18ed7e9e06f1051651a4fc46a315a9d298e59e57aeacbe0bf73

Done!

$ blockchain_go send -from 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to 12DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5 -amount 6
0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b

Success!

$ blockchain_go send -from 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1 -to 12ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL -amount 4
000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433

Success!

$ blockchain_go getbalance -address 1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1
Balance of '1F4MbuqjcuJGymjcuYQMUVYB37AWKkSLif': 20

$ blockchain_go getbalance -address 12DkLzLQ4B3gnQt62EPRJGZ38n3zF4Hzt5
Balance of '1XWu6nitBWe6J6v6MXmd5rhdP7dZsExbx': 6

$ blockchain_go getbalance -address 12ncZhA5mFTTnTmHq1aTPYBri4jAK8TacL
Balance of '13UASQpCR8Nr41PojH8Bz4K6cmTCqweskL': 4
</code></pre>
<p>好噢！这个<code>1JnMDSqVoHi4TEFXNw5wJ8skPsPf4LHkQ1</code>地址接受了三次奖励：</p>
<ol>
<li>一次来自挖出创世纪块。</li>
<li>一次来自挖出区块<code>0000001f75cb3a5033aeecbf6a8d378e15b25d026fb0a665c7721a5bb0faa21b</code>。</li>
<li>一次来自挖出区块<code>000000cc51e665d53c78af5e65774a72fc7b864140a8224bf4e7709d8e0fa433</code>。</li>
</ol>
<h2 id="merkle-tree默克尔树">Merkle Tree（默克尔树）</h2>
<p>这里有一个最好的机制我想在这部分讨论一下。</p>
<p>正如我们上文所说的，全部的比特币数据库（或者说区块链）使用了超过140Gb的磁盘空间。由于比特币去中心化的特性，网络中的每个节点必须独立和自给自足，也就是说每个节点必须存储整个区块链的副本。随着更多的人开始使用比特币，这个规则变得很难去遵守：没有可能每个人都去运行全节点。同时，由于节点是网络的成熟的参与者，它们拥有责任：它们必须验证交易和区块。同时，它们需要有确切的互联网流量来与其他节点进行交互并且下载新的区块。</p>
<p>在中本聪发布的<a href="https://bitcoin.org/bitcoin.pdf">比特币原始论文</a>中，对这个问题有一个解决方案：简单支付验证（Simplified Payment Verification SPV）。SPV是一个轻节点，不需要下载全部的区块链也不需要对区块和交易进行验证。取而代之，它在区块中寻找交易（用来验证支付）同时连接到一个全节点检索必要的数据（也就是说轻节点需要某些数据时，可以从连接全节点，在上面下载）。这个机制允许多个轻钱包节点只运行一个全节点。</p>
<p>为了让SPV成为可能，这就应该有一种检查一个区块是否包含特定的交易而不用下载整个区块的方法。这就是Merkle树所做的。</p>
<p>Merkle树被比特币用来获取交易的哈希，也就是之后存储在区块头并且被工作量证明所考虑到。直到现在，我们仅仅连接了区块中每个交易的哈希然后对它们使用<code>SHA-256</code>方法。这也是一个很好的方式来获取区块交易的独一无二的特征值，但是没有Merkle树的优势。</p>
<p>让我们看看Merkle树：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/09/19/QlatOoLygwCJM4E.png" alt="" loading="lazy"></figure>
<p>一个Merkle树是为每一个区块建立的，它从叶节点开始（树的底部），一个叶子是一个交易哈希（比特币使用双重<code>SHA256</code>哈希算法）。叶节点的数目比必须是偶数，但是并不是每一个区块都包含偶数个数的交易。如果一个区块的交易数是奇数，那么最后一个交易将会被复制（在Merkle树中，不是区块中！）。</p>
<p>离开底部，叶节点成对成组，它们的哈希被连接，同时一个新的哈希从它们相连的哈希得到。新的哈希组成新的树节点。这个步骤被重复执行直至仅剩一个节点，叫做树的根节点。这个根哈希被用做这些交易的独一无二的特征代表，被存储在区块头中，用于工作量证明程序。</p>
<p>最后，写代码：</p>
<pre><code class="language-go">type MerkleTree struct {
    RootNode *MerkleNode
}

type MerkleNode struct {
    Left  *MerkleNode
    Right *MerkleNode
    Data  []byte
}
</code></pre>
<p>我们从结构体开始。每一个<code>MerkleNode</code>（Merkle节点）维持数据并且连接到分支上。<code>MerkleNode</code>是真正的连接到下一个节点的根节点，又连接到更远的节点。</p>
<p>让我们首先创建一个节点：</p>
<pre><code class="language-go">func NewMerkleNode(left, right *MerkleNode, data []byte) *MerkleNode {
    mNode := MerkleNode{}

    if left == nil &amp;&amp; right == nil {
        hash := sha256.Sum256(data)
        mNode.Data = hash[:]
    } else {
        prevHashes := append(left.Data, right.Data...)
        hash := sha256.Sum256(prevHashes)
        mNode.Data = hash[:]
    }

    mNode.Left = left
    mNode.Right = right

    return &amp;mNode
}
</code></pre>
<p>每个节点包含一些数据。当一个节点是叶子时，数据在外界获得（我们的实例中是序列化的交易）。当一个节点连接到另一个节点时，它获取它们的数据并且连接它们然后进行哈希运算。</p>
<pre><code class="language-go">func NewMerkleTree(data [][]byte) *MerkleTree {
    var nodes []MerkleNode

    if len(data)%2 != 0 {
        data = append(data, data[len(data)-1])
    }

    for _, datum := range data {
        node := NewMerkleNode(nil, nil, datum)
        nodes = append(nodes, *node)
    }

    for i := 0; i &lt; len(data)/2; i++ {
        var newLevel []MerkleNode

        for j := 0; j &lt; len(nodes); j += 2 {
            node := NewMerkleNode(&amp;nodes[j], &amp;nodes[j+1], nil)
            newLevel = append(newLevel, *node)
        }

        nodes = newLevel
    }

    mTree := MerkleTree{&amp;nodes[0]}

    return &amp;mTree
}
</code></pre>
<p>当一个新的树被创建，第一件事就是确定是否是偶数个叶子。在那之后，数据（一个序列化交易数组）被传入树叶子，然后树开始由这些叶子生长。</p>
<p>现在，让我们修改<code>Block.HashTransactions</code>，在工作量证明中被使用来获取交易哈希：</p>
<pre><code class="language-go">func (b *Block) HashTransactions() []byte {
    var transactions [][]byte

    for _, tx := range b.Transactions {
        transactions = append(transactions, tx.Serialize())
    }
    mTree := NewMerkleTree(transactions)

    return mTree.RootNode.Data
}
</code></pre>
<p>首先，交易被序列化（使用<code>encoding/gob</code>），然后它们被用来构建Merkle树。树的根节点被作为这些区块交易的独一无二的标识来存储。</p>
<h2 id="p2kh">P2KH</h2>
<blockquote>
<p>这部分相当于扩展内容，有关比特币的脚本语言。我好困好想睡~就先转AnnatarHe的了。</p>
</blockquote>
<p>在细节上还有一点要说一下。</p>
<p>你记得吗，在比特币种有一种脚本(<em>Script</em>)编程语言，它被用来锁定交易出账：交易入账提供数据去锁定出账。这个语言非常简单，语言的代码也就仅仅是数据和操作符的排列而已。看下这个例子：</p>
<pre><code class="language-shell">5 2 OP_ADD 7 OP_EQUAL
</code></pre>
<p><strong>5</strong>, <strong>2</strong>, 和 <strong>7</strong> 都是数据. <strong>OP_ADD</strong> 和 <strong>OP_EQUAL</strong> 是操作符。<em>Script</em> 的代码是从左至右执行的：数据的每一块都被塞进栈里然后下个操作会会被栈顶的元素调用。<em>Script</em>的栈只是一个简单的 FILO(先入后出)内存存储：栈中的第一个进去的元素会被最后一个拿走，之后进来的每个元素都是放到前一个的上面。</p>
<p>来分解一下上面这个脚本执行的步骤吧：</p>
<ol>
<li>栈：空。脚本：<strong>5 2 OP_ADD 7 OP_EQUAL</strong></li>
<li>栈：<strong>5</strong>。脚本：<strong>2 OP_ADD 7 OP_EQUAL</strong></li>
<li>栈：<strong>5 2</strong>。脚本：<strong>OP_ADD 7 OP_EQUAL</strong></li>
<li>栈：<strong>7</strong>。脚本：<strong>7 OP_EQUAL</strong></li>
<li>栈：<strong>7 7</strong>。脚本：<strong>OP_EQUAL</strong></li>
<li>栈：<strong>true</strong>。脚本：空</li>
</ol>
<p><strong>OP_ADD</strong>拿走栈上的两个元素，求和，然后把和再塞进栈里。<strong>OP_EQUAL</strong>从栈里拿两个元素，然后比较： 如果一样就把<strong>true</strong> 推到栈里，不一样就把<strong>false</strong>推进去。脚本执行的结果就是栈顶的值：在我们的场景下，它是 <strong>true</strong>，这就意味着脚本正常地成功执行了。</p>
<p>现在来看一眼比特币中执行支付的脚本：</p>
<pre><code class="language-shell">&lt;signature&gt; &lt;pubKey&gt; OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG
</code></pre>
<p>这个脚本被称作<em>付款给公钥哈希(Pay to Public Key Hash)</em>(P2PKH)，这是比特币中最常用的脚本。它就是字面上的给公钥哈希付款的意思，它会用一个确定的公钥锁币。这是 <strong>比特币支付的核心</strong>：无账户，两者之间无资金交互；只有脚本去确认提供的数字签名和公钥是正确的。</p>
<p>此脚本实质上存在两个部分：</p>
<ol>
<li>第一块。<strong>signature</strong>, <strong>pubKey</strong>存在入账的 <strong>ScriptSig</strong> 字段中。</li>
<li>第二部分。<strong>OP_DUP OP_HASH160 pubKeyHash OP_EQUALVERIFY OP_CHECKSIG</strong>存在出账的 <strong>ScriptPubKey</strong> 中。</li>
</ol>
<p>所以，它是定义解锁逻辑的出账，也是提供数据区解锁出账的入账。来执行以下这个脚本：</p>
<p>1 栈: empty 脚本: signature pubKey OP_DUP OP_HASH160 pubKeyHash OP_EQUALVERIFY OP_CHECKSIG</p>
<p>2 栈: signature 脚本: pubKey OP_DUP OP_HASH160 pubKeyHash OP_EQUALVERIFY OP_CHECKSIG</p>
<p>3 栈: signature pubKey 脚本: OP_DUP OP_HASH160 pubKeyHash OP_EQUALVERIFY OP_CHECKSIG</p>
<p>4 栈: signature pubKey pubKey 脚本: OP_HASH160 pubKeyHash OP_EQUALVERIFY OP_CHECKSIG</p>
<p>5 栈: signature pubKey pubKeyHash 脚本: pubKeyHash OP_EQUALVERIFY OP_CHECKSIG</p>
<p>6 栈: signature pubKey pubKeyHash pubKeyHash 脚本: OP_EQUALVERIFY OP_CHECKSIG</p>
<p>7 栈: signature pubKey 脚本: OP_CHECKSIG</p>
<p>8 栈: <strong>true</strong> 或 <strong>false</strong>. Script: empty.</p>
<p><strong>OP_DUP</strong> 复制栈顶的一个元素. <strong>OP_HASH160</strong> 拿走栈顶的元素，并用 <strong>RIPEMD160</strong> 哈希一下; 再把结果塞到栈里. <strong>OP_EQUALVERIFY</strong> 对比栈顶的两个元素，如果不一样就中断脚本的执行. <strong>OP_CHECKSIG</strong> 通过哈希交易，还有 <strong>signature</strong> 和 <strong>pubKey</strong> 来验证交易的签名. 后面的一个操作颇为复杂: 它做了一个简版的交易副本, 对它哈希(因为这是被签名的交易哈希), 然后用提供的 <strong>signature</strong> 和 <strong>pubKey</strong> 验证签名.</p>
<p>有了这样的脚本语言就允许比特币可以成为智能合约平台：这种语言是的除了穿衣单个秘钥之外的其他交易方式成为了可能。</p>
<h2 id="总结">总结</h2>
<p>好啦！我们几乎实现了以区块链为基础的加密货币的所有关键特性。我们有了区块链、地址、挖矿以及交易。但是还有一件事赋予这些所有机制生命，使区块链成为一个全局生态：一致性。在下一篇文章中，我们将开始实现区块链的“去中心化”部分。尽请期待！</p>
<p>Links:</p>
<ol>
<li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_6">Full source codes</a></li>
<li><a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage#The_UTXO_set_.28chainstate_leveldb.29">The UTXO Set</a></li>
<li><a href="https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees">Merkle Tree</a></li>
<li><a href="https://en.bitcoin.it/wiki/Script">Script</a></li>
<li><a href="https://github.com/sipa/bitcoin/commit/450cbb0944cd20a06ce806e6679a1f4c83c50db2">“Ultraprune” Bitcoin Core commit</a></li>
<li><a href="https://statoshi.info/dashboard/db/unspent-transaction-output-set">UTXO set statistics</a></li>
<li><a href="https://medium.com/@maraoz/smart-contracts-and-bitcoin-a5d61011d9b1">Smart contracts and Bitcoin</a></li>
<li><a href="https://medium.com/@jonaldfyookball/why-every-bitcoin-user-should-understand-spv-security-520d1d45e0b9">Why every Bitcoin user should understand “SPV security”</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Golang构建区块链Part5：地址]]></title>
        <id>https://lizonglin313.github.io/post/使用Golang构建区块链Part5：地址</id>
        <link href="https://lizonglin313.github.io/post/使用Golang构建区块链Part5：地址">
        </link>
        <updated>2019-09-10T06:02:02.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>这一篇断断续续做了几天才得以实现，由于文章篇幅限制，作者只将新版本代码中最重要的最有代表性的改变在博客中进行分析。但是仍然有较多的代码需要大家根据compare进行自己细读。我们今天来进行“地址”的实现。</p>
</blockquote>
<h2 id="引言">引言</h2>
<p>在前面的文章中，我们实现了交易。你也了解到了交易的客观性：这里没有账户，你的个人数据（例如姓名、护照号码、社保号）在比特币中是不需要的，同时也是不会存储的。但是这里仍然必须有点什么东西可以标识你是交易输出的所有者（这些币的所有者锁住这些输出）。同时，这也是需要比特币地址的原因。不久之前我们使用用户定义字符串作为地址，这一次我们要实现真正的地址，就像比特币中实现的那样。</p>
<blockquote>
<p>这部分有重大的代码变化，所要没有必要全部解释。可以参考<a href="https://github.com/Jeiwan/blockchain_go/compare/part_4...part_5#files_bucket">这里</a> 去看代码最新版本中的所有变动。</p>
</blockquote>
<h2 id="比特币地址">比特币地址</h2>
<p>这里是比特币地址的一个示例：<a href="https://blockchain.info/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a>。这是比特币中的第一个地址，传言这个地址属于中本聪。比特币地址是公开的。如果你想给某个人发送币，你需要知道他的地址。但是地址（尽管是独一无二的）不是标识你是某个钱包的所有者。事实上，地址是人类可读公钥。在比特币中，你的身份就是一组（或几组）存储在你的计算机上（或者你可以访问的其他地方的）的公-私钥对的组合。比特币依赖一个密码学算法去创建这些钥匙，并且保证没有人可以不通过得到你的物理密钥而去获取你的币。下面让我们讨论一下这些算法。</p>
<h2 id="公钥加密">公钥加密</h2>
<p>公钥加密使用了一组钥匙：公钥和私钥。公钥是非敏感的并且可以透露给所有人。与此相反，私钥不能被透露：除了所有者没有人可以访问它们，因为私钥就像所有者的身份标识。你是就你的私钥（在加密货币的范畴里）。</p>
<p>事实上，比特币钱包就是一对钥匙。当你安装钱包应用或者使用比特币客户端去产生新的地址，一对钥匙就为你产生。在比特币中，谁控制了私钥谁就控制了进入这个钱包的所有币。</p>
<p>私钥和公钥仅仅是随机序列，因此它们不能被打印到屏幕上也不能被人类所读。这就是为什么比特币使用算法去把公钥转换为一个人类可读字符串。</p>
<blockquote>
<p>如果你曾用过比特币钱包应用，它也可能给你生成提示词来助记为你产生的私钥。这个机制在<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-039</a>实现。</p>
<p>PS：我翻的太烂了...</p>
<p>If you’ve ever used a Bitcoin wallet application, it’s likely that a mnemonic pass phrase was generated for you. Such phrases are used instead of private keys and can be used to generate them. This mechanism is implemented in <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-039</a>.</p>
</blockquote>
<p>好了，我们现在知道比特币中怎么去辨别用户身份了。但是比特币中怎样检查交易输出的所有者呢（币是存在里面的吗）？</p>
<h2 id="数字签名">数字签名</h2>
<p>在数学和加密学中，这里有一个数字签名的概念-这个算法保证了：</p>
<ol>
<li>发送者发给接收者的数据不会被篡改；</li>
<li>数据由确定的发送者创建；</li>
<li>发送者不可以否定发送过数据。</li>
</ol>
<p>通过对数据应用签名算法（或者是，对数据签名），一个人得到一个签名，很快就可以得到验证。数字签名使用私钥才可以进行，验证环节则需要公钥。</p>
<p>为了对数据进行签名，我们需要以下条件：</p>
<ol>
<li>需要被签名的数据；</li>
<li>私钥。</li>
</ol>
<p>签名的操作产生一个签名，存储在交易输入中。为了去验证签名，下面是我们需要的：</p>
<ol>
<li>被签名的数据；</li>
<li>签名；</li>
<li>公钥。</li>
</ol>
<p>简单说，验证流程可以被描述为：检查签名是由被签名数据加上私钥得来，并且公钥恰好是由该私钥生成（这个公钥和私钥是配对的）。</p>
<blockquote>
<p>数字签名不是加密，你不能根据签名恢复（反推）出数据。这有些像哈希运算：你通过哈希算法运算数据，得到数据的一个独一无二的标识。签名和哈希运算的不同之处在于钥匙对：它们使得签名验证得以实现。但是钥匙对也可以用来加密数据：一个私钥用于加密数据，一个公钥用来解密数据。比特币并不使用加密算法</p>
</blockquote>
<p>比特币中每一笔交易输入被创建这个交易的人签名。比特币中每一笔交易在上链存储之前必须被验证。验证意味着（不包含其他流程）：</p>
<ol>
<li>确认上笔交易中的出账有权被使用；</li>
<li>检查交易签名是否合法。</li>
</ol>
<p>图示，签名数据以及验证的流程如下：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/09/10/QYq5nyw7lH4EDKa.png" alt="" loading="lazy"></figure>
<p>现在让我们回顾一下交易的整个生命周期：</p>
<ol>
<li>在一开始，这儿有个创世纪块包含了<code>coinbase</code>交易。这个<code>coinbase</code>交易没有真正的输入，所以对它进行签名是没有必要的。这个<code>coinbase</code>交易的输出包含一个进行哈希的公钥（这里使用了RIPEMD16(SHA256(PubKey))算法）。</li>
<li>当某个人发送币时，交易被创建。交易的输入依赖于前一个（几个）交易的输出。每个输入将存储一个公钥（没有被哈希过的）同时也存储整个交易的签名。</li>
<li>比特币网络的其他节点接受交易并进行验证。除此之外，他们将会检查：入账的公钥哈希是否和被引用的出账哈希一样(这就保证了提币的人只能提他自己的币); 签名是不是正确地(这就保证了这笔交易确实是被币的所有者所创建的)。</li>
<li>当矿工节点（挖矿节点）准备好挖一个新区块时，它将会把交易放进区块然后开始挖矿。</li>
<li>当区块被挖出，网络中其他每个节点接受一条区块已经挖出来并且加入区块链的信息。</li>
<li>在区块加入区块链后，交易完成，它的交易输出可以被新的交易所引用。</li>
</ol>
<h2 id="椭圆曲线加密">椭圆曲线加密</h2>
<p>如前文所述，公钥和私钥是随机的字节序列。因为私钥是用来证明币的所有者身份的，这里有一个必须的条件：随机算法必须产生真正的随机字节。我们不想产生一个被别人所拥有的私钥（意思就是没有两个私钥是一样的）。</p>
<p>比特币使用椭圆曲线去产生私钥。椭圆曲线是复杂的数学概念，在这里我们并不会去解释它的细节（如果你好奇，<a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">点击这里</a>，⚠⚠⚠：很多数学公式！！！）。我们所需要知道的是这个曲线算法可以被用来产生真正庞大的和随机的数字。比特币所使用的曲线算法可以随意的产生一个范围在0到2²⁵⁶（大约是10⁷⁷，可见宇宙中的原子数在10⁷⁸到10⁸²）之间的数。如此巨大的上限意味着要产生两个相同的私钥几乎是不可能的。</p>
<p>同时，比特币（我们也）使用了ECDSA（Elliptic Curve Digital Signature Algorithm（椭圆曲线数字签名算法））去对交易进行签名。</p>
<h2 id="base58">Base58</h2>
<p>现在我们回到上面所谈及的比特币地址：1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa。我们知道这是一个人类可读的公钥的一个标识。如果我们对其进行解码，这个公钥就看起来是这种（十六进制表示的一个字节序列）：</p>
<pre><code class="language-shell">0062E907B15CBF27D5425399EBF6F0FB50EBB88F18C29B7D93
</code></pre>
<p>比特币使用Base58算法对公钥进行人类可读的格式转化。这个算法与著名的Base64非常的相似，但是使用了更简短的字母表：一些字母被移出，这是为了避免一些使用相似字母的攻击。因此，这里没有这些符号：0（数字0）、O（大写字母o）、I（大写字母i）、l（小写字母L），因为这些看起来很相似。同时，这里也没有“+”和“/”符号。</p>
<p>让我们根据图形象的看一下从公钥中获取地址的步骤：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/09/10/23TRpxniXPLhYOf.png" alt="" loading="lazy"></figure>
<p>上面所说的解码公钥由下面三个部分组成：</p>
<pre><code class="language-go">Version  		Public key hash                           		Checksum
00       		62E907B15CBF27D5425399EBF6F0FB50EBB88F18  		C29B7D93
</code></pre>
<p>因为哈希函数是单向的（即不能反向解码出元数据），它不可能从哈希中提取出公钥。但是我们可以检查这个公钥是否用来生成哈希，即通过执行哈希函数进行比较。</p>
<p>好啦，这是我们所有部分，让我们写一些代码。一些概念当coding时会更加的清晰。</p>
<h2 id="实现地址">实现地址</h2>
<p>我们从<code>Wallet</code>钱包结构体开始：</p>
<pre><code class="language-go">type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

type Wallets struct {
	Wallets map[string]*Wallet
}

func NewWallet() *Wallet {
	private, public := newKeyPair()
	wallet := Wallet{private, public}

	return &amp;wallet
}

func newKeyPair() (ecdsa.PrivateKey, []byte) {
	curve := elliptic.P256()
	private, err := ecdsa.GenerateKey(curve, rand.Reader)
	pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)

	return *private, pubKey
}
</code></pre>
<p>一个钱包除了了一个钥匙对之外什么都没有。我们也需要<code>Wallets</code>结构体去存储钱包的集合，把它们保存在一个文件中，并可以从文件中加载。在<code>Wallet</code>的构造方法中会产生一个新的钥匙对。这个<code>newKeyPair</code>函数是非常明确的：ECDSA是基于椭圆曲线，所以我们需要一个。接下来，通过曲线算法产生一个私钥，然后公钥由私钥产生。需要注意的一件事情是：在椭圆曲线基础算法中，公钥是指向一条曲线的。因此，一个公钥是由X、Y坐标组合而成的。在比特币中，这些坐标相连接然后组成一个公钥。</p>
<p>现在，让我们产生一个地址：</p>
<pre><code class="language-go">func (w Wallet) GetAddress() []byte {
	pubKeyHash := HashPubKey(w.PublicKey)

	versionedPayload := append([]byte{version}, pubKeyHash...)
	checksum := checksum(versionedPayload)

	fullPayload := append(versionedPayload, checksum...)
	address := Base58Encode(fullPayload)

	return address
}

func HashPubKey(pubKey []byte) []byte {
	publicSHA256 := sha256.Sum256(pubKey)

	RIPEMD160Hasher := ripemd160.New()
	_, err := RIPEMD160Hasher.Write(publicSHA256[:])
	publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)

	return publicRIPEMD160
}

func checksum(payload []byte) []byte {
	firstSHA := sha256.Sum256(payload)
	secondSHA := sha256.Sum256(firstSHA[:])

	return secondSHA[:addressChecksumLen]
}

</code></pre>
<p>这里是将一个公钥转化成一个Base58地址的步骤：</p>
<ol>
<li>获得公钥并使用__RIPEMD160(SHA256(PubKey))__哈希算法将其哈希两次。</li>
<li>为哈希运算准备地址生成算法的版本。</li>
<li>通过对第二步中的结果使用__SHA256(SHA256(payload))__计算校验和。校验和是结果哈希最开始四个字节。</li>
<li>添加校验和到__version+PubKeyHash__组合。</li>
<li>用__Base58__为__version + PubKeyHash + checksum__的组合进行编码。</li>
</ol>
<p>作为结果，你将会得到真正的比特币地址，你甚至可以在<a href="https://blockchain.info/">blockchain.info</a>中查看它的余额。但是我敢保证你的余额是零，不管你创建多少个新地址检查多少次余额。这就是为什么适当的选择公钥加密算法重要的原因：考虑到私钥是随机数据，产生相同数字必须是可能性极低的。理想情况下，必须低到“不可能”的程度。</p>
<p>同时，要注意你不需要连接比特币节点去获得一个地址。地址生成算法利用开源算法的组合，它在很多程序设计语言和库中都有实现。</p>
<p>现在我们需要使用地址对出账和入账进行一些修改：</p>
<pre><code class="language-go">type TXInput struct {
	Txid      []byte
	Vout      int
	Signature []byte
	PubKey    []byte
}

func (in *TXInput) UsesKey(pubKeyHash []byte) bool {
	lockingHash := HashPubKey(in.PubKey)

	return bytes.Compare(lockingHash, pubKeyHash) == 0
}

type TXOutput struct {
	Value      int
	PubKeyHash []byte
}

func (out *TXOutput) Lock(address []byte) {
	pubKeyHash := Base58Decode(address)
	pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4]
	out.PubKeyHash = pubKeyHash
}

func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {
	return bytes.Compare(out.PubKeyHash, pubKeyHash) == 0
}
</code></pre>
<p>注意，现在我们不再使用__ScriptPubKey__和__ScriptSig__字段，因为我们不会去实现一个脚本语言。代替的，__ScriptSig__被分成__Signature__和__PubKey__字段，<strong>ScriptPubKey__被重命名为__PubKeyHash</strong>。我们将会像比特币一样实现相同的出账的加锁和解锁以及入账签名逻辑，但我们会使用函数方法代替。</p>
<p>这个<code>UsesKey</code>方法使用特殊的钥匙去解锁出账来检查入账。注意这个入账存储一个未经加工的公钥（或者说是没有经过哈希运算的），但是需要一个哈希函数。<code>IsLockedWithKey</code>检查是否提供了一个公钥哈希来对出账加锁。这是一个和<code>UsesKey</code>函数的一个互补函数，而且它们同时使用<code>FindUnspentTransactions</code>去在交易间建立连接。</p>
<p><code>Lock</code>简单地锁住了一个输出。当我们给某人发送一些币时，我们知道他的地址，因此这个函数需要地址作为唯一的参数。这个地址接着被解码，从中提取出公钥哈希然后保存在__PubKeyHash__字段中。</p>
<p>现在，让我们检查一下程序是否可以正常工作：</p>
<pre><code class="language-shell">$ blockchain_go createwallet
Your new address: 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt

$ blockchain_go createwallet
Your new address: 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h

$ blockchain_go createwallet
Your new address: 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy

$ blockchain_go createblockchain -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
0000005420fbfdafa00c093f56e033903ba43599fa7cd9df40458e373eee724d

Done!

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 10

$ blockchain_go send -from 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -to 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -amount 5
2017/09/12 13:08:56 ERROR: Not enough funds

$ blockchain_go send -from 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -to 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -amount 6
00000019afa909094193f64ca06e9039849709f5948fbac56cae7b1b8f0ff162

Success!

$ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt
Balance of '13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt': 4

$ blockchain_go getbalance -address 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h
Balance of '15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h': 6

$ blockchain_go getbalance -address 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy
Balance of '1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy': 0
</code></pre>
<blockquote>
<p>虽然完成这些还需要修改更多的代码，仅仅修改上述部分是运行不出来的。具体参照源码。</p>
</blockquote>
<p>好的！现在让我们实现交易签名。</p>
<h2 id="实现签名">实现签名</h2>
<p>交易必须被签名，因为这是比特币中唯一一个途径来保证一个人不能花费不属于他的币。如果一个签名不合法，那么这个交易也被认为是不合法的，因此不能够添加到区块链上。</p>
<p>我们有实现签名的所有部分了，只差一件事：对数据进行签名。交易的哪一部分是真正被签名的呢？或者一个交易是作为一个整体被签名的吗？选择数据去进行签名是非常重要的。这个事情就是被签名的数据必须是用一种独一无二的方式去标识数据的信息（也就是这个数据必须体现出这个交易的独一无二）。例如，仅仅对出账的币额进行签名是完全没有意义的因为这样的签名不会考虑到交易的发送者和接收者。</p>
<p>考虑到交易解锁以前的出账，重新分配余额，并锁定新的交易，这下面是必须被签名的数据：</p>
<ol>
<li>存储在解锁的出账中的公钥哈希。这是交易发送者的身份标识。</li>
<li>新的、加锁的出账的公钥哈希。这是交易接收者的身份标识。</li>
<li>新的出账的额度。</li>
</ol>
<blockquote>
<p>在比特币中，加锁和解锁的逻辑是存储在脚本当中的，也就是分别存储在入账和出账的<code>ScriptSig</code>和<code>ScriptPubKey</code>字段。因为比特币允许这个脚本有不同的类型，它签名整个<code>ScriptPubKey</code>的内容。</p>
</blockquote>
<p>正如你所看到的，我们不需要对存储在入账中的公钥进行签名。正是这个原因，在比特币中，不是交易被签名，而是选择性的利用入账中存储的<code>ScriptPubKey</code>从相关的出账中复制。(PS:应该是没翻好...原文：Because of this, in Bitcoin, it’s not a transaction that’s signed, but its trimmed copy with inputs storing <code>ScriptPubKey</code> from referenced outputs.)</p>
<blockquote>
<p>一个得到修建事务副本的细节程序在<a href="https://en.bitcoin.it/wiki/File:Bitcoin_OpCheckSig_InDetail.png">这里</a>有描述。它很可能过时了，但是我找不到更可靠的数据来源了。</p>
</blockquote>
<p>好的，它看起来很复杂，所以让我们开始coding。我们将会从<code>Sign</code>方法开始：</p>
<pre><code class="language-go">func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	if tx.IsCoinbase() {
		return
	}

	txCopy := tx.TrimmedCopy()

	for inID, vin := range txCopy.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inID].Signature = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.ID = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil

		r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, txCopy.ID)
		signature := append(r.Bytes(), s.Bytes()...)

		tx.Vin[inID].Signature = signature
	}
}
</code></pre>
<p>这个方法接受一个私钥和一个先前交易的map结构。正如前面提及的，为了去签名一个交易，我们需要根据交易的入账去获得引用的出账，因此我们需要交易存储这些出账。</p>
<p>让我们重新一步步看：</p>
<pre><code class="language-go">if tx.IsCoinbase() {
	return
}
</code></pre>
<p>铸币交易不被签名因为这里没有真正的入账。</p>
<pre><code class="language-go">txCopy := tx.TrimmedCopy()
</code></pre>
<p>一个交易的裁剪副本会被签名，而不是整个交易被签名。</p>
<pre><code class="language-go">func (tx *Transaction) TrimmedCopy() Transaction {
	var inputs []TXInput
	var outputs []TXOutput

	for _, vin := range tx.Vin {
		inputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil})
	}

	for _, vout := range tx.Vout {
		outputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash})
	}

	txCopy := Transaction{tx.ID, inputs, outputs}

	return txCopy
}
</code></pre>
<p>这个副本会包含所有的输入和输出，但是<code>TXInput.Signature</code>以及<code>TXInput.PubKey</code>会被设置为空。</p>
<p>接下来，我们对副本里每一个入账进行迭代：</p>
<pre><code class="language-go">for inID, vin := range txCopy.Vin {
	prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
	txCopy.Vin[inID].Signature = nil
	txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
</code></pre>
<p>在每一个入账中，<code>Signature</code>被设置成空，同时<code>PubKey</code>被设置成所引用出账的<code>PubKeyHash</code>。在这种情况下，除了当前的交易其他交易都为“空”。因此__入账是单独签名的__，虽然这在我们的应用中没有必要，但是比特币中允许交易去包含入账所引用的不同的地址。</p>
<pre><code class="language-go">	txCopy.ID = txCopy.Hash()
	txCopy.Vin[inID].PubKey = nil
</code></pre>
<p>这个<code>Hash</code>方法将交易进行序列化的同时使用SHA-256算法计算哈希。这个哈希的结果就是我们将要进行签名的数据。在得到哈希之后，我们应该重置<code>PubKey</code>字段，所以它不会影响进一步的迭代。</p>
<p>现在，核心的部分：</p>
<pre><code class="language-go">	r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, txCopy.ID)
	signature := append(r.Bytes(), s.Bytes()...)
	tx.Vin[inID].Signature = signature
</code></pre>
<p>我们使用<code>privKey</code>对<code>txCopy.ID</code>进行签名。一个椭圆曲线签名算法签名的是一对数字，就是我们连接并存储的入账的<code>Signature</code>字段。</p>
<p>现在，是验证函数：</p>
<pre><code class="language-go">func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {
	txCopy := tx.TrimmedCopy()
	curve := elliptic.P256()

	for inID, vin := range tx.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inID].Signature = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.ID = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil

		r := big.Int{}
		s := big.Int{}
		sigLen := len(vin.Signature)
		r.SetBytes(vin.Signature[:(sigLen / 2)])
		s.SetBytes(vin.Signature[(sigLen / 2):])

		x := big.Int{}
		y := big.Int{}
		keyLen := len(vin.PubKey)
		x.SetBytes(vin.PubKey[:(keyLen / 2)])
		y.SetBytes(vin.PubKey[(keyLen / 2):])

		rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y}
		if ecdsa.Verify(&amp;rawPubKey, txCopy.ID, &amp;r, &amp;s) == false {
			return false
		}
	}

	return true
}
</code></pre>
<p>这个函数非常的直接了当。首先，我们需要相同的交易副本：</p>
<pre><code class="language-go">	txCopy := tx.TrimmedCopy()
</code></pre>
<p>接下来，我们需要同样的曲线用来生成钥匙对：</p>
<pre><code class="language-go">	curve := elliptic.P256()
</code></pre>
<p>然后，我们检查每个入账的签名：</p>
<pre><code class="language-go">    for inID, vin := range tx.Vin {
        prevTx := prevTXs[hex.EncodeToString(vin.Txid)]
        txCopy.Vin[inID].Signature = nil
        txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
        txCopy.ID = txCopy.Hash()
        txCopy.Vin[inID].PubKey = nil
</code></pre>
<p>这部分对唯一的签名方法是相同的，因为在验证过程中，我们需要签名的数据是相同的。</p>
<pre><code class="language-go">        r := big.Int{}
            s := big.Int{}
            sigLen := len(vin.Signature)
            r.SetBytes(vin.Signature[:(sigLen / 2)])
            s.SetBytes(vin.Signature[(sigLen / 2):])

            x := big.Int{}
            y := big.Int{}
            keyLen := len(vin.PubKey)
            x.SetBytes(vin.PubKey[:(keyLen / 2)])
            y.SetBytes(vin.PubKey[(keyLen / 2):])
</code></pre>
<p>这里是我们分析存储在<code>TXInput.Signature</code>和<code>TXInput.PubKey</code>中的数据，因为一个签名是一对数字并且公钥是一对坐标。我们为了存储它们而将它们过早的连接，而且现在我们需要解析它们用于``crypto/ecdsa` 函数。</p>
<pre><code class="language-go">            rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y}
                if ecdsa.Verify(&amp;rawPubKey, txCopy.ID, &amp;r, &amp;s) == false{
                    return false
                }
            }

            return true
</code></pre>
<p>这里，我们使用了从入账中提取出了公钥创建了<code>ecdsa.PublicKey</code>并执行了<code>ecdsa.Verify</code>，参数是从入账提取出的签名。如果所有的入账都验证过了，就返回 true, 如果在输入的验证中有一个出错了，就返回false。</p>
<p>现在，我们需要一个函数去获取先前的交易。因为这里需要与区块链进行交互，我们将构建<code>Bolckchain</code>的函数：</p>
<pre><code class="language-go">func (bc *Blockchain) FindTransaction(ID []byte) (Transaction, error) {
	bci := bc.Iterator()

	for {
		block := bci.Next()

		for _, tx := range block.Transactions {
			if bytes.Compare(tx.ID, ID) == 0 {
				return *tx, nil
			}
		}

		if len(block.PrevBlockHash) == 0 {
			break
		}
	}

	return Transaction{}, errors.New(&quot;Transaction is not found&quot;)
}

func (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) {
	prevTXs := make(map[string]Transaction)

	for _, vin := range tx.Vin {
		prevTX, err := bc.FindTransaction(vin.Txid)
		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
	}

	tx.Sign(privKey, prevTXs)
}

func (bc *Blockchain) VerifyTransaction(tx *Transaction) bool {
	prevTXs := make(map[string]Transaction)

	for _, vin := range tx.Vin {
		prevTX, err := bc.FindTransaction(vin.Txid)
		prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX
	}

	return tx.Verify(prevTXs)
}
</code></pre>
<p>这些函数很直接：<code>FindTransaction</code>通过ID寻找交易（它需要迭代区块链上的所有区块）；<code>SignTransaction</code>接受交易，寻找交易的引用，并且对它进行签名；``VerifyTransaction`也差不多做相同的事情，但是会验证交易。</p>
<p>现在，我们需要真正的签名并且验证交易。签名发生在<code>NewUTXOTransaction</code>中：</p>
<pre><code class="language-go">func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
	...

	tx := Transaction{nil, inputs, outputs}
	tx.ID = tx.Hash()
	bc.SignTransaction(&amp;tx, wallet.PrivateKey)

	return &amp;tx
}
</code></pre>
<p>验证发生在交易被放入区块之前：</p>
<pre><code class="language-go">func (bc *Blockchain) MineBlock(transactions []*Transaction) {
	var lastHash []byte

	for _, tx := range transactions {
		if bc.VerifyTransaction(tx) != true {
			log.Panic(&quot;ERROR: Invalid transaction&quot;)
		}
	}
	...
}
</code></pre>
<p>完成！让我们多检查几次：</p>
<pre><code class="language-shell">$ blockchain_go createwallet
Your new address: 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR

$ blockchain_go createwallet
Your new address: 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab

$ blockchain_go createblockchain -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
000000122348da06c19e5c513710340f4c307d884385da948a205655c6a9d008

Done!

$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 6
0000000f3dbb0ab6d56c4e4b9f7479afe8d5a5dad4d2a8823345a1a16cf3347b

Success!

$ blockchain_go getbalance -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR
Balance of '1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR': 4

$ blockchain_go getbalance -address 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab
Balance of '1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab': 6
</code></pre>
<p>没问题。极好的！</p>
<p>让我们同时把<code>NewUTXOTransaction</code>里的<code>bc.SignTransaction(&amp;tx, wallet.PrivateKey)</code>注释掉，让没有被签名的交易不能被挖矿：</p>
<pre><code class="language-go">func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
   ...
	tx := Transaction{nil, inputs, outputs}
	tx.ID = tx.Hash()
	// bc.SignTransaction(&amp;tx, wallet.PrivateKey)

	return &amp;tx
}
</code></pre>
<pre><code class="language-shell">$ go install
$ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 1
2017/09/12 16:28:15 ERROR: Invalid transaction
</code></pre>
<h2 id="总结">总结</h2>
<p>我们迅速的进行并且实现了比特币中很多关键的特点，这是极好的！我们差不多实现了除了网络之外的一切，在下一部分，我们将完成交易。</p>
<p>Links:</p>
<ol>
<li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_5">Full source codes</a></li>
<li><a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Public-key cryptography</a></li>
<li><a href="https://en.wikipedia.org/wiki/Digital_signature">Digital signatures</a></li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve">Elliptic curve</a></li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">Elliptic curve cryptography</a></li>
<li><a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a></li>
<li><a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses">Technical background of Bitcoin addresses</a></li>
<li><a href="https://en.bitcoin.it/wiki/Address">Address</a></li>
<li><a href="https://en.bitcoin.it/wiki/Base58Check_encoding">Base58</a></li>
<li><a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">A gentle introduction to elliptic curve cryptography</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Golang构建区块链Part4：交易-1]]></title>
        <id>https://lizonglin313.github.io/post/使用Golang构建区块链Part4：交易-1</id>
        <link href="https://lizonglin313.github.io/post/使用Golang构建区块链Part4：交易-1">
        </link>
        <updated>2019-09-07T07:33:16.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在对照实现本部分内容时，我进行的稍微困难，因为本篇中的实现代码与前面的代码相差的太多。所以，当遇到困难时，就直接去查源码。在后面会有对应代码改动的链接。</p>
</blockquote>
<h2 id="介绍">介绍</h2>
<p>交易是比特币的核心，将交易安全可靠的存储是区块链唯一目的，所以没有人可以在交易创建之后进行修改。今天我们将开始实现交易。但由于这是一个较为庞大的部分，我将它分成了两部分：在本部分，我们会实现交易的通用机制，在后续的那部分中我们将会实现细节部分。</p>
<p>对了，由于代码改动了很多，并且没有必要全部细说。你们可以在<a href="https://github.com/Jeiwan/blockchain_go/compare/part_3...part_4#files_bucket">这里</a>找到所有的改动。</p>
<h2 id="there-is-no-spoon这没勺子">There is no spoon（这没勺子）</h2>
<p>如果你曾经开发过Web应用，为了实现支付你会在数据库中创建这样的tables：<strong>accounts</strong> 和 <strong>transactions</strong> 。一个账户会保存一个用户的信息，包含他们的私人信息以及账户余额，同时一个交易会存储money从一个账户到另一个账户的转移信息。在比特币中，支付是实现于一个完全不同的方式。在这：</p>
<ol>
<li>没有账户。</li>
<li>没有余额。</li>
<li>没有地址。</li>
<li>没有币。</li>
<li>没有发送者和接受者。</li>
</ol>
<p>因为区块链是一个公共开放的数据库，我们不想存储钱包所有者的敏感信息在里面。币不会在账户中被收集。</p>
<p>交易不会把money从一个地址转移到另一个。这里也没有字段或者说是特征来持有账户的余额。这里只有交易。但是，交易里有什么呢？</p>
<h2 id="比特币交易">比特币交易</h2>
<blockquote>
<p>Github译者补充：</p>
<p>点击 <a href="https://blockchain.info/zh-cn/tx/b6f6b339b546a13822192b06ccbdd817afea5311845f769702ae2912f7d94ab5">这里</a> 在 blockchain.info 查看下图中的交易信息。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/09/07/otOYFCE7e9d6wsh.png" alt="" loading="lazy"></figure>
</blockquote>
<p>交易包含一些输入（inputs）和一些输出（outputs）：</p>
<pre><code class="language-go">type Transaction struct {
	ID   []byte
	Vin  []TXInput
	Vout []TXOutput
}
</code></pre>
<p>一个新的交易的入账/输入取决于上一个交易的出账/输出（不过这儿有一个例外，我们在稍后会讨论到）。出账/输出是币实际上存储在哪里。下面的图表对交易的内在联系进行了示范：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2019/09/07/XlvF9EdjqyJa5Di.png" alt="" loading="lazy"></figure>
<p>请注意：</p>
<ol>
<li>有的出账没有和入账相连。</li>
<li>在一个交易中，入账涉及多个交易的出账。</li>
<li>一个入账必须依赖一个出账。</li>
</ol>
<p>整篇文章中，我们将会使用像“钱”、“币”、“花费”、“发出”、“账户”等等这样的字眼。但是对比特币并不存在这样的概念，交易仅仅是通过一个脚本来锁定一些值，而这些实际的值只可以被锁定他们的人解锁。</p>
<p>（ Transactions just lock values with a script, which can be unlocked only by the one who locked them.）</p>
<h2 id="交易出账">交易出账</h2>
<p>让我们从交易出账开始：</p>
<pre><code class="language-go">type TXOutput struct {
	Value        int
	ScriptPubKey string
}
</code></pre>
<p>实际上，这是存储“币”的出账（注意一下上面的“value”字段）。这个存储被一个保存在__ScriptPubKey__里的“谜题”锁定。往深了说，比特币使用了一个叫做__Script__的脚本语言，它用于定义交易输出（出账）的锁定和解锁逻辑。这个语言有一些原始（它有意这样设计以便避免可能的入侵和滥用），但是我们不会讨论它的细节。你可以在<a href="https://en.bitcoin.it/wiki/Script">这里</a>找到所有细节的解释。</p>
<blockquote>
<p>在比特币中，_value_字段存储着_satoshis_的数量，而不是比特币的数量。1 _satoshis_是1亿比特币分之1（0.00000001 BTC）。所以这是比特币货币中最小的单位（像是分）。</p>
</blockquote>
<p>因为我们没有实现地址，我们现在将避免涉及到全部逻辑相关的脚本。__ScriptPubKey__将会存储为一个专用的字段（用户定义钱包地址）。</p>
<blockquote>
<p>顺便说一下，拥有脚本语言意味着比特币也可以用做智能合约平台。</p>
</blockquote>
<p>关于交易输出有一个重要的点是它们是不可分割的，这意味着你不能使用这个值的一部分。当一个交易输出被一个新的交易引用时，它会全部花费。如果这个值比所需要的多，找零会自动生成并返回给发送者。这有些相似于现实世界中你支付的场景，就是说，一个5元的钞票去买一个1元的东西，会得到4元找零。</p>
<h2 id="交易入账">交易入账</h2>
<p>这儿是交易入账：</p>
<pre><code class="language-go">type TXInput struct {
	Txid      []byte
	Vout      int
	ScriptSig string
}
</code></pre>
<p>如前面所述，一个交易的入账涉及到前一个交易的出账：<strong>Txid__存储这个交易的__ID</strong>，__Vout__存储这个交易中一个出账的索引。__ScriptSig__是一个为出账时提供使用的__ScriptPubKey__所需要数据的脚本（ScriptSig是个脚本，这个脚本提供数据，提供的数据是ScriptPubKey所需要的，ScriptPubKey是出账时所需要的脚本）。如果数据正确，交易出账可以被解锁，它的值可以用于生成新的出账；如果不正确，这个出账则不能被入账所引用。这就是保证用户不能花费属于别人的币的一个机制。</p>
<p>再说一次，因为我们没有实现地址，__ScriptSig__将仅仅存储一个专用的用户定义钱包地址。我们在下一篇文章将会实现公钥和签名检查。</p>
<p>让我们总结一下。交易出账是“币”所存在的地方。每一个交易出账都带有一个解锁的脚本，决定着解锁这个交易出账的逻辑。每一个新的交易必须至少有一个入账和出账。一个入账会引用上个交易的出账和数据(<strong>ScriptSig</strong> 字段),这些被用来在出账中解锁脚本去解锁并使用其中的值创建新的出账。（好吧我长难句不过关...原文： An input references an output from a previous transaction and provides data (the <code>ScriptSig</code> field) that is used in the output’s unlocking script to unlock it and use its value to create new outputs.）</p>
<p>但是，先有谁：入账还是出账？</p>
<h2 id="the-egg蛋">The egg（蛋）</h2>
<p>在比特币中，是先有蛋，后有鸡的。这个交易入账和交易出账的相互关系逻辑是经典的“鸡和蛋”的关系：入账产生出账，而出账使入账成为可能。在比特币中，交易出账产生于交易入账之前，也就是，先有交易出账。</p>
<p>当矿工开始挖矿时，他会添加一笔币基交易<code>coinbase</code>（我们可以理解为凭空造币的交易）。一个币基交易是一种特殊的交易，不需要任何先前的交易出账的存在。它就会“莫名其妙的”产生交易出账，可以理解为凭空造钱。这个蛋就不需要鸡。这是对矿工挖出新块的一个奖励。</p>
<p>正如你所知道的，在区块链的最开始有一个创世区块。这个区块是区块链中最开始的一个出账。由于没有先前的交易和输出，所以它不需要前面的交易输出。</p>
<p>让我们创建一个<code>coinbase</code>交易：</p>
<pre><code class="language-go">func NewCoinbaseTX(to, data string) *Transaction {
	if data == &quot;&quot; {
		data = fmt.Sprintf(&quot;Reward to '%s'&quot;, to)
	}

	txin := TXInput{[]byte{}, -1, data}
	txout := TXOutput{subsidy, to}
	tx := Transaction{nil, []TXInput{txin}, []TXOutput{txout}}
	tx.SetID()

	return &amp;tx
}
</code></pre>
<p>一个<code>coinbase</code>交易只有一个输入。在我们的实现中，它的<code>Txid</code>是空的而且<code>Vout</code>等于-1.同时，一个<code>coinbase</code>交易也不需要在<code>ScriptSig</code>中存储脚本。取而代之的，专有数据存储在这里。</p>
<blockquote>
<p>在比特币中，最开始的一个交易中带有这样的信息： “The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”. <a href="https://blockchain.info/tx/4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b?show_adv=true">在这里可以自个看</a>。</p>
</blockquote>
<p><code>subsidy</code>是奖励的总数。在区块链中，这个值不会存储在任何地方而是仅仅根据区块的总数量进行计算：区块被分为210000个。挖这些创世区块产生50BTC，并且每210000个区块这个奖励减半。在我们的实现中，我们将这个奖励存储为一个常量（至少现在是这样😉）。</p>
<h2 id="在区块链中存储交易">在区块链中存储交易</h2>
<p>从现在开始，每个区块必须存储至少1个交易同时没有可能挖一个不包含交易的区块。这意味我们应该移出<code>Block</code>中的<code>Data</code>字段然后代替的，存储交易字段：</p>
<pre><code class="language-go">type Block struct {
	Timestamp     int64
	Transactions  []*Transaction
	PrevBlockHash []byte
	Hash          []byte
	Nonce         int
}
</code></pre>
<p><code>NewBlock</code>以及<code>NewGenesisBlock</code>也必须相应的改变：</p>
<pre><code class="language-go">func NewBlock(transactions []*Transaction, prevBlockHash []byte) *Block {
    block := &amp;Block{time.Now().Unix(), transactions, prevBlockHash, []byte{}, 0}
    ...
}

func NewGenesisBlock(coinbase *Transaction) *Block {
    return NewBlock([]*Transaction{coinbase}, []byte{})
}
</code></pre>
<blockquote>
<p>在这部分以及后面的代码中，由于我理解能力的原因（或是作者描述的略微粗略），这部分以及以后的代码都是在Part3和Part4代码比较里一一对应继续修改的。链接在文章开始的地方。</p>
</blockquote>
<p>接下来调整创建区块链的部分：</p>
<pre><code class="language-go">func CreateBlockchain(address string) *Blockchain {
	...
	err = db.Update(func(tx *bolt.Tx) error {
		cbtx := NewCoinbaseTX(address, genesisCoinbaseData)
		genesis := NewGenesisBlock(cbtx)

		b, err := tx.CreateBucket([]byte(blocksBucket))
		err = b.Put(genesis.Hash, genesis.Serialize())
		...
	})
	...
}
</code></pre>
<blockquote>
<p>我将完整部分也给大家贴上：</p>
<pre><code class="language-go">// creates a new blockchain db
func CreateBlockchain(address string) *Blockchain {
	if dbExists() {
		fmt.Println(&quot;Blockchain is already exists.&quot;)
		os.Exit(1)
	}

	var tip []byte
	db, err := bolt.Open(dbFile, 0600, nil)
	if err != nil {
		log.Panic(err)
	}

	err = db.Update(func(tx *bolt.Tx) error {
		cbtx := NewCoinbaseTX(address, genesisCoinbaseData)
		genesis := NewGenesisBlock(cbtx)

		b, err := tx.CreateBucket([]byte(blocksBucket))
		if err != nil {
			log.Panic(err)
		}

		err = b.Put(genesis.Hash, genesis.Serialize())
		if err != nil {
			log.Panic(err)
		}

		err = b.Put([]byte(&quot;l&quot;), genesis.Hash)

		if err != nil {
			log.Panic(err)
		}

		tip = genesis.Hash

		return nil

	})

	if err != nil {
		log.Panic(err)
	}

	bc := Blockchain{tip, db}

	return &amp;bc
}
</code></pre>
</blockquote>
<p>现在，这个函数接收了一个地址，这个地址就是接受挖出创世区块的奖励的。</p>
<h2 id="工作量证明">工作量证明</h2>
<p>工作量证明算法必须考虑到存储在区块中的交易，去保证区块链作为一个存储交易仓库的一致性和可靠性。所以，我们现在必须修改<code>Proof-Of-Work.prepareData</code>方法：</p>
<pre><code class="language-go">func (pow *ProofOfWork) prepareData(nonce int) []byte {
	data := bytes.Join(
		[][]byte{
			pow.block.PrevBlockHash,
			pow.block.HashTransactions(), // This line was changed
			IntToHex(pow.block.Timestamp),
			IntToHex(int64(targetBits)),
			IntToHex(int64(nonce)),
		},
		[]byte{},
	)

	return data
}
</code></pre>
<p>现在我们用<code>pow.block.HashTransactions()</code>来代替<code>pow.block.Data</code>，就是：</p>
<pre><code class="language-go">func (b *Block) HashTransactions() []byte {
	var txHashes [][]byte
	var txHash [32]byte

	for _, tx := range b.Transactions {
		txHashes = append(txHashes, tx.ID)
	}
	txHash = sha256.Sum256(bytes.Join(txHashes, []byte{}))

	return txHash[:]
}
</code></pre>
<p>此外，我们使用取哈希的原理为数据提供一个独一无二的特征。我们希望所有在区块中的交易都通过单独的一个哈希去唯一的标识自己。为了实现它，我们取每个交易的哈希，将它们连接起来，然后去计算它们连接组合的哈希。</p>
<blockquote>
<p>比特币使用了更加复杂的技术：它用一颗<a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a>代表一个区块中包含的所有交易并且在工作量证明系统中使用树的根哈希值。这个方法运行快速的检查一个区块是否包含某个确定的交易，只需要树根的哈希而不需要下载整个交易。</p>
</blockquote>
<p>让我们检查一下到目前为止一切是否正确：</p>
<pre><code class="language-go">$ blockchain_go createblockchain -address Ivan
00000093450837f8b52b78c25f8163bb6137caf43ff4d9a01d1b731fa8ddcc8a

Done!
</code></pre>
<blockquote>
<p>实话说做到这里，这个我没做出来，应该还是缺一些的。在整篇文章涉及到的代码全部完成后，我才实现这样的内容。</p>
</blockquote>
<p>好！我们现在收到我们的第一笔挖矿奖励。但是，我们怎样检查我们的余额呢？</p>
<h2 id="未花费交易输出">未花费交易输出</h2>
<p>我们需要找到全部的未花费交易输出（unspent transaction outputs - UTXO）。未花费表示这些输出没有在任何地方被任何交易入账所引用（也就是哪一个交易的入账都没有使用它）。在上面的图解中，这些就是的：</p>
<ol>
<li>tx0, output 1；</li>
<li>tx1, output 0；</li>
<li>tx3, output 0；</li>
<li>tx4, output 0。</li>
</ol>
<p>当然，在我们检查余额时，我们并不需要全部的这些，只需要那些可以被我们所拥有的key解锁的（目前我们还没有key的实现，我们会用用户定义地址去代替）。首先，让我们在入账和出账上定义加锁和解锁方法：</p>
<pre><code class="language-go">func (in *TXInput) CanUnlockOutputWith(unlockingData string) bool {
	return in.ScriptSig == unlockingData
}

func (out *TXOutput) CanBeUnlockedWith(unlockingData string) bool {
	return out.ScriptPubKey == unlockingData
}
</code></pre>
<p>这里我们仅仅使用<code>unlockingData</code>与脚本字段进行比较。这些模块将会在后面的文章进行改进，在我们实现基于私钥的地址之后。</p>
<p>下一步-找到包含未花费输出的交易-这有点困难：</p>
<pre><code class="language-go">func (bc *Blockchain) FindUnspentTransactions(address string) []Transaction {
  var unspentTXs []Transaction
  spentTXOs := make(map[string][]int)
  bci := bc.Iterator()

  for {
    block := bci.Next()

    for _, tx := range block.Transactions {
      txID := hex.EncodeToString(tx.ID)

    Outputs:
      for outIdx, out := range tx.Vout {
        // Was the output spent?
        if spentTXOs[txID] != nil {
          for _, spentOut := range spentTXOs[txID] {
            if spentOut == outIdx {
              continue Outputs
            }
          }
        }

        if out.CanBeUnlockedWith(address) {
          unspentTXs = append(unspentTXs, *tx)
        }
      }

      if tx.IsCoinbase() == false {
        for _, in := range tx.Vin {
          if in.CanUnlockOutputWith(address) {
            inTxID := hex.EncodeToString(in.Txid)
            spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)
          }
        }
      }
    }

    if len(block.PrevBlockHash) == 0 {
      break
    }
  }

  return unspentTXs
}
</code></pre>
<p>因为交易被存储在区块中，我们不得不检查区块链中的每一个区块。我们从出账开始：</p>
<pre><code class="language-go">if out.CanBeUnlockedWith(address) {
	unspentTXs = append(unspentTXs, tx)
}
</code></pre>
<p>如果一笔出账被我们搜寻未花费交易输出的地址锁住了（也就是：这个出账的地址就是搜寻时所用的地址），那么这就是我们想要的出账。但是在获得它之前，我们需要检查一个出账是否早已被一个入账所引用：</p>
<pre><code class="language-go">if spentTXOs[txID] != nil {
	for _, spentOut := range spentTXOs[txID] {
		if spentOut == outIdx {
			continue Outputs
		}
	}
}
</code></pre>
<p>我们跳过那些已经被入账所引用的出账（这些值早已转移到其他出账，因此我们不能计算它们）。在检查出账之后我们获得所有的，可以被提供的地址解锁出账上面的锁，的入账（它不会用到<code>coinbase</code>交易上，因为它们没有解锁出账）：</p>
<blockquote>
<p>PS：这里我翻译不好，把原文贴上了</p>
<p>After checking outputs we gather all inputs that could unlock outputs locked with the provided address (this doesn’t apply to coinbase transactions, since they don’t unlock outputs)</p>
</blockquote>
<pre><code class="language-go">if tx.IsCoinbase() == false {
    for _, in := range tx.Vin {
        if in.CanUnlockOutputWith(address) {
            inTxID := hex.EncodeToString(in.Txid)
            spentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)
        }
    }
}
</code></pre>
<p>这个函数返回一个包含未花费输出的交易列表。为了计算余额，我们还需要一个函数，接受交易返回交易输出：</p>
<pre><code class="language-go">func (bc *Blockchain) FindUTXO(address string) []TXOutput {
       var UTXOs []TXOutput
       unspentTransactions := bc.FindUnspentTransactions(address)

       for _, tx := range unspentTransactions {
               for _, out := range tx.Vout {
                       if out.CanBeUnlockedWith(address) {
                               UTXOs = append(UTXOs, out)
                       }
               }
       }

       return UTXOs
}
</code></pre>
<p>就是它了！现在我们可以实现<code>getbalance</code>命令：</p>
<pre><code class="language-go">func (cli *CLI) getBalance(address string) {
	bc := NewBlockchain(address)
	defer bc.db.Close()

	balance := 0
	UTXOs := bc.FindUTXO(address)

	for _, out := range UTXOs {
		balance += out.Value
	}

	fmt.Printf(&quot;Balance of '%s': %d\n&quot;, address, balance)
}
</code></pre>
<p>账户的余额是所有被账户地址锁住的未花费交易输出的总额。</p>
<p>让我们在挖出创世区块后检查一下余额：</p>
<pre><code class="language-go">$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 10
</code></pre>
<p>这是我们的第一桶金！</p>
<h2 id="发送币">发送币</h2>
<p>现在，我们想发送一些币给其他人。为此，我们需要创建一个新的交易，把它放进区块里，然后挖矿。到目前为止，我们只实现了<code>coinbase</code>交易（一种特殊的交易），现在我们需要一个更有普遍性意义的交易：</p>
<pre><code class="language-go">func NewUTXOTransaction(from, to string, amount int, bc *Blockchain) *Transaction {
	var inputs []TXInput
	var outputs []TXOutput

	acc, validOutputs := bc.FindSpendableOutputs(from, amount)

	if acc &lt; amount {
		log.Panic(&quot;ERROR: Not enough funds&quot;)
	}

	// Build a list of inputs
	for txid, outs := range validOutputs {
		txID, err := hex.DecodeString(txid)

		for _, out := range outs {
			input := TXInput{txID, out, from}
			inputs = append(inputs, input)
		}
	}

	// Build a list of outputs
	outputs = append(outputs, TXOutput{amount, to})
	if acc &gt; amount {
		outputs = append(outputs, TXOutput{acc - amount, from}) // a change
	}

	tx := Transaction{nil, inputs, outputs}
	tx.SetID()

	return &amp;tx
}
</code></pre>
<p>在创建新的输出之前，我们必须寻找所有的未花费输出并且确保它们存储了足够的“钱”。这就是<code>FindSpendableOutputs</code>方法所做的。在那之后，入账所需要引用的出账就被找出来了。接下来，我们创建两个输出：</p>
<ol>
<li>一个由接收者的地址锁定。这就是真实的币到一个地址的转移。</li>
<li>一个由发送者的地址锁定。这是一个改变。它仅仅在未花费交易输出的总额大于新交易所需要的总额时被创建。记住，输出是__不可分割__的。</li>
</ol>
<p><code>FindSpendableOutputs</code>方法依赖于我们先前定义的<code>FindUnspentTransactions</code>方法：</p>
<pre><code class="language-go">func (bc *Blockchain) FindSpendableOutputs(address string, amount int) (int, map[string][]int) {
	unspentOutputs := make(map[string][]int)
	unspentTXs := bc.FindUnspentTransactions(address)
	accumulated := 0

Work:
	for _, tx := range unspentTXs {
		txID := hex.EncodeToString(tx.ID)

		for outIdx, out := range tx.Vout {
			if out.CanBeUnlockedWith(address) &amp;&amp; accumulated &lt; amount {
				accumulated += out.Value
				unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)

				if accumulated &gt;= amount {
					break Work
				}
			}
		}
	}

	return accumulated, unspentOutputs
}
</code></pre>
<p>这个方法迭代所有的未花费交易并计算它们的总额。当积累的值大于或者等于我们需要进行转换的值时，它就会停止并且返回积累的总值已经由交易ID所聚会的出账索引。我们不想花更多的钱。</p>
<p>现在，我们可以修改<code>Blockchain.MineBlock</code>方法：</p>
<pre><code class="language-go">func (bc *Blockchain) MineBlock(transactions []*Transaction) {
	...
	newBlock := NewBlock(transactions, lastHash)
	...
}
</code></pre>
<blockquote>
<p>完整代码：</p>
<pre><code class="language-go">func (bc *Blockchain) MineBlock(transactions []*Transaction) {
	var lasthash []byte

	// BoltDB的只读事务，读取最后一个区块的hash，用它挖下一个区块的hash
	err := bc.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		lasthash = b.Get([]byte(&quot;l&quot;))

		return nil
	})

	if err!= nil {
		log.Panic(err)
	}

	// 用提供的交易以及上一个区块的hash构建新的区块
	newBlock := NewBlock(transactions, lasthash)

	// 挖到新区块后进行DB存储并更新“l”键
	err = bc.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		err := b.Put(newBlock.Hash, newBlock.Serialize())
		if err != nil {
			log.Panic(err)
		}

		// 更新“l”键
		err = b.Put([]byte(&quot;l&quot;), newBlock.Hash)
		if err != nil {
			log.Panic(err)
		}

		bc.tip = newBlock.Hash

		return nil
	})
}
</code></pre>
</blockquote>
<p>最后，我们实现<code>send</code>命令：</p>
<pre><code class="language-go">func (cli *CLI) send(from, to string, amount int) {
	bc := NewBlockchain(from)
	defer bc.db.Close()

	tx := NewUTXOTransaction(from, to, amount, bc)
	bc.MineBlock([]*Transaction{tx})
	fmt.Println(&quot;Success!&quot;)
}
</code></pre>
<p>发送币意味着创建一个交易，并且通过挖出一个区块将其添加到区块链上。但是比特币没有像我们实现这些。相反的，它把所有交易存储到内存池（一般叫做矿池）中，当矿工准备好挖出一个矿时，它打包内存池中的所有交易并且产生一个候选区块。交易只有在包含它的区块被挖出来并且添加到区块链之后才被确认。</p>
<p>然我们检查发送币命令的运行：</p>
<pre><code class="language-go">$ blockchain_go send -from Ivan -to Pedro -amount 6
00000001b56d60f86f72ab2a59fadb197d767b97d4873732be505e0a65cc1e37

Success!

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 4

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 6
</code></pre>
<p>现在，让我们创建更多的交易确定发送在更多的输出程序中可以很好的运行：</p>
<pre><code class="language-go">$ blockchain_go send -from Pedro -to Helen -amount 2
00000099938725eb2c7730844b3cd40209d46bce2c2af9d87c2b7611fe9d5bdf

Success!

$ blockchain_go send -from Ivan -to Helen -amount 2
000000a2edf94334b1d94f98d22d7e4c973261660397dc7340464f7959a7a9aa

Success!
</code></pre>
<p>现在，Helen's的币被两个出账锁定：一个来自Pedro一个来自Ivan。让我们分别发送它们：</p>
<pre><code class="language-go">$ blockchain_go send -from Helen -to Rachel -amount 3
000000c58136cffa669e767b8f881d16e2ede3974d71df43058baaf8c069f1a0

Success!

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 2

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 4

$ blockchain_go getbalance -address Helen
Balance of 'Helen': 1

$ blockchain_go getbalance -address Rachel
Balance of 'Rachel': 3
</code></pre>
<p>看起来很好！让我们测试一个失败情况：</p>
<pre><code class="language-go">$ blockchain_go send -from Pedro -to Ivan -amount 5
panic: ERROR: Not enough funds

$ blockchain_go getbalance -address Pedro
Balance of 'Pedro': 4

$ blockchain_go getbalance -address Ivan
Balance of 'Ivan': 2
</code></pre>
<h2 id="总结">总结</h2>
<p>噢！它并不容易，但好歹我们现在有交易了！虽然，一些类似于区块链这种加密货币的特性遗失了：</p>
<ol>
<li>地址。我们没有真实的，基于私钥的地址。</li>
<li>奖励。挖矿是毫无利益可图的。</li>
<li>UTXO集合。需要扫描整个区块获得余额，当区块非常非常多的时候这很花费时间。而且在后面我们要验证交易的话也非常花费时间。UTXO集就是为了解决这些问题并且让交易操作更快捷。</li>
<li>内存池（矿池）。这是交易在打包到区块之前所要存储的地方。在我们目前的实现中，一个区块只包含一个交易，这是非常低效的。</li>
</ol>
<p>Links：</p>
<ol>
<li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_4">Full source codes</a></li>
<li><a href="https://en.bitcoin.it/wiki/Transaction">Transaction</a></li>
<li><a href="https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees">Merkle tree</a></li>
<li><a href="https://en.bitcoin.it/wiki/Coinbase">Coinbase</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Golang构建区块链Part3：持久化和命令行接口]]></title>
        <id>https://lizonglin313.github.io/post/使用Golang构建区块链Part3：持久化和命令行接口</id>
        <link href="https://lizonglin313.github.io/post/使用Golang构建区块链Part3：持久化和命令行接口">
        </link>
        <updated>2019-09-06T05:26:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<p>到现在，我们已经构建了一个有工作量证明系统和可以挖矿的区块链。我们的实现离一个具有完整功能的区块链又进了一步，但是它仍然少一些重要的性质。今天，我们要将区块链存储到数据库中，在这之后，我们将做一个简单的命令行接口来支持区块链的操作。在它的一个重要的本质中，区块链是一个分布式数据库；我们现在要省略“分布式”的部分，而集中精力于“数据存储”部分。</p>
<h2 id="数据库的选择">数据库的选择</h2>
<p>目前，在我们的实现中并没有数据库；反而我们在每一次运行程序创建区块时都存储在内存中。我们既不能重复使用区块链也不能与其他人共享，因此我们需要将它存储在磁盘中。</p>
<p>我们需要哪一个数据库呢？事实上，任何一个都可以。在<a href="https://bitcoin.org/bitcoin.pdf">比特币的原始论文</a>中，没有说明使用哪一个特定的数据库。所以，使用什么数据库完全取决于开发者。 <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> ，最初由中本聪发布的，现在是比特币的一个参考实现，它使用的是<a href="https://github.com/google/leveldb">LevelDB</a>（虽然它在2012年才发布客户端）。而我们将要使用的是...</p>
<h2 id="boltdb">BoltDB</h2>
<p>原因：</p>
<ol>
<li>它非常简单便捷。</li>
<li>它是由Go语言实现的。</li>
<li>它不需要运行任何一个服务器。</li>
<li>它允许我们想要的数据结构。</li>
</ol>
<p>在__BoltDB__ <a href="https://github.com/boltdb/bolt">Github上的README</a>写道：</p>
<blockquote>
<p>Bolt 是一个纯键值存储的 Go 数据库，启发自 Howard Chu 的 LMDB. 它旨在为那些无须一个像 Postgres 和 MySQL 这样有着完整数据库服务器的项目，提供一个简单，快速和可靠的数据库。</p>
<p>由于 Bolt 意在用于提供一些底层功能，简洁便成为其关键所在。它的 API 并不多，并且仅关注值的获取和设置。仅此而已。</p>
</blockquote>
<p>听起来很完美的契合了我们的需求！让我们快速的回顾一下它：</p>
<p>__BoltDB__是一个键值存储结构，这就意味着它不像关系型数据库（MySQL、PostgreSQL等）有表，没有行、列。相反的，数据以一种key-value（键值对）的组合形式存储（就像Go语言中的__map__结构）。键值对存储在桶中，这是有意的给键值对分组（这有些像关系型数据库中的表）。因此，为了获得一个值，你需要知道一个桶（bucket）和一个键（key）。</p>
<p>关于__BoltDB__一个重要的点是它没有数据类型：键和值都是以字节数组的形式存储。由于我们要存储Go的数据结构（具体来说是__Block__），我们需要将它们进行序列化。也就是说，实现一个可以将Go结构体转化为字节数组并可以从字节数组恢复到Go结构体的机制。我们将使用<a href="https://golang.org/pkg/encoding/gob/">encoding/gob</a>来实现这个，但是JSON、XML、Protocol Buffers等也是可以的。我们使用<a href="https://golang.org/pkg/encoding/gob/">encoding/gob</a>是因为它简单而且是Go的标准库。</p>
<h2 id="数据库结构">数据库结构</h2>
<p>在开始实现持久化的逻辑之前，我们需要决定怎样将数据存储到数据库中。为此，我们参考比特币的做法。</p>
<p>简单来说，比特币使用了两个桶（bucket）来存储数据：</p>
<ol>
<li>__blocks__存储链上区块的元数据描述。</li>
<li>__chainstate__存储链的状态，也就是目前所有的未花费交易输出以及一些数据。</li>
</ol>
<p>同时，区块被存储为磁盘上不同的文件。出于对性能的考虑：加载单个的区块不需要从内存中加载所有（或者部分）文件。我们不需要实现这些。</p>
<p>在 <strong>blocks</strong> 中， <strong>key -&gt; value</strong> 对应关系是这样的：</p>
<ol>
<li><strong>‘b’ + 32 字节的区块 hash -&gt; 区块索引记录</strong></li>
<li><strong>‘f’ + 4 字节文件数字 -&gt; 文件信息记录</strong></li>
<li><strong>‘l’ -&gt; 4 字节文件数字： 最后一个使用过的区块文件数字</strong></li>
<li><strong>‘R’ -&gt; 1 字节布尔值： 我们是否要去重新索引</strong></li>
<li><strong>‘F’ + 1 字节标志名长度 + 标志名 -&gt; 1 字节布尔值： 开或关的多种标志</strong></li>
<li><strong>‘t’ + 32 字节交易 hash -&gt; 交易索引记录</strong></li>
</ol>
<p>在 <strong>chainstate</strong>, <strong>key -&gt; value</strong> 对应关系是这样的：</p>
<ol>
<li><strong>‘c’ + 32 字节交易 hash -&gt; 未使用的交易出账记录</strong></li>
<li><strong>‘B’ -&gt; 32 字节区块 hash： 数据库应该表示的未使用交易出账的区块哈希</strong></li>
</ol>
<p>（更详细的解释可以在<a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage">这里</a>找到）</p>
<p>因为我们现在还不需要交易，我们只需要有一个__blocks__桶就可以。同时，就像前面说的，我们将以单个文件的形式存储在数据库中，不需要在分开的文件中存储区块。所以我们也不需要任何与文件相关的数字编号。因此，我们只需要这些键值的对应关系：</p>
<ol>
<li><strong>32 字节区块 hash -&gt; 区块数据(序列化后的)</strong></li>
<li><strong>‘l’ -&gt; 链上最后一个区块的 hash</strong></li>
</ol>
<p>以上，是我们在实现持久化之前所需要知道的全部。</p>
<h2 id="序列化">序列化</h2>
<p>如前文所说，在__BoltDB__中数据只能是__[]byte__的形式，我们想存储__Block__结构在数据库中。我们将使用<a href="https://golang.org/pkg/encoding/gob/">encoding/gob</a>来对结构体进行序列化。</p>
<p>让我们实现区块的__Serialize__方法（为了简洁，我们暂时忽略错误处理）：</p>
<pre><code class="language-go">func (b *Block) Serialize() []byte {
	var result bytes.Buffer
	encoder := gob.NewEncoder(&amp;result)

	err := encoder.Encode(b)

	return result.Bytes()
}
</code></pre>
<p>这个模块非常直接了当：首先，我们为所要序列化的数据定义了一个buffer来存储；然后我们初始化了一个__gob encoder__并且对区块进行编码；结果以一个字节数组的形式返回。</p>
<p>接下来，我们需要一个反序列化的函数接受输入的字节数组并返回一个__Block__区块。这不是一个方法而是一个独立的函数：</p>
<pre><code class="language-go">func DeserializeBlock(d []byte) *Block {
	var block Block

	decoder := gob.NewDecoder(bytes.NewReader(d))
	err := decoder.Decode(&amp;block)

	return &amp;block
}
</code></pre>
<p>这就是反序列化了！</p>
<h2 id="持久化">持久化</h2>
<p>让我们开始__NewBlockchain__函数。目前，它创建一个新的__Blockchain__并且添加一个创世纪块进去。我们希望它可以做：</p>
<ol>
<li>打开一个数据库文件。</li>
<li>检查里面是否以及存在一个区块链在里面。</li>
<li>如果这里已经有了一个区块链：
<ol>
<li>创建一个新的区块链实例。</li>
<li>设置这个区块链实例的__tip__为数据库中最后一个区块的哈希。</li>
</ol>
</li>
</ol>
<p>代码中，它看起来像：</p>
<pre><code class="language-go">func NewBlockchain() *Blockchain {
	var tip []byte
	db, err := bolt.Open(dbFile, 0600, nil)

	err = db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))

		if b == nil {
			genesis := NewGenesisBlock()
			b, err := tx.CreateBucket([]byte(blocksBucket))
			err = b.Put(genesis.Hash, genesis.Serialize())
			err = b.Put([]byte(&quot;l&quot;), genesis.Hash)
			tip = genesis.Hash
		} else {
			tip = b.Get([]byte(&quot;l&quot;))
		}

		return nil
	})

	bc := Blockchain{tip, db}

	return &amp;bc
}
</code></pre>
<p>让我们分开来看：</p>
<pre><code class="language-go">db, err := bolt.Open(dbFile, 0600, nil)
</code></pre>
<p>这是打开一个__BoltDB__数据库文件的标准形式。需要注意的是，如果没有文件它是不会返回错误的。</p>
<pre><code class="language-go">err = db.Update(func(tx *bolt.Tx) error {
...
})
</code></pre>
<p>在__BoltDB__中，数据库通过一个事务进行操作。这里有两种事务：只读（read-only）和读写（read-write）。这里我们开启一个读写事务（<strong>db.Update(...)</strong>），因为我们希望将创世纪块写入数据库。</p>
<pre><code class="language-go">b := tx.Bucket([]byte(blocksBucket))

if b == nil {
	genesis := NewGenesisBlock()
	b, err := tx.CreateBucket([]byte(blocksBucket))
	err = b.Put(genesis.Hash, genesis.Serialize())
	err = b.Put([]byte(&quot;l&quot;), genesis.Hash)
	tip = genesis.Hash
} else {
	tip = b.Get([]byte(&quot;l&quot;))
}
</code></pre>
<p>这是这个函数的核心。在这里，我们获得了一个bucket去存储我们的区块：如果它存在，我们从里面读取键值&quot;l&quot;（字母L小写，不是1）；如果不存在，我们就生成一个创世纪块，创建一个桶，将区块保存进去，之后更新&quot;l&quot;键，使其存储区块链的最后一个区块的哈希。</p>
<p>同时，注意一下创建__Blockchain__的新方法：</p>
<pre><code class="language-go">bc := Blockchain{tip, db}
</code></pre>
<p>我们不再存储所有的区块，取而代之的是仅仅存储区块链的__tip__。同时我们也保存一个数据库连接，因为我们想只打开它一次，并且让它在程序运行的过程中一直保持着连接。所以，__Blockchain__结构看起来就像这样：</p>
<pre><code class="language-go">type Blockchain struct {
	tip []byte
	db  *bolt.DB
}
</code></pre>
<p>接下来我们想做的就是更新__AddBlock__方法：现在添加区块到区块链上不是简单的向数组中添加一个元素了。从现在开始我们将把区块存储到数据库中：</p>
<pre><code class="language-go">func (bc *Blockchain) AddBlock(data string) {
	var lastHash []byte

	err := bc.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		lastHash = b.Get([]byte(&quot;l&quot;))

		return nil
	})

	newBlock := NewBlock(data, lastHash)

	err = bc.db.Update(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		err := b.Put(newBlock.Hash, newBlock.Serialize())
		err = b.Put([]byte(&quot;l&quot;), newBlock.Hash)
		bc.tip = newBlock.Hash

		return nil
	})
}
</code></pre>
<p>让我们一部分一部分进行分析：</p>
<pre><code class="language-go">err := bc.db.View(func(tx *bolt.Tx) error {
	b := tx.Bucket([]byte(blocksBucket))
	lastHash = b.Get([]byte(&quot;l&quot;))

	return nil
})
</code></pre>
<p>这是__BoltDB__数据库的另一种事务：只读（read-only）。这里我们从数据库中得到了最后一个区块的哈希，用来挖新的区块哈希。</p>
<pre><code class="language-go">newBlock := NewBlock(data, lastHash)
b := tx.Bucket([]byte(blocksBucket))
err := b.Put(newBlock.Hash, newBlock.Serialize())
err = b.Put([]byte(&quot;l&quot;), newBlock.Hash)
bc.tip = newBlock.Hash
</code></pre>
<p>在挖出新区块之后，我们将其序列化特征值存储到数据库中，并且更新&quot;l&quot;键，让它保存最新区块的哈希。</p>
<p>完成了！并不是很难，对吗！</p>
<h2 id="检查区块链">检查区块链</h2>
<p>所有的新区块现在保存在数据库中，所以我们现在可以重新打开这条链并且向其中添加新的区块。但是在实现了这些后，我们失去了一个非常好的特性：我们不能打印区块链中的区块了，因为我们不再像以前那样存储区块了。让我们修复这个瑕疵！</p>
<p>__BoltDB__数据库允许对桶里的所有key进行迭代，但是所有的key都以字节顺序存储，我们又想以区块在区块链中的顺序进行打印。而且，因为我们不想加载内存中所有的区块（我们的区块链存储数据可能非常庞大！或者假装是这样），我们将把它们一个一个读出来。为此，我们需要一个区块链迭代器：</p>
<pre><code class="language-go">type BlockchainIterator struct {
	currentHash []byte
	db          *bolt.DB
}
</code></pre>
<p>每一个迭代器将在区块链中的区块需要迭代时创建，并且它将会保存当前迭代区块的哈希和一个数据库连接。因为后面的，一个迭代器附属于一个区块（这里的区块链是指存储了一个数据库连接的__Blockchain__实例），因此我们需要通过__Blockchain__方法进行创建：</p>
<pre><code class="language-go">func (bc *Blockchain) Iterator() *BlockchainIterator {
	bci := &amp;BlockchainIterator{bc.tip, bc.db}

	return bci
}
</code></pre>
<p>注意的是，最初一个迭代器初始指向区块链的tip，所以区块将会被从顶到底获取，从最近创建的到最久之前创建的获取（我们这里把区块链想象成一个桶，最早创建的落在桶底，最晚（新）创建的在上面）。实际上，<strong>选择一个tip就意味着给一条链投票</strong>。一条区块链可以有多个分支，最长的那条被认为是主分支。在得到tip之后（它可以是区块链中的任意一个区块）我们就可以复现整条链，找到它的长度和构建它所需要的工作。这也同样意味着，一个tip也就是区块链的一种标识符。</p>
<p>__BlockchainIterator__将只做一件事情：从一条区块链中返回下一个区块。</p>
<pre><code class="language-go">func (i *BlockchainIterator) Next() *Block {
	var block *Block

	err := i.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(blocksBucket))
		encodedBlock := b.Get(i.currentHash)
		block = DeserializeBlock(encodedBlock)

		return nil
	})

	i.currentHash = block.PrevBlockHash

	return block
}
</code></pre>
<p>这就是数据库部分！</p>
<h2 id="命令行接口cli">命令行接口（CLI）</h2>
<p>截止到目前，我们的实现没有提供任何程序交互接口：我们只是很简单的在__main__函数中执行__NewBlockchain__和__bc.AddBlock__。是时候改进它了！我们想要这样的命令：</p>
<pre><code class="language-go">blockchain_go addblock &quot;Pay 0.031337 for a coffee&quot;
blockchain_go printchain
</code></pre>
<p>所有的与命令行相关的操作将交给__CLI__结构体进行处理：</p>
<pre><code class="language-go">type CLI struct {
	bc *Blockchain
}
</code></pre>
<p>它的入口在__Run__函数中：</p>
<pre><code class="language-go">func (cli *CLI) Run() {
	cli.validateArgs()

	addBlockCmd := flag.NewFlagSet(&quot;addblock&quot;, flag.ExitOnError)
	printChainCmd := flag.NewFlagSet(&quot;printchain&quot;, flag.ExitOnError)

	addBlockData := addBlockCmd.String(&quot;data&quot;, &quot;&quot;, &quot;Block data&quot;)

	switch os.Args[1] {
	case &quot;addblock&quot;:
		err := addBlockCmd.Parse(os.Args[2:])
	case &quot;printchain&quot;:
		err := printChainCmd.Parse(os.Args[2:])
	default:
		cli.printUsage()
		os.Exit(1)
	}

	if addBlockCmd.Parsed() {
		if *addBlockData == &quot;&quot; {
			addBlockCmd.Usage()
			os.Exit(1)
		}
		cli.addBlock(*addBlockData)
	}

	if printChainCmd.Parsed() {
		cli.printChain()
	}
}
</code></pre>
<p>我们使用标准包__<a href="https://golang.org/pkg/flag/">flag</a>__来解析命令行参数。</p>
<pre><code class="language-go">addBlockCmd := flag.NewFlagSet(&quot;addblock&quot;, flag.ExitOnError)
printChainCmd := flag.NewFlagSet(&quot;printchain&quot;, flag.ExitOnError)
addBlockData := addBlockCmd.String(&quot;data&quot;, &quot;&quot;, &quot;Block data&quot;)
</code></pre>
<p>首先，我们创建两个子命令__addblock__和__printchain__，然后我们添加__-data__标志在其中。__printchain__不需要任何标志。</p>
<pre><code class="language-go">switch os.Args[1] {
case &quot;addblock&quot;:
	err := addBlockCmd.Parse(os.Args[2:])
case &quot;printchain&quot;:
	err := printChainCmd.Parse(os.Args[2:])
default:
	cli.printUsage()
	os.Exit(1)
}
</code></pre>
<p>然后，我们检查用户提供的命令并且解析相关的__flag__子命令。</p>
<pre><code class="language-go">if addBlockCmd.Parsed() {
	if *addBlockData == &quot;&quot; {
		addBlockCmd.Usage()
		os.Exit(1)
	}
	cli.addBlock(*addBlockData)
}

if printChainCmd.Parsed() {
	cli.printChain()
}
</code></pre>
<p>接下来，我们检查哪个子命令被解析了然后运行相关的函数：</p>
<pre><code class="language-go">func (cli *CLI) addBlock(data string) {
	cli.bc.AddBlock(data)
	fmt.Println(&quot;Success!&quot;)
}

func (cli *CLI) printChain() {
	bci := cli.bc.Iterator()

	for {
		block := bci.Next()

		fmt.Printf(&quot;Prev. hash: %x\n&quot;, block.PrevBlockHash)
		fmt.Printf(&quot;Data: %s\n&quot;, block.Data)
		fmt.Printf(&quot;Hash: %x\n&quot;, block.Hash)
		pow := NewProofOfWork(block)
		fmt.Printf(&quot;PoW: %s\n&quot;, strconv.FormatBool(pow.Validate()))
		fmt.Println()

		if len(block.PrevBlockHash) == 0 {
			break
		}
	}
}
</code></pre>
<p>这部分非常类似于我们前面的那个。唯一的不同是我们现在使用了一个__BlockchainIterator__去迭代区块链中的区块。</p>
<p>当然也不要忘了__main__函数中相应的修改：</p>
<pre><code class="language-go">func main() {
	bc := NewBlockchain()
	defer bc.db.Close()

	cli := CLI{bc}
	cli.Run()
}
</code></pre>
<p>注意，无论提供哪一个命令行参数都会创建一个新的区块链。</p>
<p>完事儿了！让我们检查一切的运行是否如我们所愿：</p>
<pre><code class="language-go">$ blockchain_go printchain
No existing blockchain found. Creating a new one...
Mining the block containing &quot;Genesis Block&quot;
000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b

Prev. hash:
Data: Genesis Block
Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
PoW: true

$ blockchain_go addblock -data &quot;Send 1 BTC to Ivan&quot;
Mining the block containing &quot;Send 1 BTC to Ivan&quot;
000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13

Success!

$ blockchain_go addblock -data &quot;Pay 0.31337 BTC for a coffee&quot;
Mining the block containing &quot;Pay 0.31337 BTC for a coffee&quot;
000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148

Success!

$ blockchain_go printchain
Prev. hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13
Data: Pay 0.31337 BTC for a coffee
Hash: 000000aa0748da7367dec6b9de5027f4fae0963df89ff39d8f20fd7299307148
PoW: true

Prev. hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
Data: Send 1 BTC to Ivan
Hash: 000000d7b0c76e1001cdc1fc866b95a481d23f3027d86901eaeb77ae6d002b13
PoW: true

Prev. hash:
Data: Genesis Block
Hash: 000000edc4a82659cebf087adee1ea353bd57fcd59927662cd5ff1c4f618109b
PoW: true
</code></pre>
<blockquote>
<p>Github的译者版本附加的测试：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/09/06/J2CDZjOVmgfW1qN.png" alt="" loading="lazy"></figure>
</blockquote>
<p>(看起来可以开酒（🍷or🍺）了)</p>
<h2 id="总结">总结</h2>
<p>接下来我们将实现地址、钱包以及交易（或许也有）。尽情期待！</p>
<p>Links：</p>
<ol>
<li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_3">Full source codes</a></li>
<li><a href="https://en.bitcoin.it/wiki/Bitcoin_Core_0.11_(ch_2):_Data_Storage">Bitcoin Core Data Storage</a></li>
<li><a href="https://github.com/boltdb/bolt">boltdb</a></li>
<li><a href="https://golang.org/pkg/encoding/gob/">encoding/gob</a></li>
<li><a href="https://golang.org/pkg/flag/">flag</a></li>
</ol>
]]></content>
    </entry>
</feed>