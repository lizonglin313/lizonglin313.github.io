<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Python中的正则表达式 | Big Carrot</title>
<link rel="shortcut icon" href="https://lizonglin313.github.io//favicon.ico?v=1579677801561">
<link href="https://cdn.remixicon.com/releases/v2.1.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://lizonglin313.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Python中的正则表达式 | Big Carrot - Atom Feed" href="https://lizonglin313.github.io//atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
本篇主要介绍Python正则表达式的re库的基本使用方法。
本篇主要内容的整理来自于：
Python-re库的官方文档
Python-0-100天正则表达式部分
正则表达式30分钟入门

什么是正则表达式
在编写处理字符串的程序或网页时，..." />
    <meta name="keywords" content="Python,数据分析" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lizonglin313.github.io/">
  <img class="avatar" src="https://lizonglin313.github.io//images/avatar.png?v=1579677801561" alt="">
  </a>
  <h1 class="site-title">
    Big Carrot
  </h1>
  <p class="site-description">
    人们依然相信未来会更精彩
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://lizonglin313.github.io/post/friends" class="menu">
          朋友
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/lizonglin313" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
        <a href="https://weibo.com/u/3645767403?nick=lizonglin_TNcarrot&amp;is_hot=1" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Python中的正则表达式
            </h2>
            <div class="post-info">
              <span>
                2019-07-15
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://lizonglin313.github.io/tag/ywt-yiKCrM" class="post-tag">
                  # Python
                </a>
              
                <a href="https://lizonglin313.github.io/tag/BTYsGEfIl3" class="post-tag">
                  # 数据分析
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <blockquote>
<p>本篇主要介绍Python正则表达式的re库的基本使用方法。</p>
<p>本篇主要内容的整理来自于：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/re.html">Python-re库的官方文档</a></p>
<p><a href="%5Bhttps://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md%5D(https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md)">Python-0-100天正则表达式部分</a></p>
<p><a href="https://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门</a></p>
</blockquote>
<h1 id="什么是正则表达式">什么是正则表达式</h1>
<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。<strong>正则表达式</strong>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p>
<p>换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p>
<p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p>
<h1 id="正则表达式中的基本符号扼要总结">正则表达式中的基本符号扼要总结</h1>
<h2 id="匹配类型">匹配类型</h2>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">解释</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">匹配任意字符</td>
<td style="text-align:left">b.t</td>
<td style="text-align:left">可以匹配bat/but/b#t/b2t等</td>
</tr>
<tr>
<td style="text-align:left">\w</td>
<td style="text-align:left">匹配字母/数字/下划线</td>
<td style="text-align:left">b\wt</td>
<td style="text-align:left">可以匹配bat/but/b_t等 但是不能匹配b#t</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">匹配空白字符(包括\t、\n、\r)</td>
<td style="text-align:left">love\syou</td>
<td style="text-align:left">可以匹配love you</td>
</tr>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:left">匹配数字</td>
<td style="text-align:left">\d\d</td>
<td style="text-align:left">可以匹配01/99/34/54等</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">匹配单词的边界</td>
<td style="text-align:left">\bThe\b</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">匹配字符串的开始</td>
<td style="text-align:left">^The</td>
<td style="text-align:left">可以匹配The开头的字符串</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">匹配字符串的结束</td>
<td style="text-align:left">$.exe</td>
<td style="text-align:left">可以匹配.exe结束的字符串</td>
</tr>
<tr>
<td style="text-align:left">\W</td>
<td style="text-align:left">匹配非(字母/数字/下划线)</td>
<td style="text-align:left">b\Wt</td>
<td style="text-align:left">可以匹配b@t/b#t等 但是不能匹配b1t/but/b_t等</td>
</tr>
<tr>
<td style="text-align:left">\S</td>
<td style="text-align:left">匹配非空白字符</td>
<td style="text-align:left">love\Syou</td>
<td style="text-align:left">可以匹配love#you等 但是不能匹配love you</td>
</tr>
<tr>
<td style="text-align:left">\D</td>
<td style="text-align:left">匹配非数字</td>
<td style="text-align:left">\d\D</td>
<td style="text-align:left">可以匹配3#/5f/6^等</td>
</tr>
<tr>
<td style="text-align:left">\B</td>
<td style="text-align:left">匹配非单词边界</td>
<td style="text-align:left">\Bio\B</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="匹配次数及组合匹配">匹配次数及组合匹配</h2>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>匹配来自字符集的任意单一字符</td>
<td>[aeiou]</td>
<td>可以匹配任一元音字母字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在字符集中的任意单一字符</td>
<td>[^aeiou]</td>
<td>可以匹配任一非元音字母字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0次或多次</td>
<td>\w*</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>匹配1次或多次</td>
<td>\w+</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>匹配0次或1次</td>
<td>\w?</td>
<td></td>
</tr>
<tr>
<td>{N}</td>
<td>匹配N次</td>
<td>\w{3}</td>
<td></td>
</tr>
<tr>
<td>{M,}</td>
<td>匹配至少M次</td>
<td>\w{3,}</td>
<td></td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配至少M次至多N次</td>
<td>\w{3,6}</td>
<td></td>
</tr>
<tr>
<td>(?#)</td>
<td>注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(exp)</td>
<td>匹配exp并捕获到自动命名的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(? &lt;name&gt;exp)</td>
<td>匹配exp并捕获到名为name的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?:exp)</td>
<td>匹配exp但是不捕获匹配的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?=exp)</td>
<td>匹配exp前面的位置</td>
<td>\b\w+(?=ing)</td>
<td>可以匹配I'm dancing中的danc</td>
</tr>
<tr>
<td>(?&lt;=exp)</td>
<td>匹配exp后面的位置</td>
<td>(?&lt;=\bdanc)\w+\b</td>
<td>可以匹配I love dancing and reading中的第一个ing</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>匹配后面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
<td>a.*b a.*?b</td>
<td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或多次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,N}?</td>
<td>重复M到N次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,}?</td>
<td>重复M次以上，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。</p>
</blockquote>
<h1 id="python对正则表达式的支持">Python对正则表达式的支持</h1>
<blockquote>
<p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p>
</blockquote>
<h2 id="re模块中的核心函数">re模块中的核心函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>complie(pattern, flags=0)</td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td>match(pattern, string, flags=0)</td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>search(pattern, string, flags=0)</td>
<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>split(pattern, repl, string, count=0, flags=0)</td>
<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td>sub(pattern, repl, string, count=0, flags=0)</td>
<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td>
</tr>
<tr>
<td>fullmatch(pattern, string, flags=0)</td>
<td>match函数的完全匹配（从字符串开头到结尾）版本</td>
</tr>
<tr>
<td>findall(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>
</tr>
<tr>
<td>finditer(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>
</tr>
<tr>
<td>purge()</td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td>re.I / re.IGNORECASE</td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td>re.M / re.MULTILINE</td>
<td>多行匹配标记</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>说明：</strong> 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">什么是正则表达式</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7%E6%89%BC%E8%A6%81%E6%80%BB%E7%BB%93">正则表达式中的基本符号扼要总结</a>
<ul>
<li><a href="#%E5%8C%B9%E9%85%8D%E7%B1%BB%E5%9E%8B">匹配类型</a></li>
<li><a href="#%E5%8C%B9%E9%85%8D%E6%AC%A1%E6%95%B0%E5%8F%8A%E7%BB%84%E5%90%88%E5%8C%B9%E9%85%8D">匹配次数及组合匹配</a></li>
</ul>
</li>
<li><a href="#python%E5%AF%B9%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%94%AF%E6%8C%81">Python对正则表达式的支持</a>
<ul>
<li><a href="#re%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0">re模块中的核心函数</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lizonglin313.github.io/post/解决Pycharm出现Runtime-Error-R6034的报错">
              <h3 class="post-title">
                解决Pycharm出现Runtime Error R6034的报错
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://lizonglin313.github.io//atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
